package co.blocke.scalajack
package json

import writing.*
import co.blocke.scala_reflection.{RTypeRef, TypedName}
import co.blocke.scala_reflection.reflect.rtypeRefs.*
import co.blocke.scala_reflection.reflect.ReflectOnType
import co.blocke.scala_reflection.rtypes.{EnumRType, JavaClassRType, NonConstructorFieldInfo}
import co.blocke.scala_reflection.given
import reading.JsonSource
import scala.jdk.CollectionConverters.*
import scala.quoted.*
import scala.reflect.ClassTag
import scala.annotation.{switch, tailrec}
import scala.collection.Factory
import scala.util.{Failure, Success, Try}
import dotty.tools.dotc.ast.Trees.EmptyTree
import org.apache.commons.text.StringEscapeUtils
import org.apache.commons.lang3.text.translate.CharSequenceTranslator
import dotty.tools.dotc.core.TypeComparer.AnyConstantType
import scala.jdk.CollectionConverters.*

object JsonCodecMaker:

  def generateCodecFor[T](ref: RTypeRef[T], cfg: SJConfig)(using q: Quotes)(using tt: Type[T]) =
    import q.reflect.*

    // Cache generated method Symbols + an array of the generated functions (DefDef)
    case class MethodKey(ref: RTypeRef[?], isNonConstructorFields: Boolean)

    // Used to trap recusive endless loops when processing SelfREf's
    val reflectMap = scala.collection.mutable.Map.empty[TypedName, Boolean]

    val readMethodSyms = new scala.collection.mutable.HashMap[MethodKey, Symbol]
    val readMethodDefs = new scala.collection.mutable.ArrayBuffer[DefDef]

    def makeReadFn[U: Type](methodKey: MethodKey, in: Expr[JsonSource])(f: Expr[JsonSource] => Expr[U])(using Quotes)(using Type[JsonSource]): Expr[Unit] =
      readMethodSyms.getOrElseUpdate(
        methodKey, {
          val sym = Symbol.newMethod(
            Symbol.spliceOwner,
            "r" + readMethodSyms.size,
            MethodType(List("in"))(_ => List(TypeRepr.of[JsonSource]), _ => TypeRepr.of[U])
          )
          readMethodDefs += DefDef(
            sym,
            params => {
              val List(List(in)) = params
              Some(f(in.asExprOf[JsonSource]).asTerm.changeOwner(sym))
            }
          )
          sym // <<< PATCH: now returns sym so the cache has it immediately, allowing recursive references
        }
      )
      '{} // still return dummy expression

    def makeReadFnX[U: Type](methodKey: MethodKey, in: Expr[JsonSource])(f: Expr[JsonSource] => Expr[U])(using Quotes)(using Type[JsonSource]): Expr[Unit] =
      readMethodSyms.getOrElse(
        methodKey, {
          val sym = Symbol.newMethod(
            Symbol.spliceOwner,
            "r" + readMethodSyms.size,
            MethodType(List("in"))(_ => List(TypeRepr.of[JsonSource]), _ => TypeRepr.of[U])
            //                    (_ => List(input_params,...), _ => resultType)
          )
          readMethodSyms.update(methodKey, sym)
          readMethodDefs += DefDef(
            sym,
            params => {
              val List(List(in)) = params
              Some(f(in.asExprOf[JsonSource]).asTerm.changeOwner(sym))
            }
          )
        }
      )
      '{}

    val classFieldMatrixSyms = new scala.collection.mutable.HashMap[MethodKey, Symbol]
    val classFieldMatrixValDefs = new scala.collection.mutable.ArrayBuffer[ValDef]

    def makeClassFieldMatrixValDef(methodKey: MethodKey, className: String, fieldNames: Array[String])(using Quotes): Expr[Unit] =
      classFieldMatrixSyms.getOrElse(
        methodKey, {
          val sym = Symbol.newVal(
            Symbol.spliceOwner,
            s"__$className" + "_fields",
            TypeRepr.of[StringMatrix],
            Flags.EmptyFlags,
            Symbol.noSymbol
          )
          classFieldMatrixSyms.update(methodKey, sym)
          val names = Expr(fieldNames)
          classFieldMatrixValDefs += ValDef(sym, Some('{ new StringMatrix($names) }.asTerm))
        }
      )
      '{}

    inline def changeFieldName(fr: FieldInfoRef): String = fr.annotations.get("co.blocke.scalajack.Change").flatMap(_.get("name")).getOrElse(fr.name)

    // ---------------------------------------------------------------------------------------------

    def lrHasOptionChild(lr: LeftRightRef[?]): (String, Language) =
      lr.rightRef match
        case t: ScalaOptionRef[?]  => ("r", Language.Scala)
        case t: JavaOptionalRef[?] => ("r", Language.Java)
        case t: LeftRightRef[?] =>
          val (recipe, lang) = lrHasOptionChild(t)
          ("r" + recipe, lang)
        case _ =>
          lr.leftRef match
            case t: ScalaOptionRef[?]  => ("l", Language.Scala)
            case t: JavaOptionalRef[?] => ("l", Language.Java)
            case t: LeftRightRef[?] =>
              val (recipe, lang) = lrHasOptionChild(t)
              ("l" + recipe, lang)
            case _ => ("", Language.Scala)

    def tryHasOptionChild(t: TryRef[?]): (Boolean, Language) =
      t.tryRef match
        case o: ScalaOptionRef[?]  => (true, Language.Scala)
        case o: JavaOptionalRef[?] => (true, Language.Java)
        case lr: LeftRightRef[?] =>
          val (recipe, lang) = lrHasOptionChild(lr)
          (recipe.length > 0, lang)
        case _ => (false, Language.Scala)

    def genDecFnBody[T: Type](r: RTypeRef[?], in: Expr[JsonSource])(using Quotes): Expr[Unit] =

      def typeArgs(tpe: TypeRepr): List[TypeRepr] = tpe match
        case AppliedType(_, typeArgs) => typeArgs.map(_.dealias)
        case _                        => Nil

      r.refType match // refType is Type[r.R]
        case '[b] =>
          r match

            case t: Sealable if t.isSealed && !t.childrenAreObject =>
              val methodKey = MethodKey(t, false)
              val _ = makeReadFn[T](methodKey, '{ ??? }) // placeholder

              // Generate readers for all sealed children
              t.sealedChildren.foreach { case kid =>
                kid.refType match
                  case '[c] => genDecFnBody[c](kid.asInstanceOf[RTypeRef[c]], in)
              }

              val realSym = readMethodSyms(methodKey)

              // Replace placeholder with actual DefDef
              readMethodDefs -= readMethodDefs.find(_.symbol == realSym).get
              readMethodDefs += DefDef(
                realSym,
                { case List(List(inParam)) =>
                  val localIn = Ref(inParam.symbol).asExprOf[JsonSource]

                  val hintLabelE = Expr(cfg.typeHintLabel)
                  val classPrefixE = Expr(allButLastPart(t.name))

                  val caseDefs = t.sealedChildren.map { childRef =>
                    val childNameE = Expr(childRef.name)
                    val methodKey = MethodKey(childRef, false)

                    cfg.typeHintPolicy match
                      case TypeHintPolicy.SCRAMBLE_CLASSNAME =>
                        val sym = Symbol.newBind(Symbol.spliceOwner, "t", Flags.EmptyFlags, TypeRepr.of[String])
                        CaseDef(
                          Bind(sym, Typed(Wildcard(), Inferred(TypeRepr.of[String]))),
                          Some({
                            val tE = Ref(sym).asExprOf[String]
                            '{ descramble($tE, lastPart($childNameE).hashCode) }.asTerm
                          }),
                          Apply(Ref(readMethodSyms(methodKey)), List(localIn.asTerm)).asExprOf[T].asTerm
                        )

                      case TypeHintPolicy.USE_ANNOTATION =>
                        val hintValue = childRef match
                          case cr: ClassRef[?] =>
                            cr.annotations
                              .get("co.blocke.scalajack.TypeHint")
                              .flatMap(_.get("hintValue"))
                              .getOrElse(lastPart(cr.name))
                          case _ => lastPart(childRef.name)

                        CaseDef(
                          Literal(StringConstant(hintValue)),
                          None,
                          Apply(Ref(readMethodSyms(methodKey)), List(localIn.asTerm)).asExprOf[T].asTerm
                        )

                      case TypeHintPolicy.SIMPLE_CLASSNAME =>
                        CaseDef(
                          Literal(StringConstant(childRef.name)),
                          None,
                          Apply(Ref(readMethodSyms(methodKey)), List(localIn.asTerm)).asExprOf[T].asTerm
                        )
                  }

                  val unique = Unique.findUniqueWithExcluded(t)
                  val excludeFields = Expr(unique.optionalFields)
                  val liftedUnique = liftStringMap(unique.simpleUniqueHash)
                  val tname = Expr(t.name)

                  val matchCases: List[CaseDef] = t.sealedChildren.flatMap { classRef =>
                    val methodKey = MethodKey(classRef, false)
                    readMethodSyms.get(methodKey).map { sym =>
                      val cond = Literal(StringConstant(classRef.name))
                      val rhs = Apply(Ref(sym), List(localIn.asTerm)).asExprOf[T].asTerm
                      CaseDef(cond, None, rhs)
                    }
                  }

                  val traitExpr: Expr[T] = '{
                    if $localIn.expectNull() then null
                    else {
                      $localIn.findObjectField($hintLabelE) match {
                        case Some(hint) =>
                          ${
                            cfg.typeHintPolicy match
                              case TypeHintPolicy.SIMPLE_CLASSNAME =>
                                Match('{ $classPrefixE + "." + hint }.asTerm, caseDefs).asExprOf[T]
                              case TypeHintPolicy.SCRAMBLE_CLASSNAME =>
                                Match('{ hint }.asTerm, caseDefs).asExprOf[T]
                              case TypeHintPolicy.USE_ANNOTATION =>
                                Match('{ hint }.asTerm, caseDefs).asExprOf[T]
                          }
                        case None =>
                          val fields = $localIn.findAllFieldNames()
                          val fingerprint = Unique.hashOf(fields.filterNot($excludeFields.contains))
                          val className = $liftedUnique
                            .get(fingerprint)
                            .getOrElse(
                              $liftedUnique
                                .get("")
                                .getOrElse(
                                  throw new JsonParseError("Class in trait " + $tname + s" with parsed fields [${fields.mkString(",")}] needed a type hint but none was found (ambiguous)", $localIn)
                                )
                            )
                          ${ Match('{ className }.asTerm, matchCases).asExprOf[T] }
                      }
                    }
                  }.asExprOf[T]

                  Some(traitExpr.asTerm.changeOwner(realSym))
                }
              )

              '{ () }

            case t: ScalaClassRef[?] =>
              makeReadFn[T](MethodKey(t, false), in)(in =>
                // Generate vars for each contractor argument, populated with either a "unit" value (eg 0, "") or given default value
                val tpe = TypeRepr.of[b]
                val classCompanion = tpe.typeSymbol.companionClass
                val companionModule = tpe.typeSymbol.companionModule
                val totalRequired = math.pow(2, t.fields.length).toInt - 1
                var required = 0
                val reqSym = Symbol.newVal(Symbol.spliceOwner, "required", TypeRepr.of[Int], Flags.Mutable, Symbol.noSymbol)
                val allFieldNames = Expr(t.fields.map(f => changeFieldName(f)).toArray) // Used for missing required field error

                val together = t.fields.map { oneField =>
                  oneField.fieldRef.refType match {
                    case '[f] =>
                      val dvMembers = classCompanion.methodMember("$lessinit$greater$default$" + (oneField.index + 1))
                      val sym = Symbol.newVal(Symbol.spliceOwner, "_" + oneField.name, TypeRepr.of[f], Flags.Mutable, Symbol.noSymbol)
                      val fieldSymRef = Ident(sym.termRef)
                      val reqBit = Expr(math.pow(2, oneField.index).toInt)
                      val fieldName = Expr(oneField.name)

                      val caseDef = CaseDef(
                        Literal(IntConstant(oneField.index)),
                        None,
                        '{
                          if (${ Ref(reqSym).asExprOf[Int] } & $reqBit) != 0 then
                            ${ Assign(Ref(reqSym), '{ ${ Ref(reqSym).asExprOf[Int] } ^ $reqBit }.asTerm).asExprOf[Unit] }
                            ${ Assign(fieldSymRef, genReadVal[f](oneField.fieldRef.asInstanceOf[RTypeRef[f]], in).asTerm).asExprOf[Unit] }
                          else throw new JsonParseError("Duplicate field " + $fieldName, $in)
                        }.asTerm
                      )
                      if dvMembers.isEmpty then
                        // no default... required?  Not if Option/Optional, or a collection
                        val unitVal = oneField.fieldRef match {
                          case _: OptionRef[?] =>
                            oneField.fieldRef.unitVal.asTerm // not required
                          case _: AnyRef =>
                            oneField.fieldRef.unitVal.asTerm // not required
                          case r: LeftRightRef[?] if r.lrkind == LRKind.EITHER => // maybe required
                            val (optionRecipe, lang) = lrHasOptionChild(r)
                            if optionRecipe.length == 0 then
                              required = required | math.pow(2, oneField.index).toInt // required
                              oneField.fieldRef.unitVal.asTerm
                            else
                              val recipeE = Expr(optionRecipe)
                              if lang == Language.Scala then
                                '{
                                  $recipeE.foldRight(None: Any)((c, acc) => if c == 'r' then Right(acc) else Left(acc)).asInstanceOf[f]
                                }.asTerm
                              else
                                '{
                                  $recipeE.foldRight(java.util.Optional.empty: Any)((c, acc) => if c == 'r' then Right(acc) else Left(acc)).asInstanceOf[f]
                                }.asTerm
                          case r: LeftRightRef[?] => // maybe required
                            val (optionRecipe, lang) = lrHasOptionChild(r)
                            if optionRecipe.length == 0 then // no Option children -> required
                              required = required | math.pow(2, oneField.index).toInt // required
                              oneField.fieldRef.unitVal.asTerm
                            else // at least one Option child -> optional
                            if lang == Language.Scala then '{ None }.asTerm
                            else '{ java.util.Optional.empty.asInstanceOf[f] }.asTerm
                          case y: TryRef[?] =>
                            tryHasOptionChild(y) match
                              case (true, Language.Scala) => '{ Success(None) }.asTerm
                              case (true, Language.Java)  => '{ Success(java.util.Optional.empty).asInstanceOf[f] }.asTerm
                              case _ =>
                                required = required | math.pow(2, oneField.index).toInt // required
                                oneField.fieldRef.unitVal.asTerm
                          case _ =>
                            required = required | math.pow(2, oneField.index).toInt // required
                            oneField.fieldRef.unitVal.asTerm
                        }
                        (ValDef(sym, Some(unitVal)), caseDef, fieldSymRef)
                      else
                        val methodSymbol = dvMembers.head
                        val dvSelectNoTArgs = Ref(companionModule).select(methodSymbol)
                        val dvSelect = methodSymbol.paramSymss match
                          case Nil => dvSelectNoTArgs
                          case List(params) if (params.exists(_.isTypeParam)) =>
                            typeArgs(tpe) match
                              case Nil      => ??? // throw JsonParseError("Expected an applied type", ???)
                              case typeArgs => TypeApply(dvSelectNoTArgs, typeArgs.map(Inferred(_)))
                          case _ => ??? // fail(s"Default method for ${symbol.name} of class ${tpe.show} have a complex " +
                        (ValDef(sym, Some(dvSelect)), caseDef, fieldSymRef)
                  }
                }
                val reqVarDef = ValDef(reqSym, Some(Literal(IntConstant(totalRequired))))
                val (varDefs, caseDefs, idents) = together.unzip3
                val caseDefsWithFinal = caseDefs :+ CaseDef(Wildcard(), None, '{ $in.skipValue() }.asTerm) // skip values of unrecognized fields

                val argss = List(idents)
                val primaryConstructor = tpe.classSymbol.get.primaryConstructor
                val constructorNoTypes = Select(New(Inferred(tpe)), primaryConstructor)
                val constructor = typeArgs(tpe) match
                  case Nil      => constructorNoTypes
                  case typeArgs => TypeApply(constructorNoTypes, typeArgs.map(Inferred(_)))
                val instantiateClass = argss.tail.foldLeft(Apply(constructor, argss.head))((acc, args) => Apply(acc, args))

                val exprRequired = Expr(required)

                makeClassFieldMatrixValDef(MethodKey(t, false), t.name.replaceAll("\\.", "_"), t.fields.map(f => changeFieldName(f)).toArray)
                val fieldMatrixSym = classFieldMatrixSyms(MethodKey(t, false)).asInstanceOf[Symbol]

                var finalVarDefs = varDefs
                val parseLoop =
                  if !cfg._writeNonConstructorFields || t.nonConstructorFields.isEmpty then
                    // When we don't care about non-constructor fields
                    '{
                      var maybeFieldNum = $in.expectFirstObjectField(${ Ref(fieldMatrixSym).asExprOf[StringMatrix] })
                      if maybeFieldNum == null then null.asInstanceOf[T]
                      else
                        while maybeFieldNum.isDefined do
                          ${ Match('{ maybeFieldNum.get }.asTerm, caseDefsWithFinal).asExprOf[Any] }
                          maybeFieldNum = $in.expectObjectField(${ Ref(fieldMatrixSym).asExprOf[StringMatrix] })

                        if (${ Ref(reqSym).asExprOf[Int] } & ${ exprRequired }) == 0 then ${ instantiateClass.asExprOf[T] }
                        else throw new JsonParseError("Missing required field(s) " + ${ allFieldNames }(Integer.numberOfTrailingZeros(${ Ref(reqSym).asExprOf[Int] } & ${ exprRequired })), $in)
                    }.asTerm
                  else
                    val instanceSym = Symbol.newVal(Symbol.spliceOwner, "_instance", TypeRepr.of[T], Flags.Mutable, Symbol.noSymbol)
                    finalVarDefs = finalVarDefs :+ ValDef(instanceSym, Some('{ null }.asTerm)) // add var _instance=null to gen'ed code
                    val instanceSymRef = Ident(instanceSym.termRef)
                    // When we do care about non-constructor fields
                    makeClassFieldMatrixValDef(MethodKey(t, true), t.name.replaceAll("\\.", "_"), t.nonConstructorFields.sortBy(_.index).map(f => changeFieldName(f)).toArray)
                    val fieldMatrixSymNCF = classFieldMatrixSyms(MethodKey(t, true)).asInstanceOf[Symbol]
                    // New Case/Match for non-constructor fields
                    val caseDefsWithFinalNC = t.nonConstructorFields.map(ncf =>
                      ncf.fieldRef.refType match
                        case '[u] =>
                          CaseDef(
                            Literal(IntConstant(ncf.index)),
                            None,
                            // Call the setter for this field here...
                            Apply(Select.unique(Ref(instanceSym), ncf.setterLabel), List(genReadVal[u](ncf.fieldRef.asInstanceOf[RTypeRef[u]], in).asTerm)).asExpr.asTerm
                          )
                    ) :+ CaseDef(Wildcard(), None, '{ $in.skipValue() }.asTerm) // skip values of unrecognized fields
                    '{
                      val mark = $in.pos
                      var maybeFieldNum = $in.expectFirstObjectField(${ Ref(fieldMatrixSym).asExprOf[StringMatrix] })
                      if maybeFieldNum == null then null.asInstanceOf[T]
                      else
                        while maybeFieldNum.isDefined do
                          ${ Match('{ maybeFieldNum.get }.asTerm, caseDefsWithFinal).asExprOf[Any] }
                          maybeFieldNum = $in.expectObjectField(${ Ref(fieldMatrixSym).asExprOf[StringMatrix] })

                        if (${ Ref(reqSym).asExprOf[Int] } & ${ exprRequired }) == 0 then
                          ${ Assign(instanceSymRef, instantiateClass.asExpr.asTerm).asExprOf[Unit] } // _instance = (new instance)
                          $in.revertToPos(mark) // go back to re-parse object json, this time for non-constructor fields
                          maybeFieldNum = $in.expectFirstObjectField(${ Ref(fieldMatrixSymNCF).asExprOf[StringMatrix] })
                          while maybeFieldNum.isDefined do
                            ${ Match('{ maybeFieldNum.get }.asTerm, caseDefsWithFinalNC).asExprOf[Any] }
                            maybeFieldNum = $in.expectObjectField(${ Ref(fieldMatrixSymNCF).asExprOf[StringMatrix] })
                          ${ Ref(instanceSym).asExprOf[T] }
                        else throw new JsonParseError("Missing required field(s) " + ${ allFieldNames }(Integer.numberOfTrailingZeros(${ Ref(reqSym).asExprOf[Int] } & ${ exprRequired })), $in)
                    }.asTerm

                Block(finalVarDefs :+ reqVarDef, parseLoop).asExprOf[T]
              )

            case t => throw new ParseError("Not yet implemented: " + t)

    // ---------------------------------------------------------------------------------------------

    def genReadVal[T: Type](
        ref: RTypeRef[T],
        in: Expr[JsonSource],
        inTuple: Boolean = false,
        isMapKey: Boolean = false
    )(using q: Quotes): Expr[T] =
      val methodKey = MethodKey(ref, false)

      println("GEN for " + ref.name)
      // Insert placeholder early if not already present
      val sym = readMethodSyms.getOrElseUpdate(
        methodKey,
        Symbol.newMethod(
          Symbol.spliceOwner,
          "r" + readMethodSyms.size,
          MethodType(List("in"))(_ => List(TypeRepr.of[JsonSource]), _ => TypeRepr.of[T])
        )
      )
      if !readMethodDefs.exists(_.symbol == sym) then readMethodDefs += DefDef(sym, _ => Some('{ ??? }.asTerm))

      ref match
        // First cover all primitive and simple types...
        case t: BigDecimalRef =>
          if isMapKey then
            '{
              $in.expectString() match
                case null => null
                case s    => scala.math.BigDecimal(s)
            }.asExprOf[T]
          else
            '{
              $in.expectNumberOrNull() match
                case null => null
                case s    => scala.math.BigDecimal(s)
            }.asExprOf[T]

        // --- LOTS OF OTHER REFS HERE

        case t: SelfRefRef[?] =>
          t.refType match
            case '[e] =>
              val ref = ReflectOnType[e](q)(q.reflect.TypeRepr.of[e])(using reflectMap)
              val key = MethodKey(ref, false)
              val sym = readMethodSyms(key)
              Ref(sym).appliedTo(in.asTerm).asExprOf[T]

        case _ =>
          // Classes, traits, etc.
          genDecFnBody[T](ref, in) // Create a new decoder function (presumably for class, trait, etc)
          genReadVal(ref, in, inTuple)

        // Just-created function is present now and will be called

    // ---------------------------------------------------------------------------------------------

    // ================================================================
    // You've made it this far!  Ok, now we sew everything together.
    // We generate a codec class and then kick off a deep traversal of
    // generation from the given root ref (refer waaay back at the top of this fn...).
    // ================================================================
    val codecDef = '{
      new JsonCodec[T] {
        def encodeValue(in: T, out: JsonOutput): Unit = ${ genWriteVal('in, ref, 'out) }
        def decodeValue(in: JsonSource): T = ${ genReadVal(ref, 'in) }
      }
    }.asTerm
    val codec = Block((classFieldMatrixValDefs ++ writeMethodDefs ++ readMethodDefs).toList, codecDef).asExprOf[JsonCodec[T]]
    // println(s"Codec: ${codec.show}")
    codec
