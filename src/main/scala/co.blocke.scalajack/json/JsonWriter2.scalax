package co.blocke.scalajack
package json

import scala.quoted.*
import co.blocke.scala_reflection.*
import co.blocke.scala_reflection.rtypes.*
import co.blocke.scala_reflection.reflect.{ReflectOnType, TypeSymbolMapper}
import co.blocke.scala_reflection.reflect.rtypeRefs.*
import scala.util.{Failure, Success, Try}
import scala.quoted.staging.*

object JsonWriter2:

  // Tests whether we should write something or not--mainly in the case of Option, or wrapped Option
  def isOkToWrite(a: Any, cfg: JsonConfig) =
    a match
      case None if !cfg.noneAsNull                                    => false
      case Left(None) if !cfg.noneAsNull                              => false
      case Right(None) if !cfg.noneAsNull                             => false
      case Failure(_) if cfg.tryFailureHandling == TryOption.NO_WRITE => false
      case _                                                          => true

  def refWrite[T](cfgE: Expr[JsonConfig], rt: RType[T], aE: Expr[T], sbE: Expr[StringBuilder], isMapKey: Boolean = false)(using Quotes)(using tt: Type[T]): Expr[StringBuilder] =
    import quotes.reflect.*

    rt match
      case StringRType() | CharRType() | JavaCharacterRType() => '{ if $aE == null then $sbE.append("null") else $sbE.append("\"" + $aE.toString + "\"") }
      case t: PrimitiveRType => 
        if isMapKey then
          '{
            if $aE == null then $sbE.append("\"null\"")
            else
              $sbE.append('"')
              $sbE.append($aE.toString)
              $sbE.append('"')
          }
        else '{ if $aE == null then $sbE.append("null") else $sbE.append($aE.toString) }

      case t: SeqRType[?] =>
        if isMapKey then throw new JsonError("Seq instances cannot be map keys")

        t.elementType.toType(quotes) match
          case '[e] =>
            '{
              val sb = $sbE
              if $aE == null then sb.append("null")
              else
                sb.append('[')
                val sbLen = sb.length

                $aE.asInstanceOf[Seq[e]].foldLeft(sb) { (acc, one) =>
                  if isOkToWrite(one, $cfgE) then
                    ${ refWrite[e](cfgE, t.elementType.asInstanceOf[RType[e]], '{ one }, '{ acc }) }
                    sb.append(',')
                  else sb
                }

                if sbLen == sb.length then sb.append(']')
                else sb.setCharAt(sb.length() - 1, ']')
            }
      case t: ArrayRType[?] =>
        if isMapKey then throw new JsonError("Arrays instances cannot be map keys")

        t.elementType.toType(quotes) match
          case '[e] =>
            '{
              val sb = $sbE
              if $aE == null then sb.append("null")
              else
                sb.append('[')
                val sbLen = sb.length

                $aE.asInstanceOf[Seq[e]].foldLeft(sb) { (acc, one) =>
                  if isOkToWrite(one, $cfgE) then
                    ${ refWrite[e](cfgE, t.elementType.asInstanceOf[RType[e]], '{ one }, '{ acc }) }
                    sb.append(',')
                  else sb
                }

                if sbLen == sb.length then sb.append(']')
                else sb.setCharAt(sb.length() - 1, ']')
            }

      case t: ClassRType[?] =>
        '{
          val sb = $sbE
          if $aE == null then sb.append("null")
          else
            sb.append('{')
            val sbLen = sb.length
            ${
              t.fields.foldLeft('{ sb }) { (accE, f) =>
                f.fieldType.toType(quotes) match
                  case '[e] =>
                    val fieldValue = Select.unique(aE.asTerm, f.name).asExprOf[e]
                    val name = Expr(f.name)
                    '{
                      val acc = $accE
                      if isOkToWrite($fieldValue, $cfgE) then
                        acc.append('"')
                        acc.append($name)
                        acc.append('"')
                        acc.append(':')
                        val b = ${ refWrite[e](cfgE, f.fieldType.asInstanceOf[RType[e]], fieldValue, '{ acc }) }
                        acc.append(',')
                      else acc
                    }
              }
            }
            if sbLen == sb.length then sb.append('}')
            else sb.setCharAt(sb.length() - 1, '}')
        }

      case t: TraitRType[?] =>
        val foo: Expr[RType[T]] = '{
          // given Compiler = Compiler.make($aE.getClass.getClassLoader)
          val sb = $sbE
          sb.append('{')
          sb.append(s"\"_hint\":\"${$aE.getClass.getName}\"")
          sb.append('}')
          RType.inTermsOf[T]($aE.getClass).asInstanceOf[RType[T]]
          val rt: Expr[RType[T]] = ???
          ${refWrite[T](cfgE, rt.value, aE, sbE)}
        }
        

          // val fn = (q: Quotes) ?=> {
          //   import q.reflect.*
          //   ReflectUtil.inTermsOf2(RType.of[T].asInstanceOf[TraitRType[T]], $aE.getClass).expr.asInstanceOf[Expr[RTypeRef[?]]]
          // }
          // val classRType = quoted.staging.run(fn).asInstanceOf[RType[T]]
          // ${
          //   t.toType(quotes) match
          //     case '[e] =>
            
          // }
          // $sbE
            // val cRT: ScalaClassRType[T] = ???
            // refWrite[T](cfgE, cRT, aE, sbE)

      /*
        given Compiler = Compiler.make(this.getClass.getClassLoader)
        '{
          val refMakerFn = (q: Quotes) ?=>
            import q.reflect.*
            (traitRef: TraitRef[T], inst: T, instE: Expr[T], cfgE: Expr[JsonConfig], sbE2: Expr[StringBuilder]) =>
              val clazz = inst.getClass
              val classRef = ReflectOnType(quotes)(quotes.reflect.TypeRepr.typeConstructorOf(clazz), false)(using scala.collection.mutable.Map.empty[TypedName, Boolean]).asInstanceOf[ScalaClassRef[?]]
              val inTermsOfRef =
                if traitRef.typeParamSymbols.nonEmpty then
                  val seenBefore = scala.collection.mutable.Map.empty[TypedName, Boolean]
                  val paths = classRef.typePaths.getOrElse(traitRef.name, throw new ReflectException(s"No path in class ${classRef.name} for trait ${traitRef.name}"))
                  traitRef.refType match
                    case '[e] =>
                      val typeParamTypes = TypeSymbolMapper.runPath(quotes)(paths, TypeRepr.of[e])
                      val classQuotedTypeRepr = TypeRepr.typeConstructorOf(clazz)
                      ReflectOnType(q)(classQuotedTypeRepr.appliedTo(typeParamTypes))(using seenBefore)
                else classRef
              classRef.refType match
                case '[e] =>
                  ${
                    val y = refWrite[e](cfgE, classRef.asInstanceOf[RTypeRef[e]], instE.asInstanceOf[Expr[e]], sbE2)
                    '{ y }
                  }
          quoted.staging.run(refMakerFn(t, $aE, aE, cfgE, sbE))
        }
       */

      /*
        '{
          val fn = (quotes: Quotes) ?=>
            (ref2: TraitRef[T], aE2: Expr[T], a2: T, cfgE2: Expr[JsonConfig]) =>
              import quotes.reflect.*
              val clazz = a2.getClass
              val classRef = ReflectOnType(quotes)(quotes.reflect.TypeRepr.typeConstructorOf(clazz), false)(using scala.collection.mutable.Map.empty[TypedName, Boolean]).asInstanceOf[ScalaClassRef[?]]
              val inTermsOfRef =
                if ref2.typeParamSymbols.nonEmpty then
                  val seenBefore = scala.collection.mutable.Map.empty[TypedName, Boolean]
                  val paths = classRef.typePaths.getOrElse(ref2.name, throw new ReflectException(s"No path in class ${classRef.name} for trait ${ref2.name}"))
                  ref2.refType match
                    case '[e] =>
                      val typeParamTypes = TypeSymbolMapper.runPath(quotes)(paths, TypeRepr.of[e])
                      val classQuotedTypeRepr = TypeRepr.typeConstructorOf(clazz)
                      ReflectOnType(quotes)(classQuotedTypeRepr.appliedTo(typeParamTypes))(using seenBefore)
                else classRef

              inTermsOfRef.refType match
                case '[e] =>
                  val asClassRef = inTermsOfRef.asInstanceOf[ScalaClassRef[e]].copy(renderTrait = Some(ref2.name)) // set renderTrait so ClassRef writer code renders type hint
                  refWrite[e](cfgE, asClassRef.asInstanceOf[RTypeRef[e]], aE2.asInstanceOf[Expr[e]], sbE)

          given Compiler = Compiler.make(this.getClass.getClassLoader)
          quoted.staging.run(fn(t, aE, $aE, cfgE))
        }
       */

       /*
      case t: OptionRef[?] =>
        if isMapKey then throw new JsonError("Option valuess cannot be map keys")
        t.optionParamType.refType match
          case '[e] =>
            '{
              $aE match
                case None => $sbE.append("null")
                case Some(v) =>
                  ${ refWrite[e](cfgE, t.optionParamType.asInstanceOf[RTypeRef[e]], '{ v }.asInstanceOf[Expr[e]], sbE) }
            }

      case t: MapRef[?] =>
        if isMapKey then throw new JsonError("Map values cannot be map keys")
        t.elementRef.refType match
          case '[k] =>
            t.elementRef2.refType match
              case '[v] =>
                '{
                  val sb = $sbE
                  if $aE == null then sb.append("null")
                  else
                    sb.append('{')
                    val sbLen = sb.length
                    $aE.asInstanceOf[Map[?, ?]].foreach { case (key, value) =>
                      if isOkToWrite(value, $cfgE) then
                        val b = ${ refWrite[k](cfgE, t.elementRef.asInstanceOf[RTypeRef[k]], '{ key }.asInstanceOf[Expr[k]], sbE, true) }
                        b.append(':')
                        val b2 = ${ refWrite[v](cfgE, t.elementRef2.asInstanceOf[RTypeRef[v]], '{ value }.asInstanceOf[Expr[v]], sbE) }
                        b2.append(',')
                    }
                    if sbLen == sb.length then sb.append('}')
                    else sb.setCharAt(sb.length() - 1, '}')
                }

      case t: TryRef[?] =>
        if isMapKey then throw new JsonError("Try values (Succeed/Fail) cannot be map keys")
        t.tryRef.refType match
          case '[e] =>
            '{
              $aE match
                case Success(v) =>
                  ${ refWrite[e](cfgE, t.tryRef.asInstanceOf[RTypeRef[e]], '{ v }.asInstanceOf[Expr[e]], sbE) }
                case Failure(_) if $cfgE.tryFailureHandling == TryOption.AS_NULL => $sbE.append("null")
                case Failure(v) =>
                  $sbE.append('"')
                  $sbE.append(v.getMessage)
                  $sbE.append('"')
            }

      case t: AliasRef[?] =>
        t.unwrappedType.refType match
          case '[e] =>
            refWrite[e](cfgE, t.unwrappedType.asInstanceOf[RTypeRef[e]], aE.asInstanceOf[Expr[e]], sbE)
*/