package co.blocke.scalajack
package json

import co.blocke.scala_reflection.{ReflectException, RType, RTypeRef, TypedName}
import co.blocke.scala_reflection.rtypes.TraitRType
import co.blocke.scala_reflection.reflect.rtypeRefs.*
import co.blocke.scala_reflection.reflect.*
import scala.quoted.*
import scala.quoted.staging.*

object ReflectUtil:

  /** This function takes the RType of a trait and an instance of T and does two things.
    * First it expresses the instance's class *in terms of* the trait's concrete type parameters (if any).
    * Then it generates a writer function for the now correctly-typed class.
    */
// Returns: StringBuilder
  def inTermsOf[T](traitType: TraitRType[?], a: T, aE: Expr[T], sbE: Expr[StringBuilder], cfgE: Expr[JsonConfig]) =
    given Compiler = Compiler.make(getClass.getClassLoader)

    val clazz = a.getClass

    val fn = (quotes: Quotes) ?=> {
      import quotes.reflect.*

      val classRef = ReflectOnType(quotes)(quotes.reflect.TypeRepr.typeConstructorOf(clazz), false)(using scala.collection.mutable.Map.empty[TypedName, Boolean]).asInstanceOf[ScalaClassRef[?]]

      val inTermsOfRef = traitType.toType(quotes) match
        case '[t] =>
          if traitType.typeParamSymbols.nonEmpty then
            val seenBefore = scala.collection.mutable.Map.empty[TypedName, Boolean]
            val paths = classRef.typePaths.getOrElse(traitType.name, throw new ReflectException(s"No path in class ${classRef.name} for trait ${traitType.name}"))
            val typeParamTypes = TypeSymbolMapper.runPath(quotes)(paths, TypeRepr.of[t])
            val classQuotedTypeRepr = TypeRepr.typeConstructorOf(clazz)
            ReflectOnType(quotes)(classQuotedTypeRepr.appliedTo(typeParamTypes))(using seenBefore)
          else classRef

      inTermsOfRef.refType match
        case '[e] =>
          val asClassRef = inTermsOfRef.asInstanceOf[ScalaClassRef[e]].copy(renderTrait = Some(traitType.name)).asInstanceOf[co.blocke.scala_reflection.RTypeRef[e]]
          JsonWriter.refWrite[e](cfgE, asClassRef, aE.asInstanceOf[Expr[e]], sbE)
    }
    run(fn)

  def inTermsOf2[T](traitType: TraitRType[?], clazz: Class[?])(using Quotes) =
    import quotes.reflect.*

    val classRef = ReflectOnType(quotes)(quotes.reflect.TypeRepr.typeConstructorOf(clazz), false)(using scala.collection.mutable.Map.empty[TypedName, Boolean]).asInstanceOf[ScalaClassRef[?]]

    (traitType.toType(quotes) match
      case '[t] =>
        if traitType.typeParamSymbols.nonEmpty then
          val seenBefore = scala.collection.mutable.Map.empty[TypedName, Boolean]
          val paths = classRef.typePaths.getOrElse(traitType.name, throw new ReflectException(s"No path in class ${classRef.name} for trait ${traitType.name}"))
          val typeParamTypes = TypeSymbolMapper.runPath(quotes)(paths, TypeRepr.of[t])
          val classQuotedTypeRepr = TypeRepr.typeConstructorOf(clazz)
          ReflectOnType(quotes)(classQuotedTypeRepr.appliedTo(typeParamTypes))(using seenBefore)
        else classRef
    ).asInstanceOf[ScalaClassRef[?]]
