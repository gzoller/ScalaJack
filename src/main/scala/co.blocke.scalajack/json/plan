// 1. Entry point (simplified)

def generateCodecFor[T](using q: Quotes, t: Type[T]): Expr[Codec[T]] =
  val ctx = CodecBuildContext(...) // has readerFnMap
  val key = methodKeyFor[T]

  // Build reader function
  makeReadFn[T](ctx, key)

  // Assemble final Codec
  '{
    Codec[T](
      reader = ${ ctx.readerFnMap(key).asExprOf[(JsonSource) => T] },
      writer = ??? // (you can fill in later)
    )
  }


  // 2. makeReadFn -- core of reader generation

  def makeReadFn[T](ctx: CodecBuildContext, key: MethodKey)(using Quotes, Type[T]): Unit =
    if ctx.readerFnMap.contains(key) then
      return // Already reserved/handled

    // === 1. Reserve a placeholder ===
    ctx.readerFnMap.put(key, Placeholder())

    // === 2. Reflect on type T ===
    val fields: List[FieldInfo] = reflectFieldsOf[T] // case class fields, etc.

    // === 3. For each field, ensure reader exists ===
    val fieldReaders: List[Expr[(JsonSource) => Any]] = fields.map { field =>
      val fieldKey = methodKeyForField(field)
      makeReadFn(field.typeRepr)(ctx, fieldKey) // recursive generation
      ctx.readerFnMap(fieldKey) match
        case RealReader(expr) => expr
        case Placeholder()    =>
          // If still placeholder, emit safe stub call
          makeReaderStub(fieldKey)
    }

    // === 4. Generate final reader body ===
    val readerExpr: Expr[(JsonSource) => T] =
      generateReaderBody[T](fields, fieldReaders)

    // === 5. Patch the map ===
    ctx.readerFnMap.update(key, RealReader(readerExpr))


    // 3. Support code

    sealed trait ReaderEntry
    case class Placeholder() extends ReaderEntry
    case class RealReader(expr: Expr[(JsonSource) => Any]) extends ReaderEntry

    def makeReaderStub(key: MethodKey)(using Quotes): Expr[(JsonSource) => Any] =
      '{ (in: JsonSource) => readerMap(${Expr(key)})(in) }

    def generateReaderBody[T](fields: List[FieldInfo], fieldReaders: List[Expr[(JsonSource) => Any]])(using Quotes, Type[T]): Expr[(JsonSource) => T] =
      '{
        (in: JsonSource) =>
          val fieldValues = List(..${ fieldReaders.map(fr => '{ $fr(in) }) })
          buildCaseClass[T](fieldValues) // Some helper to assemble T
      }