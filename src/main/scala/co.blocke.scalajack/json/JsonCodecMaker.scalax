package co.blocke.scalajack
package json

import scala.quoted.*
import scala.collection.mutable
import co.blocke.scala_reflection.{RType, RTypeRef, TypedName}
import co.blocke.scala_reflection.util.TypedName
import co.blocke.scala_reflection.reflect.rtypeRefs.*
import co.blocke.scala_reflection.reflect.ReflectOnType
import writing.JsonOutput
import reading.JsonSource

object JsonCodecMaker:

  case class StubRTypeRef(typedName: TypedName) extends RTypeRef[Nothing]:
    def asJson(sb: StringBuilder)(using quotes: scala.quoted.Quotes): Unit = ()
    val expr: scala.quoted.Expr[co.blocke.scala_reflection.RType[Nothing]] = null.asInstanceOf[Expr[RType[Nothing]]]
    val name: String = typedName.toString
    val refType: scala.quoted.Type[Nothing] = null.asInstanceOf[Type[Nothing]]
    val unitVal: scala.quoted.Expr[Nothing] = null.asInstanceOf[Expr[Nothing]]

  def generateCodecFor[T](ctx: CodecBuildContext, ref: RTypeRef[T], cfg: SJConfig)(using tt: Type[T]) =
    given Quotes = ctx.quotes
    import ctx.quotes.reflect.*

    println(s"[ðŸ§ª quotes hash in generateCodecFor] ${ctx.quotes.hashCode()}")
    def resolveRType(tpe: TypeRepr, isRoot: Boolean = false): RTypeRef[?] =
      val typedName = TypedName(ctx.quotes)(tpe)
      ctx.canonicalRefCache.getOrElseUpdate(
        typedName, {
          val stub = StubRTypeRef(typedName)
          ctx.canonicalRefCache += typedName -> stub
          val fullRef = ReflectOnType(ctx.quotes)(tpe, isRoot)(using ctx.seenBefore)
          ctx.canonicalRefCache.update(typedName, fullRef)
          fullRef
        }
      )

    val qHash = Expr(ctx.quotes.hashCode())
    val codecDef = '{
      new JsonCodec[T] {
        def encodeValue(in: T, out: JsonOutput): Unit =
          ${
            val inExpr = 'in
            val outExpr = 'out
            genWriterFor[T](ctx, cfg, inExpr, ref, outExpr)
          }
        def decodeValue(in: JsonSource): T = null.asInstanceOf[T]
      }
    }.asTerm

    val rootRef = resolveRType(TypeRepr.of[T], isRoot = true).asInstanceOf[RTypeRef[T]]

    println("ðŸ§  canonicalRefCache:")
    ctx.canonicalRefCache.foreach { (k, v) =>
      println(s"  $k => ${v.getClass.getSimpleName}")
    }

    val codec = Block(
      ctx.writeMethodDefs.toList.asInstanceOf[List[ctx.quotes.reflect.Statement]],
      codecDef
    ).asExprOf[JsonCodec[T]]
    codec

  def genWriterFor[W](ctx: CodecBuildContext, cfg: SJConfig, in: Expr[W], ref: RTypeRef[W], out: Expr[JsonOutput], isMapKey: Boolean = false)(using Type[W]): Expr[Unit] =
    given Quotes = ctx.quotes
    import ctx.quotes.reflect.*

    // ------- This machinery designed to support SelfRefs -- avoid endless recursion
    val typedName = ref.typedName
    if !ctx.generatedWriters.contains(typedName) &&
      !ctx.currentlyGenerating.contains(typedName) &&
      !ref.isInstanceOf[SelfRefRef[?]]
    then

      ref.refType match
        case '[w] =>
          val methodName = "write_" + typedName.toString.replace('.', '_')
          val writerSym = Symbol.newMethod(
            Symbol.spliceOwner,
            methodName,
            MethodType(List("in", "out"))(
              _ => List(TypeRepr.of[w], TypeRepr.of[JsonOutput]),
              _ => TypeRepr.of[Unit]
            )
          )

          ctx.currentlyGenerating += typedName

          val paramIn = Ref(writerSym.paramSymss.head(0)).asExprOf[w]
          val paramOut = Ref(writerSym.paramSymss.head(1)).asExprOf[JsonOutput]
          val body = genWriterFor[w](ctx, cfg, paramIn, ref.asInstanceOf[RTypeRef[w]], paramOut)(using Type.of[w])
          val defdef = DefDef(writerSym, { case List(List(_, _)) => Some(body.asTerm) })

          ctx.generatedWriters += typedName -> writerSym
          ctx.writeMethodDefs += defdef
          ctx.currentlyGenerating -= typedName
    // -------

    ref match
      case p: StringRef =>
        if cfg._suppressEscapedStrings then '{ $out.value(${ in.asExprOf[String] }) }
        else '{ $out.valueEscaped(${ in.asExprOf[String] }) }
      case p: IntRef =>
        if isMapKey then '{ $out.valueStringified(${ in.asExprOf[Int] }) }
        else '{ $out.value(${ in.asExprOf[Int] }) }
//      case p: LongRef =>
//        if isMapKey then '{ $out.valueStringified($in) }
//        else '{ $out.value($in) }
//      case p: BooleanRef =>
//        if isMapKey then '{ $out.valueStringified($in) }
//        else '{ $out.value($in) }

      case c: ScalaClassRef[?] =>
        ref.refType match
          case '[w] =>
            val typedIn = in.asExprOf[w]
            val begin = '{ $out.startObject() }
            val end = '{ $out.endObject() }

            val fieldWrites = c.fields.map { oneField =>
              oneField.fieldRef.refType match
                case '[f] =>
                  val fieldExpr = Select.unique(typedIn.asTerm, oneField.name).asExprOf[f]
                  val fieldNameExpr = Expr(oneField.name)
                  val writeField = genWriterFor[f](
                    ctx,
                    cfg,
                    fieldExpr,
                    oneField.fieldRef.asInstanceOf[RTypeRef[f]],
                    out
                  )(using Type.of[f])
                  '{
                    $out.label($fieldNameExpr)
                    $writeField
                  }
            }
            Expr.block(begin +: fieldWrites :+ end, '{ () })

      case t: Sealable if t.isSealed =>
        '{ println("writing trait") }

      case l: SeqRef[?] =>
        val listTerm = in.asTerm
        l.elementRef.refType match
          case '[e] =>
            val tin = if l.isMutable then in.asExprOf[scala.collection.mutable.Seq[e]] else in.asExprOf[Seq[e]]
            '{
              if $tin == null then $out.burpNull()
              else
                $out.startArray()
                $tin.foreach { i =>
                  ${ genWriterFor[e](ctx, cfg, '{ i }, l.elementRef.asInstanceOf[RTypeRef[e]], out)(using Type.of[e]) }
                }
                $out.endArray()
            }

      case s: SelfRefRef[?] =>
        ctx.generatedWriters.get(s.typedName) match
          case Some(methodSym) =>
            Apply(Ref(methodSym), List(in.asTerm, out.asTerm)).asExprOf[Unit]
          case None =>
            report.error(s"No writer method found for SelfRef type: ${s.typedName}")
            '{ () }

      case _ =>
        report.error(s"Unsupported RTypeRef: $ref")
        '{ () }
