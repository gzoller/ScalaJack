package co.blocke.scalajack

import co.blocke.scala_reflection._
import co.blocke.scala_reflection.info._
import org.apache.commons.codec.binary.Base64

import scala.collection.mutable
import scala.jdk.CollectionConverters._
import json._
import yaml._
import delimited._
import model.JackFlavor
import co.blocke.scalajack.Converters._


trait Human
case class Person(name: String, age: Int) extends Human
case class Typey[T](thing: T) {
  type foom = T
}

object Main {

  def main(args: Array[String]): Unit = 

    val sj: JsonFlavor        = ScalaJack()
    val sjY: JackFlavor[YAML] = ScalaJack(YamlFlavor())

    val simple: Person        = Person("Fred", 34)
    val complex: Typey[Human] = Typey[Human](Person("Fred", 34))

    val js = simple.toJson[Person]
    println(js)
    println(js.jsonToYaml)
    println(js.jsonToJson4s)
    // println(js.toDelimited)  // This should work!
    println("BACK: "+js.fromJson[Person])
    println("-------")
    val js2 = complex.toJson[Typey[Human]]
    println(js2)
    println(js2.jsonToYaml)
    println(js2.jsonToJson4s)
    println("BACK: "+js2.fromJson[Typey[Human]])


  def constructors(clazz: Class[_]): String = 
    s"=== Constructors: ${clazz.getName} ===\n   " + clazz.getConstructors.toList.mkString("\n   ")
  def methods(clazz: Class[_]): String = 
    s"=== Methods: ${clazz.getName} ===\n   " + clazz.getMethods.toList.mkString("\n   ")
  def fields(clazz: Class[_]): String = 
    s"=== Fields: ${clazz.getName} ===\n   " + clazz.getFields.toList.mkString("\n   ")
  def stack(clazz: Class[_]): String = 
    s"=== Superclass: ${clazz.getName} ===\n   " + clazz.getSuperclass() + "\n" +
    s"=== Interfaces: ${clazz.getName} ===\n   " + clazz.getInterfaces.toList.mkString("\n   ")
  
}