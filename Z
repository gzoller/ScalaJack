[info] welcome to sbt 1.9.6 (Homebrew Java 19.0.2)
[info] loading global plugins from /Users/gzoller/.sbt/1.0/plugins
[info] loading settings for project scalajack-build-build-build from metals.sbt ...
[info] loading project definition from /Users/gzoller/me/git/ScalaJack/project/project/project
[info] loading settings for project scalajack-build-build from metals.sbt ...
[info] loading project definition from /Users/gzoller/me/git/ScalaJack/project/project
[success] Generated .bloop/scalajack-build-build.json
[success] Total time: 1 s, completed Apr 6, 2024, 11:44:09 PM
[info] loading settings for project scalajack-build from metals.sbt,plugins.sbt ...
[info] loading project definition from /Users/gzoller/me/git/ScalaJack/project
[success] Generated .bloop/scalajack-build.json
[success] Total time: 0 s, completed Apr 6, 2024, 11:44:09 PM
[info] loading settings for project root from build.sbt ...
>>> Unknown gitflow branch: newworld
>>> Unknown gitflow branch: newworld
Packaged artifact name: scalajack_unknown-tests.jar
Packaged artifact name: scalajack_unknown.jar
>>> Unknown gitflow branch: newworld
Packaged artifact name: scalajack_unknown.jar
>>> Unknown gitflow branch: newworld
Packaged artifact name: scalajack_unknown-sources.jar
>>> Unknown gitflow branch: newworld
Packaged artifact name: scalajack_unknown-tests-sources.jar
>>> Unknown gitflow branch: newworld
Packaged artifact name: scalajack_unknown.jar
>>> Unknown gitflow branch: newworld
>>> Unknown gitflow branch: newworld
Packaged artifact name: scalajack_unknown.pom
Packaged artifact name: scalajack_unknown.pom
>>> Unknown gitflow branch: newworld
Packaged artifact name: scalajack_unknown-javadoc.jar
>>> Unknown gitflow branch: newworld
Packaged artifact name: scalajack_unknown-tests-javadoc.jar
>>> Unknown gitflow branch: newworld
Packaged artifact name: scalajack_unknown-cached-compile.jar
>>> Unknown gitflow branch: newworld
Packaged artifact name: scalajack_unknown-cached-test.jar
[info] set current project to scalajack (in build file:/Users/gzoller/me/git/ScalaJack/)
[info] scalafmt: Formatting 17 Scala sources (/Users/gzoller/me/git/ScalaJack)...
[info] scalafmt: Formatting 17 Scala sources (/Users/gzoller/me/git/ScalaJack)...
[info] compiling 17 Scala sources and 20 Java sources to /Users/gzoller/me/git/ScalaJack/target/scala-3.3.1/classes ...
Codec: {
  val __co_blocke_scalajack_json_run_JJ_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: java.util.ArrayList[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    scala.Predef.refArrayOps[java.lang.Object](in.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => out.value(elem.asInstanceOf[scala.Int])))
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.run.JJ, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.run.JJ = {
    var _a: java.util.ArrayList[scala.Int] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_run_JJ_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.run.JJ] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else new java.util.ArrayList[scala.Int][scala.Int]({
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Int] = `in₃`.expectArray[scala.Int]((() => `in₃`.expectInt()))
                scala.jdk.CollectionConverters.SeqHasAsJava[scala.Int](parsedArray.toList).asJava.asInstanceOf[java.util.Collection[scala.Int]]
              })
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_run_JJ_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.run.JJ(_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.run.JJ] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.run.JJ, `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.run.JJ = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.run.JJ])
}
[info] done compiling
[info] compiling 17 Scala sources and 2 Java sources to /Users/gzoller/me/git/ScalaJack/target/scala-3.3.1/test-classes ...
Codec: {
  val __co_blocke_scalajack_json_collections_JSetHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: java.util.Set[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    scala.Predef.refArrayOps[java.lang.Object](in.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => out.value(elem.asInstanceOf[scala.Int])))
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.JSetHolder[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[scala.Int] = {
    var _a: java.util.Set[scala.Int] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.JSetHolder[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Int] = `in₃`.expectArray[scala.Int]((() => `in₃`.expectInt()))
                if (parsedArray.==(null)) null else new java.util.TreeSet[scala.Int](scala.jdk.CollectionConverters.SeqHasAsJava[scala.Int](parsedArray.toList).asJava)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.JSetHolder[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[scala.Int]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.JSetHolder[scala.Int], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[scala.Int] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_JSetHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: java.util.Set[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    scala.Predef.refArrayOps[java.lang.Object](in.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => out.value(elem.asInstanceOf[scala.Int])))
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.JSetHolder[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[scala.Int] = {
    var _a: java.util.Set[scala.Int] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.JSetHolder[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Int] = `in₃`.expectArray[scala.Int]((() => `in₃`.expectInt()))
                if (parsedArray.==(null)) null else new java.util.TreeSet[scala.Int](scala.jdk.CollectionConverters.SeqHasAsJava[scala.Int](parsedArray.toList).asJava)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.JSetHolder[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[scala.Int]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.JSetHolder[scala.Int], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[scala.Int] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_JSetHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: java.util.Set[scala.Predef.String], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    scala.Predef.refArrayOps[java.lang.Object](in.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => out.valueEscaped(elem.asInstanceOf[java.lang.String])))
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.JSetHolder[scala.Predef.String], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[scala.Predef.String] = {
    var _a: java.util.Set[scala.Predef.String] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.JSetHolder[scala.Predef.String]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val parsedArray: scala.collection.mutable.ListBuffer[java.lang.String] = `in₃`.expectArray[java.lang.String]((() => `in₃`.expectString()))
                if (parsedArray.==(null)) null else new java.util.TreeSet[java.lang.String](scala.jdk.CollectionConverters.SeqHasAsJava[java.lang.String](parsedArray.toList).asJava)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.JSetHolder[scala.Predef.String][java.lang.String](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[scala.Predef.String]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.JSetHolder[scala.Predef.String], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[scala.Predef.String] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[scala.Predef.String]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_JSetHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: java.util.Set[scala.Boolean], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    scala.Predef.refArrayOps[java.lang.Object](in.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => out.value(elem.asInstanceOf[scala.Boolean])))
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.JSetHolder[scala.Boolean], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[scala.Boolean] = {
    var _a: java.util.Set[scala.Boolean] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.JSetHolder[scala.Boolean]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Boolean] = `in₃`.expectArray[scala.Boolean]((() => `in₃`.expectBoolean()))
                if (parsedArray.==(null)) null else new java.util.TreeSet[scala.Boolean](scala.jdk.CollectionConverters.SeqHasAsJava[scala.Boolean](parsedArray.toList).asJava)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.JSetHolder[scala.Boolean][scala.Boolean](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[scala.Boolean]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.JSetHolder[scala.Boolean], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[scala.Boolean] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[scala.Boolean]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_JSetHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w2(in: java.util.Set[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    scala.Predef.refArrayOps[java.lang.Object](in.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => out.value(elem.asInstanceOf[scala.Int])))
    out.endArray()
  }
  def w1(`in₂`: java.util.Set[java.util.Set[scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startArray()
    scala.Predef.refArrayOps[java.lang.Object](`in₂`.toArray()).foreach[scala.Unit](((`elem₂`: java.lang.Object) => w2(`elem₂`.asInstanceOf[java.util.Set[scala.Int]], `out₂`)))
    `out₂`.endArray()
  }
  def w0(`in₃`: co.blocke.scalajack.json.collections.JSetHolder[java.util.Set[scala.Int]], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `out₃`.label("a")
    w1(`in₃`.a, `out₃`)
    `out₃`.endObject()
  }
  def r0(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[java.util.Set[scala.Int]] = {
    var _a: java.util.Set[java.util.Set[scala.Int]] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.JSetHolder[java.util.Set[scala.Int]]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val parsedArray: scala.collection.mutable.ListBuffer[java.util.Set[scala.Int]] = `in₄`.expectArray[java.util.Set[scala.Int]]((() => {
                  val `parsedArray₂`: scala.collection.mutable.ListBuffer[scala.Int] = `in₄`.expectArray[scala.Int]((() => `in₄`.expectInt()))
                  if (`parsedArray₂`.==(null)) null else new java.util.TreeSet[scala.Int](scala.jdk.CollectionConverters.SeqHasAsJava[scala.Int](`parsedArray₂`.toList).asJava)
                }))
                if (parsedArray.==(null)) null else new java.util.TreeSet[java.util.Set[scala.Int]](scala.jdk.CollectionConverters.SeqHasAsJava[java.util.Set[scala.Int]](parsedArray.toList).asJava)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.JSetHolder[java.util.Set[scala.Int]][java.util.Set[scala.Int]](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₄`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[java.util.Set[scala.Int]]] {
    def encodeValue(`in₅`: co.blocke.scalajack.json.collections.JSetHolder[java.util.Set[scala.Int]], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₅`, `out₄`)
    def decodeValue(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[java.util.Set[scala.Int]] = r0(`in₆`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[java.util.Set[scala.Int]]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_JSetHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: java.util.Set[scala.util.Either[scala.Int, scala.Boolean]], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    scala.Predef.refArrayOps[java.lang.Object](in.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => if (elem.asInstanceOf[scala.util.Either[scala.Int, scala.Boolean]].==(null)) out.burpNull() else elem.asInstanceOf[scala.util.Either[scala.Int, scala.Boolean]] match {
      case scala.Left(v) =>
        out.value(v.asInstanceOf[scala.Int])
      case scala.Right(v) =>
        out.value(`v₂`.asInstanceOf[scala.Boolean])
    }))
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.JSetHolder[scala.util.Either[scala.Int, scala.Boolean]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[scala.util.Either[scala.Int, scala.Boolean]] = {
    var _a: java.util.Set[scala.util.Either[scala.Int, scala.Boolean]] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.JSetHolder[scala.util.Either[scala.Int, scala.Boolean]]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.util.Either[scala.Int, scala.Boolean]] = `in₃`.expectArray[scala.util.Either[scala.Int, scala.Boolean]]((() => {
                  val mark: scala.Int = `in₃`.pos
                  if (`in₃`.expectNull()) null else scala.util.Try.apply[scala.Boolean](`in₃`.expectBoolean()) match {
                    case scala.util.Success(rval) =>
                      scala.Right.apply[scala.Nothing, scala.Boolean](rval)
                    case scala.util.Failure(f) =>
                      `in₃`.revertToPos(mark)
                      scala.util.Try.apply[scala.Int](`in₃`.expectInt()) match {
                        case scala.util.Success(lval) =>
                          scala.Left.apply[scala.Int, scala.Nothing](lval)
                        case scala.util.Failure(_) =>
                          `in₃`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₃`)
                      }
                  }
                }))
                if (parsedArray.==(null)) null else new java.util.TreeSet[scala.util.Either[scala.Int, scala.Boolean]](scala.jdk.CollectionConverters.SeqHasAsJava[scala.util.Either[scala.Int, scala.Boolean]](parsedArray.toList).asJava)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.JSetHolder[scala.util.Either[scala.Int, scala.Boolean]][scala.util.Either[scala.Int, scala.Boolean]](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[scala.util.Either[scala.Int, scala.Boolean]]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.JSetHolder[scala.util.Either[scala.Int, scala.Boolean]], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[scala.util.Either[scala.Int, scala.Boolean]] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[scala.util.Either[scala.Int, scala.Boolean]]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_JSetHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: java.util.Set[scala.Int | scala.Boolean], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    scala.Predef.refArrayOps[java.lang.Object](in.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => {
      out.mark()
      scala.util.Try.apply[scala.Unit](out.value(elem.asInstanceOf[scala.Int | scala.Boolean].asInstanceOf[scala.Boolean])) match {
        case scala.util.Success(_) =>
          ()
        case scala.util.Failure(_) =>
          out.revert()
          out.value(elem.asInstanceOf[scala.Int | scala.Boolean].asInstanceOf[scala.Int])
      }
    }))
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.JSetHolder[scala.Int | scala.Boolean], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[scala.Int | scala.Boolean] = {
    var _a: java.util.Set[scala.Int | scala.Boolean] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.JSetHolder[scala.Int | scala.Boolean]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Int | scala.Boolean] = `in₃`.expectArray[scala.Int | scala.Boolean]((() => {
                  val mark: scala.Int = `in₃`.pos
                  scala.util.Try.apply[scala.Int](`in₃`.expectInt()) match {
                    case scala.util.Success(lval) =>
                      (lval: scala.Int)
                    case scala.util.Failure(f) =>
                      `in₃`.revertToPos(mark)
                      scala.util.Try.apply[scala.Boolean](`in₃`.expectBoolean()) match {
                        case scala.util.Success(rval) =>
                          (rval: scala.Boolean)
                        case scala.util.Failure(_) =>
                          `in₃`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₃`)
                      }
                  }
                }))
                if (parsedArray.==(null)) null else new java.util.TreeSet[scala.Int | scala.Boolean](scala.jdk.CollectionConverters.SeqHasAsJava[scala.Int | scala.Boolean](parsedArray.toList).asJava)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.JSetHolder[scala.Int | scala.Boolean][scala.Int | scala.Boolean](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[scala.Int | scala.Boolean]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.JSetHolder[scala.Int | scala.Boolean], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[scala.Int | scala.Boolean] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[scala.Int | scala.Boolean]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_JSetHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: java.util.Set[scala.Option[scala.Int]], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    scala.Predef.refArrayOps[java.lang.Object](in.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => elem.asInstanceOf[scala.Option[scala.Int]] match {
      case null =>
        out.burpNull()
      case scala.None =>
        ()
      case scala.Some(v) =>
        val vv: scala.Int = v.asInstanceOf[scala.Int]
        out.value(vv)
    }))
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.JSetHolder[scala.Option[scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[scala.Option[scala.Int]] = {
    var _a: java.util.Set[scala.Option[scala.Int]] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.JSetHolder[scala.Option[scala.Int]]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Option[scala.Int]] = `in₃`.expectArray[scala.Option[scala.Int]]((() => if (`in₃`.expectNull()) null else scala.Some.apply[scala.Int](`in₃`.expectInt())))
                if (parsedArray.==(null)) null else new java.util.TreeSet[scala.Option[scala.Int]](scala.jdk.CollectionConverters.SeqHasAsJava[scala.Option[scala.Int]](parsedArray.toList).asJava)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.JSetHolder[scala.Option[scala.Int]][scala.Option[scala.Int]](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[scala.Option[scala.Int]]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.JSetHolder[scala.Option[scala.Int]], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[scala.Option[scala.Int]] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[scala.Option[scala.Int]]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_JSetHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w2(in: scala.collection.immutable.Map[scala.Predef.String, scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, scala.Int]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.valueEscaped(key)
          out.colon()
          out.value(value)
        }
    }))
    out.endObject()
  }
  def w1(`in₂`: java.util.Set[scala.collection.immutable.Map[scala.Predef.String, scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startArray()
    scala.Predef.refArrayOps[java.lang.Object](`in₂`.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => w2(elem.asInstanceOf[scala.collection.immutable.Map[scala.Predef.String, scala.Int]], `out₂`)))
    `out₂`.endArray()
  }
  def w0(`in₃`: co.blocke.scalajack.json.collections.JSetHolder[scala.collection.immutable.Map[scala.Predef.String, scala.Int]], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `out₃`.label("a")
    w1(`in₃`.a, `out₃`)
    `out₃`.endObject()
  }
  def r0(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[scala.collection.immutable.Map[scala.Predef.String, scala.Int]] = {
    var _a: java.util.Set[scala.collection.immutable.Map[scala.Predef.String, scala.Int]] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.JSetHolder[scala.collection.immutable.Map[scala.Predef.String, scala.Int]]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.collection.immutable.Map[scala.Predef.String, scala.Int]] = `in₄`.expectArray[scala.collection.immutable.Map[scala.Predef.String, scala.Int]]((() => if (`in₄`.expectNull()) null else {
                  `in₄`.expectToken('{')
                  `in₄`.parseMap[java.lang.String, scala.Int]((() => `in₄`.expectString()), (() => `in₄`.expectInt()), scala.Predef.Map.empty[java.lang.String, scala.Int], true)
                }))
                if (parsedArray.==(null)) null else new java.util.TreeSet[scala.collection.immutable.Map[scala.Predef.String, scala.Int]](scala.jdk.CollectionConverters.SeqHasAsJava[scala.collection.immutable.Map[scala.Predef.String, scala.Int]](parsedArray.toList).asJava)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.JSetHolder[scala.collection.immutable.Map[scala.Predef.String, scala.Int]][scala.collection.immutable.Map[scala.Predef.String, scala.Int]](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₄`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[scala.collection.immutable.Map[scala.Predef.String, scala.Int]]] {
    def encodeValue(`in₅`: co.blocke.scalajack.json.collections.JSetHolder[scala.collection.immutable.Map[scala.Predef.String, scala.Int]], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₅`, `out₄`)
    def decodeValue(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[scala.collection.immutable.Map[scala.Predef.String, scala.Int]] = r0(`in₆`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[scala.collection.immutable.Map[scala.Predef.String, scala.Int]]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_Person_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("name", "age")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  val __co_blocke_scalajack_json_collections_JSetHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w2(in: co.blocke.scalajack.json.collections.Person, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("name")
    out.valueEscaped(in.name)
    out.label("age")
    out.value(in.age)
    out.endObject()
  }
  def w1(`in₂`: java.util.Set[co.blocke.scalajack.json.collections.Person], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startArray()
    scala.Predef.refArrayOps[java.lang.Object](`in₂`.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => w2(elem.asInstanceOf[co.blocke.scalajack.json.collections.Person], `out₂`)))
    `out₂`.endArray()
  }
  def w0(`in₃`: co.blocke.scalajack.json.collections.JSetHolder[co.blocke.scalajack.json.collections.Person], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `out₃`.label("a")
    w1(`in₃`.a, `out₃`)
    `out₃`.endObject()
  }
  def r1(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.Person = {
    var _name: java.lang.String = ""
    var _age: scala.Int = 0
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_collections_Person_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.Person] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _name = `in₄`.expectString()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("name"), `in₄`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _age = `in₄`.expectInt()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("age"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_collections_Person_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.collections.Person(_name, _age) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("name", "age")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₄`)
    }
  }
  def r0(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[co.blocke.scalajack.json.collections.Person] = {
    var _a: java.util.Set[co.blocke.scalajack.json.collections.Person] = null
    var `required₂`: scala.Int = 1
    var `maybeFieldNum₂`: scala.Option[scala.Int] = `in₅`.expectFirstObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
    if (`maybeFieldNum₂`.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.JSetHolder[co.blocke.scalajack.json.collections.Person]] else {
      while (`maybeFieldNum₂`.isDefined) {
        `maybeFieldNum₂`.get match {
          case 0 =>
            if (`required₂`.&(1).!=(0)) {
              `required₂` = `required₂`.^(1)
              _a = {
                val parsedArray: scala.collection.mutable.ListBuffer[co.blocke.scalajack.json.collections.Person] = `in₅`.expectArray[co.blocke.scalajack.json.collections.Person]((() => r1(`in₅`)))
                if (parsedArray.==(null)) null else new java.util.TreeSet[co.blocke.scalajack.json.collections.Person](scala.jdk.CollectionConverters.SeqHasAsJava[co.blocke.scalajack.json.collections.Person](parsedArray.toList).asJava)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₅`)
          case _ =>
            `in₅`.skipValue()
        }
        `maybeFieldNum₂` = `in₅`.expectObjectField(__co_blocke_scalajack_json_collections_JSetHolder_fields)
      }
      if (`required₂`.&(1).==(0)) new co.blocke.scalajack.json.collections.JSetHolder[co.blocke.scalajack.json.collections.Person][co.blocke.scalajack.json.collections.Person](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(`required₂`.&(1)))), `in₅`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[co.blocke.scalajack.json.collections.Person]] {
    def encodeValue(`in₆`: co.blocke.scalajack.json.collections.JSetHolder[co.blocke.scalajack.json.collections.Person], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₆`, `out₄`)
    def decodeValue(`in₇`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.JSetHolder[co.blocke.scalajack.json.collections.Person] = r0(`in₇`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.JSetHolder[co.blocke.scalajack.json.collections.Person]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_ArrayListHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: java.util.ArrayList[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    scala.Predef.refArrayOps[java.lang.Object](in.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => out.value(elem.asInstanceOf[scala.Int])))
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int] = {
    var _a: java.util.ArrayList[scala.Int] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else new java.util.ArrayList[scala.Int][scala.Int]({
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Int] = `in₃`.expectArray[scala.Int]((() => `in₃`.expectInt()))
                scala.jdk.CollectionConverters.SeqHasAsJava[scala.Int](parsedArray.toList).asJava.asInstanceOf[java.util.Collection[scala.Int]]
              })
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_ArrayListHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: java.util.ArrayList[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    scala.Predef.refArrayOps[java.lang.Object](in.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => out.value(elem.asInstanceOf[scala.Int])))
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int] = {
    var _a: java.util.ArrayList[scala.Int] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else new java.util.ArrayList[scala.Int][scala.Int]({
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Int] = `in₃`.expectArray[scala.Int]((() => `in₃`.expectInt()))
                scala.jdk.CollectionConverters.SeqHasAsJava[scala.Int](parsedArray.toList).asJava.asInstanceOf[java.util.Collection[scala.Int]]
              })
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_ArrayListHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: java.util.ArrayList[scala.Predef.String], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    scala.Predef.refArrayOps[java.lang.Object](in.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => out.valueEscaped(elem.asInstanceOf[java.lang.String])))
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.ArrayListHolder[scala.Predef.String], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[scala.Predef.String] = {
    var _a: java.util.ArrayList[scala.Predef.String] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.ArrayListHolder[scala.Predef.String]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else new java.util.ArrayList[scala.Predef.String][java.lang.String]({
                val parsedArray: scala.collection.mutable.ListBuffer[java.lang.String] = `in₃`.expectArray[java.lang.String]((() => `in₃`.expectString()))
                scala.jdk.CollectionConverters.SeqHasAsJava[java.lang.String](parsedArray.toList).asJava.asInstanceOf[java.util.Collection[java.lang.String]]
              })
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.ArrayListHolder[scala.Predef.String][java.lang.String](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[scala.Predef.String]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.ArrayListHolder[scala.Predef.String], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[scala.Predef.String] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[scala.Predef.String]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_ArrayListHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: java.util.ArrayList[scala.Boolean], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    scala.Predef.refArrayOps[java.lang.Object](in.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => out.value(elem.asInstanceOf[scala.Boolean])))
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.ArrayListHolder[scala.Boolean], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[scala.Boolean] = {
    var _a: java.util.ArrayList[scala.Boolean] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.ArrayListHolder[scala.Boolean]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else new java.util.ArrayList[scala.Boolean][scala.Boolean]({
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Boolean] = `in₃`.expectArray[scala.Boolean]((() => `in₃`.expectBoolean()))
                scala.jdk.CollectionConverters.SeqHasAsJava[scala.Boolean](parsedArray.toList).asJava.asInstanceOf[java.util.Collection[scala.Boolean]]
              })
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.ArrayListHolder[scala.Boolean][scala.Boolean](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[scala.Boolean]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.ArrayListHolder[scala.Boolean], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[scala.Boolean] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[scala.Boolean]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_ArrayListHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w2(in: java.util.ArrayList[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    scala.Predef.refArrayOps[java.lang.Object](in.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => out.value(elem.asInstanceOf[scala.Int])))
    out.endArray()
  }
  def w1(`in₂`: java.util.ArrayList[java.util.ArrayList[scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startArray()
    scala.Predef.refArrayOps[java.lang.Object](`in₂`.toArray()).foreach[scala.Unit](((`elem₂`: java.lang.Object) => w2(`elem₂`.asInstanceOf[java.util.ArrayList[scala.Int]], `out₂`)))
    `out₂`.endArray()
  }
  def w0(`in₃`: co.blocke.scalajack.json.collections.ArrayListHolder[java.util.ArrayList[scala.Int]], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `out₃`.label("a")
    w1(`in₃`.a, `out₃`)
    `out₃`.endObject()
  }
  def r0(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[java.util.ArrayList[scala.Int]] = {
    var _a: java.util.ArrayList[java.util.ArrayList[scala.Int]] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.ArrayListHolder[java.util.ArrayList[scala.Int]]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₄`.expectNull()) null else new java.util.ArrayList[java.util.ArrayList[scala.Int]][java.util.ArrayList[scala.Int]]({
                val parsedArray: scala.collection.mutable.ListBuffer[java.util.ArrayList[scala.Int]] = `in₄`.expectArray[java.util.ArrayList[scala.Int]]((() => if (`in₄`.expectNull()) null else new java.util.ArrayList[scala.Int][scala.Int]({
                  val `parsedArray₂`: scala.collection.mutable.ListBuffer[scala.Int] = `in₄`.expectArray[scala.Int]((() => `in₄`.expectInt()))
                  scala.jdk.CollectionConverters.SeqHasAsJava[scala.Int](`parsedArray₂`.toList).asJava.asInstanceOf[java.util.Collection[scala.Int]]
                })))
                scala.jdk.CollectionConverters.SeqHasAsJava[java.util.ArrayList[scala.Int]](parsedArray.toList).asJava.asInstanceOf[java.util.Collection[java.util.ArrayList[scala.Int]]]
              })
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.ArrayListHolder[java.util.ArrayList[scala.Int]][java.util.ArrayList[scala.Int]](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₄`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[java.util.ArrayList[scala.Int]]] {
    def encodeValue(`in₅`: co.blocke.scalajack.json.collections.ArrayListHolder[java.util.ArrayList[scala.Int]], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₅`, `out₄`)
    def decodeValue(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[java.util.ArrayList[scala.Int]] = r0(`in₆`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[java.util.ArrayList[scala.Int]]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_ArrayListHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: java.util.ArrayList[scala.util.Either[scala.Int, scala.Boolean]], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    scala.Predef.refArrayOps[java.lang.Object](in.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => if (elem.asInstanceOf[scala.util.Either[scala.Int, scala.Boolean]].==(null)) out.burpNull() else elem.asInstanceOf[scala.util.Either[scala.Int, scala.Boolean]] match {
      case scala.Left(v) =>
        out.value(v.asInstanceOf[scala.Int])
      case scala.Right(v) =>
        out.value(`v₂`.asInstanceOf[scala.Boolean])
    }))
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.ArrayListHolder[scala.util.Either[scala.Int, scala.Boolean]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[scala.util.Either[scala.Int, scala.Boolean]] = {
    var _a: java.util.ArrayList[scala.util.Either[scala.Int, scala.Boolean]] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.ArrayListHolder[scala.util.Either[scala.Int, scala.Boolean]]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else new java.util.ArrayList[scala.util.Either[scala.Int, scala.Boolean]][scala.util.Either[scala.Int, scala.Boolean]]({
                val parsedArray: scala.collection.mutable.ListBuffer[scala.util.Either[scala.Int, scala.Boolean]] = `in₃`.expectArray[scala.util.Either[scala.Int, scala.Boolean]]((() => {
                  val mark: scala.Int = `in₃`.pos
                  if (`in₃`.expectNull()) null else scala.util.Try.apply[scala.Boolean](`in₃`.expectBoolean()) match {
                    case scala.util.Success(rval) =>
                      scala.Right.apply[scala.Nothing, scala.Boolean](rval)
                    case scala.util.Failure(f) =>
                      `in₃`.revertToPos(mark)
                      scala.util.Try.apply[scala.Int](`in₃`.expectInt()) match {
                        case scala.util.Success(lval) =>
                          scala.Left.apply[scala.Int, scala.Nothing](lval)
                        case scala.util.Failure(_) =>
                          `in₃`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₃`)
                      }
                  }
                }))
                scala.jdk.CollectionConverters.SeqHasAsJava[scala.util.Either[scala.Int, scala.Boolean]](parsedArray.toList).asJava.asInstanceOf[java.util.Collection[scala.util.Either[scala.Int, scala.Boolean]]]
              })
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.ArrayListHolder[scala.util.Either[scala.Int, scala.Boolean]][scala.util.Either[scala.Int, scala.Boolean]](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[scala.util.Either[scala.Int, scala.Boolean]]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.ArrayListHolder[scala.util.Either[scala.Int, scala.Boolean]], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[scala.util.Either[scala.Int, scala.Boolean]] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[scala.util.Either[scala.Int, scala.Boolean]]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_ArrayListHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: java.util.ArrayList[scala.Int | scala.Boolean], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    scala.Predef.refArrayOps[java.lang.Object](in.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => {
      out.mark()
      scala.util.Try.apply[scala.Unit](out.value(elem.asInstanceOf[scala.Int | scala.Boolean].asInstanceOf[scala.Boolean])) match {
        case scala.util.Success(_) =>
          ()
        case scala.util.Failure(_) =>
          out.revert()
          out.value(elem.asInstanceOf[scala.Int | scala.Boolean].asInstanceOf[scala.Int])
      }
    }))
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int | scala.Boolean], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int | scala.Boolean] = {
    var _a: java.util.ArrayList[scala.Int | scala.Boolean] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int | scala.Boolean]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else new java.util.ArrayList[scala.Int | scala.Boolean][scala.Int | scala.Boolean]({
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Int | scala.Boolean] = `in₃`.expectArray[scala.Int | scala.Boolean]((() => {
                  val mark: scala.Int = `in₃`.pos
                  scala.util.Try.apply[scala.Int](`in₃`.expectInt()) match {
                    case scala.util.Success(lval) =>
                      (lval: scala.Int)
                    case scala.util.Failure(f) =>
                      `in₃`.revertToPos(mark)
                      scala.util.Try.apply[scala.Boolean](`in₃`.expectBoolean()) match {
                        case scala.util.Success(rval) =>
                          (rval: scala.Boolean)
                        case scala.util.Failure(_) =>
                          `in₃`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₃`)
                      }
                  }
                }))
                scala.jdk.CollectionConverters.SeqHasAsJava[scala.Int | scala.Boolean](parsedArray.toList).asJava.asInstanceOf[java.util.Collection[scala.Int | scala.Boolean]]
              })
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int | scala.Boolean][scala.Int | scala.Boolean](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int | scala.Boolean]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int | scala.Boolean], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int | scala.Boolean] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[scala.Int | scala.Boolean]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_ArrayListHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: java.util.ArrayList[scala.Option[scala.Int]], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    scala.Predef.refArrayOps[java.lang.Object](in.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => elem.asInstanceOf[scala.Option[scala.Int]] match {
      case null =>
        out.burpNull()
      case scala.None =>
        ()
      case scala.Some(v) =>
        val vv: scala.Int = v.asInstanceOf[scala.Int]
        out.value(vv)
    }))
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.ArrayListHolder[scala.Option[scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[scala.Option[scala.Int]] = {
    var _a: java.util.ArrayList[scala.Option[scala.Int]] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.ArrayListHolder[scala.Option[scala.Int]]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else new java.util.ArrayList[scala.Option[scala.Int]][scala.Option[scala.Int]]({
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Option[scala.Int]] = `in₃`.expectArray[scala.Option[scala.Int]]((() => if (`in₃`.expectNull()) null else scala.Some.apply[scala.Int](`in₃`.expectInt())))
                scala.jdk.CollectionConverters.SeqHasAsJava[scala.Option[scala.Int]](parsedArray.toList).asJava.asInstanceOf[java.util.Collection[scala.Option[scala.Int]]]
              })
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.ArrayListHolder[scala.Option[scala.Int]][scala.Option[scala.Int]](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[scala.Option[scala.Int]]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.ArrayListHolder[scala.Option[scala.Int]], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[scala.Option[scala.Int]] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[scala.Option[scala.Int]]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_ArrayListHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w2(in: scala.collection.immutable.Map[scala.Predef.String, scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, scala.Int]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.valueEscaped(key)
          out.colon()
          out.value(value)
        }
    }))
    out.endObject()
  }
  def w1(`in₂`: java.util.ArrayList[scala.collection.immutable.Map[scala.Predef.String, scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startArray()
    scala.Predef.refArrayOps[java.lang.Object](`in₂`.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => w2(elem.asInstanceOf[scala.collection.immutable.Map[scala.Predef.String, scala.Int]], `out₂`)))
    `out₂`.endArray()
  }
  def w0(`in₃`: co.blocke.scalajack.json.collections.ArrayListHolder[scala.collection.immutable.Map[scala.Predef.String, scala.Int]], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `out₃`.label("a")
    w1(`in₃`.a, `out₃`)
    `out₃`.endObject()
  }
  def r0(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[scala.collection.immutable.Map[scala.Predef.String, scala.Int]] = {
    var _a: java.util.ArrayList[scala.collection.immutable.Map[scala.Predef.String, scala.Int]] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.ArrayListHolder[scala.collection.immutable.Map[scala.Predef.String, scala.Int]]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₄`.expectNull()) null else new java.util.ArrayList[scala.collection.immutable.Map[scala.Predef.String, scala.Int]][scala.collection.immutable.Map[scala.Predef.String, scala.Int]]({
                val parsedArray: scala.collection.mutable.ListBuffer[scala.collection.immutable.Map[scala.Predef.String, scala.Int]] = `in₄`.expectArray[scala.collection.immutable.Map[scala.Predef.String, scala.Int]]((() => if (`in₄`.expectNull()) null else {
                  `in₄`.expectToken('{')
                  `in₄`.parseMap[java.lang.String, scala.Int]((() => `in₄`.expectString()), (() => `in₄`.expectInt()), scala.Predef.Map.empty[java.lang.String, scala.Int], true)
                }))
                scala.jdk.CollectionConverters.SeqHasAsJava[scala.collection.immutable.Map[scala.Predef.String, scala.Int]](parsedArray.toList).asJava.asInstanceOf[java.util.Collection[scala.collection.immutable.Map[scala.Predef.String, scala.Int]]]
              })
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.ArrayListHolder[scala.collection.immutable.Map[scala.Predef.String, scala.Int]][scala.collection.immutable.Map[scala.Predef.String, scala.Int]](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₄`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[scala.collection.immutable.Map[scala.Predef.String, scala.Int]]] {
    def encodeValue(`in₅`: co.blocke.scalajack.json.collections.ArrayListHolder[scala.collection.immutable.Map[scala.Predef.String, scala.Int]], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₅`, `out₄`)
    def decodeValue(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[scala.collection.immutable.Map[scala.Predef.String, scala.Int]] = r0(`in₆`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[scala.collection.immutable.Map[scala.Predef.String, scala.Int]]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_Person_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("name", "age")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  val __co_blocke_scalajack_json_collections_ArrayListHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w2(in: co.blocke.scalajack.json.collections.Person, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("name")
    out.valueEscaped(in.name)
    out.label("age")
    out.value(in.age)
    out.endObject()
  }
  def w1(`in₂`: java.util.ArrayList[co.blocke.scalajack.json.collections.Person], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startArray()
    scala.Predef.refArrayOps[java.lang.Object](`in₂`.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => w2(elem.asInstanceOf[co.blocke.scalajack.json.collections.Person], `out₂`)))
    `out₂`.endArray()
  }
  def w0(`in₃`: co.blocke.scalajack.json.collections.ArrayListHolder[co.blocke.scalajack.json.collections.Person], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `out₃`.label("a")
    w1(`in₃`.a, `out₃`)
    `out₃`.endObject()
  }
  def r1(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.Person = {
    var _name: java.lang.String = ""
    var _age: scala.Int = 0
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_collections_Person_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.Person] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _name = `in₄`.expectString()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("name"), `in₄`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _age = `in₄`.expectInt()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("age"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_collections_Person_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.collections.Person(_name, _age) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("name", "age")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₄`)
    }
  }
  def r0(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[co.blocke.scalajack.json.collections.Person] = {
    var _a: java.util.ArrayList[co.blocke.scalajack.json.collections.Person] = null
    var `required₂`: scala.Int = 1
    var `maybeFieldNum₂`: scala.Option[scala.Int] = `in₅`.expectFirstObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
    if (`maybeFieldNum₂`.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.ArrayListHolder[co.blocke.scalajack.json.collections.Person]] else {
      while (`maybeFieldNum₂`.isDefined) {
        `maybeFieldNum₂`.get match {
          case 0 =>
            if (`required₂`.&(1).!=(0)) {
              `required₂` = `required₂`.^(1)
              _a = if (`in₅`.expectNull()) null else new java.util.ArrayList[co.blocke.scalajack.json.collections.Person][co.blocke.scalajack.json.collections.Person]({
                val parsedArray: scala.collection.mutable.ListBuffer[co.blocke.scalajack.json.collections.Person] = `in₅`.expectArray[co.blocke.scalajack.json.collections.Person]((() => r1(`in₅`)))
                scala.jdk.CollectionConverters.SeqHasAsJava[co.blocke.scalajack.json.collections.Person](parsedArray.toList).asJava.asInstanceOf[java.util.Collection[co.blocke.scalajack.json.collections.Person]]
              })
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₅`)
          case _ =>
            `in₅`.skipValue()
        }
        `maybeFieldNum₂` = `in₅`.expectObjectField(__co_blocke_scalajack_json_collections_ArrayListHolder_fields)
      }
      if (`required₂`.&(1).==(0)) new co.blocke.scalajack.json.collections.ArrayListHolder[co.blocke.scalajack.json.collections.Person][co.blocke.scalajack.json.collections.Person](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(`required₂`.&(1)))), `in₅`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[co.blocke.scalajack.json.collections.Person]] {
    def encodeValue(`in₆`: co.blocke.scalajack.json.collections.ArrayListHolder[co.blocke.scalajack.json.collections.Person], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₆`, `out₄`)
    def decodeValue(`in₇`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.ArrayListHolder[co.blocke.scalajack.json.collections.Person] = r0(`in₇`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.ArrayListHolder[co.blocke.scalajack.json.collections.Person]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_Holder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: java.util.concurrent.ArrayBlockingQueue[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    scala.Predef.refArrayOps[java.lang.Object](in.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => out.value(elem.asInstanceOf[scala.Int])))
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.Holder[java.util.concurrent.ArrayBlockingQueue[scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.Holder[java.util.concurrent.ArrayBlockingQueue[scala.Int]] = {
    var _a: java.util.concurrent.ArrayBlockingQueue[scala.Int] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_Holder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.Holder[java.util.concurrent.ArrayBlockingQueue[scala.Int]]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Int] = `in₃`.expectArray[scala.Int]((() => `in₃`.expectInt()))
                if (parsedArray.==(null)) null else new java.util.concurrent.ArrayBlockingQueue[scala.Int](parsedArray.length, true, scala.jdk.CollectionConverters.SeqHasAsJava[scala.Int](parsedArray.toList).asJava)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_Holder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.Holder[java.util.concurrent.ArrayBlockingQueue[scala.Int]][java.util.concurrent.ArrayBlockingQueue[scala.Int]](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.Holder[java.util.concurrent.ArrayBlockingQueue[scala.Int]]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.Holder[java.util.concurrent.ArrayBlockingQueue[scala.Int]], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.Holder[java.util.concurrent.ArrayBlockingQueue[scala.Int]] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.Holder[java.util.concurrent.ArrayBlockingQueue[scala.Int]]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_Holder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: java.util.TreeSet[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    scala.Predef.refArrayOps[java.lang.Object](in.toArray()).foreach[scala.Unit](((elem: java.lang.Object) => out.value(elem.asInstanceOf[scala.Int])))
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.Holder[java.util.TreeSet[scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.Holder[java.util.TreeSet[scala.Int]] = {
    var _a: java.util.TreeSet[scala.Int] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_Holder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.Holder[java.util.TreeSet[scala.Int]]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Int] = `in₃`.expectArray[scala.Int]((() => `in₃`.expectInt()))
                if (parsedArray.==(null)) null else new java.util.TreeSet[scala.Int](scala.jdk.CollectionConverters.SeqHasAsJava[scala.Int](parsedArray.toList).asJava)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_Holder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.Holder[java.util.TreeSet[scala.Int]][java.util.TreeSet[scala.Int]](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.Holder[java.util.TreeSet[scala.Int]]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.Holder[java.util.TreeSet[scala.Int]], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.Holder[java.util.TreeSet[scala.Int]] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.Holder[java.util.TreeSet[scala.Int]]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MapHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.Map[scala.Int, scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[scala.Int, scala.Int]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.valueStringified(scala.Int.int2long(key))
          out.colon()
          out.value(value)
        }
    }))
    out.endObject()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.MapHolder[scala.Int, scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Int, scala.Int] = {
    var _a: scala.collection.immutable.Map[scala.Int, scala.Int] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MapHolder[scala.Int, scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('{')
                `in₃`.parseMap[scala.Int, scala.Int]((() => scala.Predef.augmentString(`in₃`.expectString()).toInt), (() => `in₃`.expectInt()), scala.Predef.Map.empty[scala.Int, scala.Int], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MapHolder[scala.Int, scala.Int][scala.Int, scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Int, scala.Int]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.MapHolder[scala.Int, scala.Int], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Int, scala.Int] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Int, scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MapHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.Map[scala.Predef.String, scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, scala.Int]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.valueEscaped(key)
          out.colon()
          out.value(value)
        }
    }))
    out.endObject()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Int] = {
    var _a: scala.collection.immutable.Map[scala.Predef.String, scala.Int] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('{')
                `in₃`.parseMap[java.lang.String, scala.Int]((() => `in₃`.expectString()), (() => `in₃`.expectInt()), scala.Predef.Map.empty[java.lang.String, scala.Int], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Int][java.lang.String, scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Int]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Int], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Int] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MapHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.Map[scala.Long, scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[scala.Long, scala.Int]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.valueStringified(key)
          out.colon()
          out.value(value)
        }
    }))
    out.endObject()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.MapHolder[scala.Long, scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Long, scala.Int] = {
    var _a: scala.collection.immutable.Map[scala.Long, scala.Int] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MapHolder[scala.Long, scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('{')
                `in₃`.parseMap[scala.Long, scala.Int]((() => scala.Predef.augmentString(`in₃`.expectString()).toLong), (() => `in₃`.expectInt()), scala.Predef.Map.empty[scala.Long, scala.Int], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MapHolder[scala.Long, scala.Int][scala.Long, scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Long, scala.Int]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.MapHolder[scala.Long, scala.Int], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Long, scala.Int] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Long, scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MapHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.Map[scala.Boolean, scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[scala.Boolean, scala.Int]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.valueStringified(key)
          out.colon()
          out.value(value)
        }
    }))
    out.endObject()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.MapHolder[scala.Boolean, scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Boolean, scala.Int] = {
    var _a: scala.collection.immutable.Map[scala.Boolean, scala.Int] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MapHolder[scala.Boolean, scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('{')
                `in₃`.parseMap[scala.Boolean, scala.Int]((() => scala.Predef.augmentString(`in₃`.expectString()).toBoolean), (() => `in₃`.expectInt()), scala.Predef.Map.empty[scala.Boolean, scala.Int], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MapHolder[scala.Boolean, scala.Int][scala.Boolean, scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Boolean, scala.Int]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.MapHolder[scala.Boolean, scala.Int], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Boolean, scala.Int] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Boolean, scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MapHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.Map[java.util.UUID, scala.Predef.String], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[java.util.UUID, java.lang.String]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.value(key)
          out.colon()
          out.valueEscaped(value)
        }
    }))
    out.endObject()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.MapHolder[java.util.UUID, scala.Predef.String], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[java.util.UUID, scala.Predef.String] = {
    var _a: scala.collection.immutable.Map[java.util.UUID, scala.Predef.String] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MapHolder[java.util.UUID, scala.Predef.String]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('{')
                `in₃`.parseMap[java.util.UUID, java.lang.String]((() => `in₃`.expectString[java.util.UUID](((x$0: java.lang.String) => java.util.UUID.fromString(x$0)))), (() => `in₃`.expectString()), scala.Predef.Map.empty[java.util.UUID, java.lang.String], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MapHolder[java.util.UUID, scala.Predef.String][java.util.UUID, java.lang.String](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[java.util.UUID, scala.Predef.String]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.MapHolder[java.util.UUID, scala.Predef.String], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[java.util.UUID, scala.Predef.String] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[java.util.UUID, scala.Predef.String]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MapHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.Map[scala.Predef.String, scala.Predef.String], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, java.lang.String]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.valueEscaped(key)
          out.colon()
          out.valueEscaped(value)
        }
    }))
    out.endObject()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Predef.String], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Predef.String] = {
    var _a: scala.collection.immutable.Map[scala.Predef.String, scala.Predef.String] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Predef.String]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('{')
                `in₃`.parseMap[java.lang.String, java.lang.String]((() => `in₃`.expectString()), (() => `in₃`.expectString()), scala.Predef.Map.empty[java.lang.String, java.lang.String], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Predef.String][java.lang.String, java.lang.String](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Predef.String]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Predef.String], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Predef.String] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Predef.String]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MapHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.Map[scala.Predef.String, scala.Long], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, scala.Long]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.valueEscaped(key)
          out.colon()
          out.value(value)
        }
    }))
    out.endObject()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Long], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Long] = {
    var _a: scala.collection.immutable.Map[scala.Predef.String, scala.Long] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Long]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('{')
                `in₃`.parseMap[java.lang.String, scala.Long]((() => `in₃`.expectString()), (() => `in₃`.expectLong()), scala.Predef.Map.empty[java.lang.String, scala.Long], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Long][java.lang.String, scala.Long](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Long]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Long], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Long] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Long]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MapHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.Map[scala.Predef.String, scala.Boolean], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, scala.Boolean]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.valueEscaped(key)
          out.colon()
          out.value(value)
        }
    }))
    out.endObject()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Boolean], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Boolean] = {
    var _a: scala.collection.immutable.Map[scala.Predef.String, scala.Boolean] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Boolean]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('{')
                `in₃`.parseMap[java.lang.String, scala.Boolean]((() => `in₃`.expectString()), (() => `in₃`.expectBoolean()), scala.Predef.Map.empty[java.lang.String, scala.Boolean], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Boolean][java.lang.String, scala.Boolean](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Boolean]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Boolean], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Boolean] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Boolean]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MapHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.Map[co.blocke.scalajack.json.collections.Model$package.OnOff, co.blocke.scalajack.json.collections.Model$package.Counter], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[co.blocke.scalajack.json.collections.Model$package.OnOff, co.blocke.scalajack.json.collections.Model$package.Counter]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.valueStringified(key.asInstanceOf[scala.Boolean])
          out.colon()
          out.value(value.asInstanceOf[scala.Short])
        }
    }))
    out.endObject()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.MapHolder[co.blocke.scalajack.json.collections.Model$package.OnOff, co.blocke.scalajack.json.collections.Model$package.Counter], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[co.blocke.scalajack.json.collections.Model$package.OnOff, co.blocke.scalajack.json.collections.Model$package.Counter] = {
    var _a: scala.collection.immutable.Map[co.blocke.scalajack.json.collections.Model$package.OnOff, co.blocke.scalajack.json.collections.Model$package.Counter] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MapHolder[co.blocke.scalajack.json.collections.Model$package.OnOff, co.blocke.scalajack.json.collections.Model$package.Counter]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('{')
                `in₃`.parseMap[co.blocke.scalajack.json.collections.Model$package.OnOff, co.blocke.scalajack.json.collections.Model$package.Counter]((() => scala.Predef.augmentString(`in₃`.expectString()).toBoolean.asInstanceOf[co.blocke.scalajack.json.collections.Model$package.OnOff]), (() => `in₃`.expectInt().toShort.asInstanceOf[co.blocke.scalajack.json.collections.Model$package.Counter]), scala.Predef.Map.empty[co.blocke.scalajack.json.collections.Model$package.OnOff, co.blocke.scalajack.json.collections.Model$package.Counter], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MapHolder[co.blocke.scalajack.json.collections.Model$package.OnOff, co.blocke.scalajack.json.collections.Model$package.Counter][co.blocke.scalajack.json.collections.Model$package.OnOff, co.blocke.scalajack.json.collections.Model$package.Counter](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[co.blocke.scalajack.json.collections.Model$package.OnOff, co.blocke.scalajack.json.collections.Model$package.Counter]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.MapHolder[co.blocke.scalajack.json.collections.Model$package.OnOff, co.blocke.scalajack.json.collections.Model$package.Counter], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[co.blocke.scalajack.json.collections.Model$package.OnOff, co.blocke.scalajack.json.collections.Model$package.Counter] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[co.blocke.scalajack.json.collections.Model$package.OnOff, co.blocke.scalajack.json.collections.Model$package.Counter]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MapHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.Map[scala.Predef.String, java.util.UUID], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, java.util.UUID]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.valueEscaped(key)
          out.colon()
          out.value(value)
        }
    }))
    out.endObject()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, java.util.UUID], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, java.util.UUID] = {
    var _a: scala.collection.immutable.Map[scala.Predef.String, java.util.UUID] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, java.util.UUID]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('{')
                `in₃`.parseMap[java.lang.String, java.util.UUID]((() => `in₃`.expectString()), (() => `in₃`.expectString[java.util.UUID](((x$0: java.lang.String) => java.util.UUID.fromString(x$0)))), scala.Predef.Map.empty[java.lang.String, java.util.UUID], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, java.util.UUID][java.lang.String, java.util.UUID](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, java.util.UUID]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, java.util.UUID], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, java.util.UUID] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, java.util.UUID]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MapHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w2(in: scala.collection.immutable.List[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    in.foreach[scala.Unit](((i: scala.Int) => out.value(i)))
    out.endArray()
  }
  def w1(`in₂`: scala.collection.immutable.Map[scala.Predef.String, scala.collection.immutable.List[scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `in₂`.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, scala.collection.immutable.List[scala.Int]]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          `out₂`.maybeComma()
          `out₂`.valueEscaped(key)
          `out₂`.colon()
          w2(value, `out₂`)
        }
    }))
    `out₂`.endObject()
  }
  def w0(`in₃`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.collection.immutable.List[scala.Int]], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `out₃`.label("a")
    w1(`in₃`.a, `out₃`)
    `out₃`.endObject()
  }
  def r0(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.collection.immutable.List[scala.Int]] = {
    var _a: scala.collection.immutable.Map[scala.Predef.String, scala.collection.immutable.List[scala.Int]] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.collection.immutable.List[scala.Int]]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₄`.expectNull()) null else {
                `in₄`.expectToken('{')
                `in₄`.parseMap[java.lang.String, scala.collection.immutable.List[scala.Int]]((() => `in₄`.expectString()), (() => {
                  val parsedArray: scala.collection.mutable.ListBuffer[scala.Int] = `in₄`.expectArray[scala.Int]((() => `in₄`.expectInt()))

                  (if (parsedArray.!=(null)) parsedArray.toList else null: scala.collection.immutable.List[scala.Int])
                }), scala.Predef.Map.empty[java.lang.String, scala.collection.immutable.List[scala.Int]], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.collection.immutable.List[scala.Int]][java.lang.String, scala.collection.immutable.List[scala.Int]](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₄`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.collection.immutable.List[scala.Int]]] {
    def encodeValue(`in₅`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.collection.immutable.List[scala.Int]], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₅`, `out₄`)
    def decodeValue(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.collection.immutable.List[scala.Int]] = r0(`in₆`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.collection.immutable.List[scala.Int]]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MapHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w2(in: scala.collection.immutable.Map[scala.Predef.String, scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, scala.Int]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.valueEscaped(key)
          out.colon()
          out.value(value)
        }
    }))
    out.endObject()
  }
  def w1(`in₂`: scala.collection.immutable.Map[scala.Predef.String, scala.collection.immutable.Map[scala.Predef.String, scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `in₂`.foreach[scala.Unit](((`x$1₂`: scala.Tuple2[java.lang.String, scala.collection.immutable.Map[scala.Predef.String, scala.Int]]) => `x$1₂` match {
      case scala.Tuple2(key, value) =>
        {
          `out₂`.maybeComma()
          `out₂`.valueEscaped(`key₂`)
          `out₂`.colon()
          w2(`value₂`, `out₂`)
        }
    }))
    `out₂`.endObject()
  }
  def w0(`in₃`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.collection.immutable.Map[scala.Predef.String, scala.Int]], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `out₃`.label("a")
    w1(`in₃`.a, `out₃`)
    `out₃`.endObject()
  }
  def r0(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.collection.immutable.Map[scala.Predef.String, scala.Int]] = {
    var _a: scala.collection.immutable.Map[scala.Predef.String, scala.collection.immutable.Map[scala.Predef.String, scala.Int]] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.collection.immutable.Map[scala.Predef.String, scala.Int]]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₄`.expectNull()) null else {
                `in₄`.expectToken('{')
                `in₄`.parseMap[java.lang.String, scala.collection.immutable.Map[scala.Predef.String, scala.Int]]((() => `in₄`.expectString()), (() => if (`in₄`.expectNull()) null else {
                  `in₄`.expectToken('{')
                  `in₄`.parseMap[java.lang.String, scala.Int]((() => `in₄`.expectString()), (() => `in₄`.expectInt()), scala.Predef.Map.empty[java.lang.String, scala.Int], true)
                }), scala.Predef.Map.empty[java.lang.String, scala.collection.immutable.Map[scala.Predef.String, scala.Int]], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.collection.immutable.Map[scala.Predef.String, scala.Int]][java.lang.String, scala.collection.immutable.Map[scala.Predef.String, scala.Int]](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₄`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.collection.immutable.Map[scala.Predef.String, scala.Int]]] {
    def encodeValue(`in₅`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.collection.immutable.Map[scala.Predef.String, scala.Int]], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₅`, `out₄`)
    def decodeValue(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.collection.immutable.Map[scala.Predef.String, scala.Int]] = r0(`in₆`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.collection.immutable.Map[scala.Predef.String, scala.Int]]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MapHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w2(in: scala.collection.immutable.List[scala.Predef.String], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    in.foreach[scala.Unit](((i: java.lang.String) => out.valueEscaped(i)))
    out.endArray()
  }
  def w1(`in₂`: scala.collection.immutable.Map[scala.Predef.String, scala.Int | scala.collection.immutable.List[scala.Predef.String]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `in₂`.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, scala.Int | scala.collection.immutable.List[scala.Predef.String]]) => x$1 match {
      case scala.Tuple2(key, value) =>
        if (value.==(null)) `out₂`.burpNull() else {
          `out₂`.mark()
          scala.util.Try.apply[scala.Unit]({
            `out₂`.maybeComma()
            `out₂`.valueEscaped(key)
            `out₂`.colon()
            w2(value.asInstanceOf[scala.collection.immutable.List[scala.Predef.String]], `out₂`)
          }) match {
            case scala.util.Success(_) =>
              ()
            case scala.util.Failure(f) =>
              `out₂`.revert()
              {
                `out₂`.maybeComma()
                `out₂`.valueEscaped(key)
                `out₂`.colon()
                `out₂`.value(value.asInstanceOf[scala.Int])
              }
          }
        }
    }))
    `out₂`.endObject()
  }
  def w0(`in₃`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Int | scala.collection.immutable.List[scala.Predef.String]], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `out₃`.label("a")
    w1(`in₃`.a, `out₃`)
    `out₃`.endObject()
  }
  def r0(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Int | scala.collection.immutable.List[scala.Predef.String]] = {
    var _a: scala.collection.immutable.Map[scala.Predef.String, scala.Int | scala.collection.immutable.List[scala.Predef.String]] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Int | scala.collection.immutable.List[scala.Predef.String]]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₄`.expectNull()) null else {
                `in₄`.expectToken('{')
                `in₄`.parseMap[java.lang.String, scala.Int | scala.collection.immutable.List[scala.Predef.String]]((() => `in₄`.expectString()), (() => {
                  val mark: scala.Int = `in₄`.pos
                  scala.util.Try.apply[scala.Int](`in₄`.expectInt()) match {
                    case scala.util.Success(lval) =>
                      (lval: scala.Int)
                    case scala.util.Failure(f) =>
                      `in₄`.revertToPos(mark)
                      scala.util.Try.apply[scala.collection.immutable.List[scala.Predef.String]]({
                        val parsedArray: scala.collection.mutable.ListBuffer[java.lang.String] = `in₄`.expectArray[java.lang.String]((() => `in₄`.expectString()))

                        (if (parsedArray.!=(null)) parsedArray.toList else null: scala.collection.immutable.List[java.lang.String])
                      }) match {
                        case scala.util.Success(rval) =>
                          (rval: scala.collection.immutable.List[scala.Predef.String])
                        case scala.util.Failure(_) =>
                          `in₄`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₄`)
                      }
                  }
                }), scala.Predef.Map.empty[java.lang.String, scala.Int | scala.collection.immutable.List[scala.Predef.String]], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Int | scala.collection.immutable.List[scala.Predef.String]][java.lang.String, scala.Int | scala.collection.immutable.List[scala.Predef.String]](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₄`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Int | scala.collection.immutable.List[scala.Predef.String]]] {
    def encodeValue(`in₅`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Int | scala.collection.immutable.List[scala.Predef.String]], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₅`, `out₄`)
    def decodeValue(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Int | scala.collection.immutable.List[scala.Predef.String]] = r0(`in₆`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, scala.Int | scala.collection.immutable.List[scala.Predef.String]]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_Person_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("name", "age")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  val __co_blocke_scalajack_json_collections_MapHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w2(in: co.blocke.scalajack.json.collections.Person, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("name")
    out.valueEscaped(in.name)
    out.label("age")
    out.value(in.age)
    out.endObject()
  }
  def w1(`in₂`: scala.collection.immutable.Map[scala.Predef.String, co.blocke.scalajack.json.collections.Person], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `in₂`.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, co.blocke.scalajack.json.collections.Person]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          `out₂`.maybeComma()
          `out₂`.valueEscaped(key)
          `out₂`.colon()
          w2(value, `out₂`)
        }
    }))
    `out₂`.endObject()
  }
  def w0(`in₃`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Person], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `out₃`.label("a")
    w1(`in₃`.a, `out₃`)
    `out₃`.endObject()
  }
  def r1(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.Person = {
    var _name: java.lang.String = ""
    var _age: scala.Int = 0
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_collections_Person_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.Person] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _name = `in₄`.expectString()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("name"), `in₄`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _age = `in₄`.expectInt()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("age"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_collections_Person_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.collections.Person(_name, _age) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("name", "age")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₄`)
    }
  }
  def r0(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Person] = {
    var _a: scala.collection.immutable.Map[scala.Predef.String, co.blocke.scalajack.json.collections.Person] = null
    var `required₂`: scala.Int = 1
    var `maybeFieldNum₂`: scala.Option[scala.Int] = `in₅`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
    if (`maybeFieldNum₂`.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Person]] else {
      while (`maybeFieldNum₂`.isDefined) {
        `maybeFieldNum₂`.get match {
          case 0 =>
            if (`required₂`.&(1).!=(0)) {
              `required₂` = `required₂`.^(1)
              _a = if (`in₅`.expectNull()) null else {
                `in₅`.expectToken('{')
                `in₅`.parseMap[java.lang.String, co.blocke.scalajack.json.collections.Person]((() => `in₅`.expectString()), (() => r1(`in₅`)), scala.Predef.Map.empty[java.lang.String, co.blocke.scalajack.json.collections.Person], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₅`)
          case _ =>
            `in₅`.skipValue()
        }
        `maybeFieldNum₂` = `in₅`.expectObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
      }
      if (`required₂`.&(1).==(0)) new co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Person][java.lang.String, co.blocke.scalajack.json.collections.Person](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(`required₂`.&(1)))), `in₅`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Person]] {
    def encodeValue(`in₆`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Person], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₆`, `out₄`)
    def decodeValue(`in₇`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Person] = r0(`in₇`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Person]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MapHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.Map[co.blocke.scalajack.json.collections.Distance, scala.Predef.String], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[co.blocke.scalajack.json.collections.Distance, java.lang.String]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.valueStringified(key.meters)
          out.colon()
          out.valueEscaped(value)
        }
    }))
    out.endObject()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.MapHolder[co.blocke.scalajack.json.collections.Distance, scala.Predef.String], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[co.blocke.scalajack.json.collections.Distance, scala.Predef.String] = {
    var _a: scala.collection.immutable.Map[co.blocke.scalajack.json.collections.Distance, scala.Predef.String] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MapHolder[co.blocke.scalajack.json.collections.Distance, scala.Predef.String]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('{')
                `in₃`.parseMap[co.blocke.scalajack.json.collections.Distance, java.lang.String]((() => new co.blocke.scalajack.json.collections.Distance(scala.Predef.augmentString(`in₃`.expectString()).toDouble)), (() => `in₃`.expectString()), scala.Predef.Map.empty[co.blocke.scalajack.json.collections.Distance, java.lang.String], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MapHolder[co.blocke.scalajack.json.collections.Distance, scala.Predef.String][co.blocke.scalajack.json.collections.Distance, java.lang.String](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[co.blocke.scalajack.json.collections.Distance, scala.Predef.String]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.MapHolder[co.blocke.scalajack.json.collections.Distance, scala.Predef.String], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[co.blocke.scalajack.json.collections.Distance, scala.Predef.String] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[co.blocke.scalajack.json.collections.Distance, scala.Predef.String]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MapHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.Map[scala.Predef.String, co.blocke.scalajack.json.collections.Distance], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, co.blocke.scalajack.json.collections.Distance]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.valueEscaped(key)
          out.colon()
          out.value(value.meters)
        }
    }))
    out.endObject()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Distance], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Distance] = {
    var _a: scala.collection.immutable.Map[scala.Predef.String, co.blocke.scalajack.json.collections.Distance] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Distance]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('{')
                `in₃`.parseMap[java.lang.String, co.blocke.scalajack.json.collections.Distance]((() => `in₃`.expectString()), (() => new co.blocke.scalajack.json.collections.Distance(`in₃`.expectDouble())), scala.Predef.Map.empty[java.lang.String, co.blocke.scalajack.json.collections.Distance], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_MapHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Distance][java.lang.String, co.blocke.scalajack.json.collections.Distance](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Distance]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Distance], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Distance] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Distance]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MMapHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.mutable.Map[scala.Predef.String, co.blocke.scalajack.json.collections.Distance], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, co.blocke.scalajack.json.collections.Distance]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.valueEscaped(key)
          out.colon()
          out.value(value.meters)
        }
    }))
    out.endObject()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.MMapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Distance], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MMapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Distance] = {
    var _a: scala.collection.mutable.Map[scala.Predef.String, co.blocke.scalajack.json.collections.Distance] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MMapHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MMapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Distance]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('{')
                scala.collection.mutable.Map.from[java.lang.String, co.blocke.scalajack.json.collections.Distance](`in₃`.parseMap[java.lang.String, co.blocke.scalajack.json.collections.Distance]((() => `in₃`.expectString()), (() => new co.blocke.scalajack.json.collections.Distance(`in₃`.expectDouble())), scala.Predef.Map.empty[java.lang.String, co.blocke.scalajack.json.collections.Distance], true))
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_MMapHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MMapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Distance][java.lang.String, co.blocke.scalajack.json.collections.Distance](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MMapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Distance]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.MMapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Distance], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MMapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Distance] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MMapHolder[scala.Predef.String, co.blocke.scalajack.json.collections.Distance]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MMapHolder2_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.mutable.HashMap[scala.Predef.String, co.blocke.scalajack.json.collections.Distance], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, co.blocke.scalajack.json.collections.Distance]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.valueEscaped(key)
          out.colon()
          out.value(value.meters)
        }
    }))
    out.endObject()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.MMapHolder2[scala.Predef.String, co.blocke.scalajack.json.collections.Distance], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MMapHolder2[scala.Predef.String, co.blocke.scalajack.json.collections.Distance] = {
    var _a: scala.collection.mutable.HashMap[scala.Predef.String, co.blocke.scalajack.json.collections.Distance] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MMapHolder2_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MMapHolder2[scala.Predef.String, co.blocke.scalajack.json.collections.Distance]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('{')
                scala.collection.mutable.HashMap.from[java.lang.String, co.blocke.scalajack.json.collections.Distance](`in₃`.parseMap[java.lang.String, co.blocke.scalajack.json.collections.Distance]((() => `in₃`.expectString()), (() => new co.blocke.scalajack.json.collections.Distance(`in₃`.expectDouble())), scala.Predef.Map.empty[java.lang.String, co.blocke.scalajack.json.collections.Distance], true))
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_MMapHolder2_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MMapHolder2[scala.Predef.String, co.blocke.scalajack.json.collections.Distance][java.lang.String, co.blocke.scalajack.json.collections.Distance](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MMapHolder2[scala.Predef.String, co.blocke.scalajack.json.collections.Distance]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.MMapHolder2[scala.Predef.String, co.blocke.scalajack.json.collections.Distance], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MMapHolder2[scala.Predef.String, co.blocke.scalajack.json.collections.Distance] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MMapHolder2[scala.Predef.String, co.blocke.scalajack.json.collections.Distance]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MMapHolder3_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.mutable.SeqMap[scala.Predef.String, co.blocke.scalajack.json.collections.Distance], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, co.blocke.scalajack.json.collections.Distance]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.valueEscaped(key)
          out.colon()
          out.value(value.meters)
        }
    }))
    out.endObject()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.MMapHolder3[scala.Predef.String, co.blocke.scalajack.json.collections.Distance], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MMapHolder3[scala.Predef.String, co.blocke.scalajack.json.collections.Distance] = {
    var _a: scala.collection.mutable.SeqMap[scala.Predef.String, co.blocke.scalajack.json.collections.Distance] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MMapHolder3_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MMapHolder3[scala.Predef.String, co.blocke.scalajack.json.collections.Distance]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('{')
                scala.collection.mutable.Map.from[java.lang.String, co.blocke.scalajack.json.collections.Distance](`in₃`.parseMap[java.lang.String, co.blocke.scalajack.json.collections.Distance]((() => `in₃`.expectString()), (() => new co.blocke.scalajack.json.collections.Distance(`in₃`.expectDouble())), scala.Predef.Map.empty[java.lang.String, co.blocke.scalajack.json.collections.Distance], true)).to[scala.collection.mutable.SeqMap[scala.Predef.String, co.blocke.scalajack.json.collections.Distance]](scala.collection.mutable.SeqMap.mapFactory[java.lang.String, co.blocke.scalajack.json.collections.Distance])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_MMapHolder3_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MMapHolder3[scala.Predef.String, co.blocke.scalajack.json.collections.Distance][java.lang.String, co.blocke.scalajack.json.collections.Distance](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MMapHolder3[scala.Predef.String, co.blocke.scalajack.json.collections.Distance]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.MMapHolder3[scala.Predef.String, co.blocke.scalajack.json.collections.Distance], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MMapHolder3[scala.Predef.String, co.blocke.scalajack.json.collections.Distance] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MMapHolder3[scala.Predef.String, co.blocke.scalajack.json.collections.Distance]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MapHolder2_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.HashMap[scala.Predef.String, co.blocke.scalajack.json.collections.Distance], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, co.blocke.scalajack.json.collections.Distance]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.valueEscaped(key)
          out.colon()
          out.value(value.meters)
        }
    }))
    out.endObject()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.MapHolder2[scala.Predef.String, co.blocke.scalajack.json.collections.Distance], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder2[scala.Predef.String, co.blocke.scalajack.json.collections.Distance] = {
    var _a: scala.collection.immutable.HashMap[scala.Predef.String, co.blocke.scalajack.json.collections.Distance] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MapHolder2_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MapHolder2[scala.Predef.String, co.blocke.scalajack.json.collections.Distance]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('{')
                scala.collection.immutable.HashMap.from[java.lang.String, co.blocke.scalajack.json.collections.Distance](`in₃`.parseMap[java.lang.String, co.blocke.scalajack.json.collections.Distance]((() => `in₃`.expectString()), (() => new co.blocke.scalajack.json.collections.Distance(`in₃`.expectDouble())), scala.Predef.Map.empty[java.lang.String, co.blocke.scalajack.json.collections.Distance], true))
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_MapHolder2_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MapHolder2[scala.Predef.String, co.blocke.scalajack.json.collections.Distance][java.lang.String, co.blocke.scalajack.json.collections.Distance](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder2[scala.Predef.String, co.blocke.scalajack.json.collections.Distance]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.MapHolder2[scala.Predef.String, co.blocke.scalajack.json.collections.Distance], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder2[scala.Predef.String, co.blocke.scalajack.json.collections.Distance] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder2[scala.Predef.String, co.blocke.scalajack.json.collections.Distance]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_MapHolder3_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.SeqMap[scala.Predef.String, co.blocke.scalajack.json.collections.Distance], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, co.blocke.scalajack.json.collections.Distance]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          out.maybeComma()
          out.valueEscaped(key)
          out.colon()
          out.value(value.meters)
        }
    }))
    out.endObject()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.MapHolder3[scala.Predef.String, co.blocke.scalajack.json.collections.Distance], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder3[scala.Predef.String, co.blocke.scalajack.json.collections.Distance] = {
    var _a: scala.collection.immutable.SeqMap[scala.Predef.String, co.blocke.scalajack.json.collections.Distance] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_MapHolder3_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.MapHolder3[scala.Predef.String, co.blocke.scalajack.json.collections.Distance]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('{')
                scala.collection.immutable.SeqMap.from[java.lang.String, co.blocke.scalajack.json.collections.Distance](`in₃`.parseMap[java.lang.String, co.blocke.scalajack.json.collections.Distance]((() => `in₃`.expectString()), (() => new co.blocke.scalajack.json.collections.Distance(`in₃`.expectDouble())), scala.Predef.Map.empty[java.lang.String, co.blocke.scalajack.json.collections.Distance], true))
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_MapHolder3_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.MapHolder3[scala.Predef.String, co.blocke.scalajack.json.collections.Distance][java.lang.String, co.blocke.scalajack.json.collections.Distance](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder3[scala.Predef.String, co.blocke.scalajack.json.collections.Distance]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.MapHolder3[scala.Predef.String, co.blocke.scalajack.json.collections.Distance], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.MapHolder3[scala.Predef.String, co.blocke.scalajack.json.collections.Distance] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.MapHolder3[scala.Predef.String, co.blocke.scalajack.json.collections.Distance]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_TupleHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    out.value(in._1)
    out.valueEscaped(in._2)
    out.value(in._3)
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean] = {
    var _a: scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_TupleHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('[')
                val tv: scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean] = new scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean][scala.Int, java.lang.String, scala.Boolean](`in₃`.expectInt(), {
                  `in₃`.expectToken(',')
                  `in₃`.expectString()
                }, {
                  `in₃`.expectToken(',')
                  `in₃`.expectBoolean()
                })
                `in₃`.expectToken(']')

                (tv: scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_TupleHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean][scala.Int, java.lang.String, scala.Boolean](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_TupleHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    out.value(in._1)
    out.valueEscaped(in._2)
    out.value(in._3)
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean] = {
    var _a: scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_TupleHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('[')
                val tv: scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean] = new scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean][scala.Int, java.lang.String, scala.Boolean](`in₃`.expectInt(), {
                  `in₃`.expectToken(',')
                  `in₃`.expectString()
                }, {
                  `in₃`.expectToken(',')
                  `in₃`.expectBoolean()
                })
                `in₃`.expectToken(']')

                (tv: scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_TupleHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean][scala.Int, java.lang.String, scala.Boolean](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_TupleHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    out.value(in._1)
    out.valueEscaped(in._2)
    out.value(in._3)
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean] = {
    var _a: scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_TupleHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('[')
                val tv: scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean] = new scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean][scala.Int, java.lang.String, scala.Boolean](`in₃`.expectInt(), {
                  `in₃`.expectToken(',')
                  `in₃`.expectString()
                }, {
                  `in₃`.expectToken(',')
                  `in₃`.expectBoolean()
                })
                `in₃`.expectToken(']')

                (tv: scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_TupleHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean][scala.Int, java.lang.String, scala.Boolean](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean]])
}
Codec: {
  val __co_blocke_scalajack_json_collections_TupleHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    out.value(in._1)
    out.valueEscaped(in._2)
    out.value(in._3)
    out.endArray()
  }
  def w0(`in₂`: co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `out₂`.label("a")
    w1(`in₂`.a, `out₂`)
    `out₂`.endObject()
  }
  def r0(`in₃`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean] = {
    var _a: scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₃`.expectFirstObjectField(__co_blocke_scalajack_json_collections_TupleHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₃`.expectNull()) null else {
                `in₃`.expectToken('[')
                val tv: scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean] = new scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean][scala.Int, java.lang.String, scala.Boolean](`in₃`.expectInt(), {
                  `in₃`.expectToken(',')
                  `in₃`.expectString()
                }, {
                  `in₃`.expectToken(',')
                  `in₃`.expectBoolean()
                })
                `in₃`.expectToken(']')

                (tv: scala.Tuple3[scala.Int, scala.Predef.String, scala.Boolean])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₃`)
          case _ =>
            `in₃`.skipValue()
        }
        maybeFieldNum = `in₃`.expectObjectField(__co_blocke_scalajack_json_collections_TupleHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean][scala.Int, java.lang.String, scala.Boolean](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₃`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean]] {
    def encodeValue(`in₄`: co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₄`, `out₃`)
    def decodeValue(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean] = r0(`in₅`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.collections.TupleHolder[scala.Int, scala.Predef.String, scala.Boolean]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_AliasHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b", "c", "d")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.List[AliasSpec.this.Count], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    in.foreach[scala.Unit](((i: scala.Int) => out.value(i)))
    out.endArray()
  }
  def w2(`in₂`: scala.collection.immutable.Map[AliasSpec.this.Count, scala.Predef.String], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `in₂`.foreach[scala.Unit](((x$1: scala.Tuple2[scala.Int, java.lang.String]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          `out₂`.maybeComma()
          `out₂`.valueStringified(scala.Int.int2long(key))
          `out₂`.colon()
          `out₂`.valueEscaped(value)
        }
    }))
    `out₂`.endObject()
  }
  def w3(`in₃`: scala.collection.immutable.Map[scala.Predef.String, AliasSpec.this.Count], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `in₃`.foreach[scala.Unit](((`x$1₂`: scala.Tuple2[java.lang.String, scala.Int]) => `x$1₂` match {
      case scala.Tuple2(key, value) =>
        {
          `out₃`.maybeComma()
          `out₃`.valueEscaped(`key₂`)
          `out₃`.colon()
          `out₃`.value(`value₂`)
        }
    }))
    `out₃`.endObject()
  }
  def w0(`in₄`: co.blocke.scalajack.json.misc.AliasHolder[AliasSpec.this.Count], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₄`.==(null)) `out₄`.burpNull() else {
    `out₄`.startObject()
    `out₄`.label("a")
    `out₄`.value(`in₄`.a)
    `out₄`.label("b")
    w1(`in₄`.b, `out₄`)
    `out₄`.label("c")
    w2(`in₄`.c, `out₄`)
    `out₄`.label("d")
    w3(`in₄`.d, `out₄`)
    `out₄`.endObject()
  }
  def r0(`in₅`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.AliasHolder[AliasSpec.this.Count] = {
    var _a: scala.Int = 0
    var _b: scala.collection.immutable.List[AliasSpec.this.Count] = null
    var _c: scala.collection.immutable.Map[AliasSpec.this.Count, scala.Predef.String] = null
    var _d: scala.collection.immutable.Map[scala.Predef.String, AliasSpec.this.Count] = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₅`.expectFirstObjectField(__co_blocke_scalajack_json_misc_AliasHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.AliasHolder[AliasSpec.this.Count]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = `in₅`.expectInt()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₅`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Int] = `in₅`.expectArray[scala.Int]((() => `in₅`.expectInt()))

                (if (parsedArray.!=(null)) parsedArray.toList else null: scala.collection.immutable.List[scala.Int])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₅`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _c = if (`in₅`.expectNull()) null else {
                `in₅`.expectToken('{')
                `in₅`.parseMap[scala.Int, java.lang.String]((() => scala.Predef.augmentString(`in₅`.expectString()).toInt), (() => `in₅`.expectString()), scala.Predef.Map.empty[scala.Int, java.lang.String], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c"), `in₅`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _d = if (`in₅`.expectNull()) null else {
                `in₅`.expectToken('{')
                `in₅`.parseMap[java.lang.String, scala.Int]((() => `in₅`.expectString()), (() => `in₅`.expectInt()), scala.Predef.Map.empty[java.lang.String, scala.Int], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d"), `in₅`)
          case _ =>
            `in₅`.skipValue()
        }
        maybeFieldNum = `in₅`.expectObjectField(__co_blocke_scalajack_json_misc_AliasHolder_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.misc.AliasHolder[AliasSpec.this.Count][scala.Int](_a, _b, _c, _d) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b", "c", "d")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₅`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.AliasHolder[AliasSpec.this.Count]] {
    def encodeValue(`in₆`: co.blocke.scalajack.json.misc.AliasHolder[AliasSpec.this.Count], `out₅`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₆`, `out₅`)
    def decodeValue(`in₇`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.AliasHolder[AliasSpec.this.Count] = r0(`in₇`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.AliasHolder[AliasSpec.this.Count]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_AliasHolder2_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b", "c")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.List[AliasSpec.this.CountX], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    in.foreach[scala.Unit](((i: scala.Option[scala.Int]) => i match {
      case null =>
        out.burpNull()
      case scala.None =>
        ()
      case scala.Some(v) =>
        val vv: scala.Int = v.asInstanceOf[scala.Int]
        out.value(vv)
    }))
    out.endArray()
  }
  def w2(`in₂`: scala.collection.immutable.Map[scala.Predef.String, AliasSpec.this.CountX], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `in₂`.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, scala.Option[scala.Int]]) => x$1 match {
      case scala.Tuple2(key, value) =>
        value match {
          case scala.None =>
            ()
          case scala.Some(v) =>
            {
              `out₂`.maybeComma()
              `out₂`.valueEscaped(key)
              `out₂`.colon()
              `out₂`.value(`v₂`)
            }
        }
    }))
    `out₂`.endObject()
  }
  def w0(`in₃`: co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountX], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `in₃`.a match {
      case scala.None =>
        ()
      case scala.Some(v) =>
        {
          `out₃`.label("a")
          `out₃`.value(`v₃`)
        }
    }
    `out₃`.label("b")
    w1(`in₃`.b, `out₃`)
    `out₃`.label("c")
    w2(`in₃`.c, `out₃`)
    `out₃`.endObject()
  }
  def r0(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountX] = {
    var _a: scala.Option[scala.Int] = scala.None
    var _b: scala.collection.immutable.List[AliasSpec.this.CountX] = null
    var _c: scala.collection.immutable.Map[scala.Predef.String, AliasSpec.this.CountX] = null
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_misc_AliasHolder2_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountX]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₄`.expectNull()) null else scala.Some.apply[scala.Int](`in₄`.expectInt())
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₄`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Option[scala.Int]] = `in₄`.expectArray[scala.Option[scala.Int]]((() => if (`in₄`.expectNull()) null else scala.Some.apply[scala.Int](`in₄`.expectInt())))

                (if (parsedArray.!=(null)) parsedArray.toList else null: scala.collection.immutable.List[scala.Option[scala.Int]])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₄`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _c = if (`in₄`.expectNull()) null else {
                `in₄`.expectToken('{')
                `in₄`.parseMap[java.lang.String, scala.Option[scala.Int]]((() => `in₄`.expectString()), (() => if (`in₄`.expectNull()) null else scala.Some.apply[scala.Int](`in₄`.expectInt())), scala.Predef.Map.empty[java.lang.String, scala.Option[scala.Int]], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_misc_AliasHolder2_fields)
      }
      if (required.&(6).==(0)) new co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountX][scala.Option[scala.Int]](_a, _b, _c) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b", "c")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(6)))), `in₄`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountX]] {
    def encodeValue(`in₅`: co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountX], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₅`, `out₄`)
    def decodeValue(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountX] = r0(`in₆`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountX]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_AliasHolder2_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b", "c")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.List[AliasSpec.this.CountX], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    in.foreach[scala.Unit](((i: scala.Option[scala.Int]) => i match {
      case null =>
        out.burpNull()
      case scala.None =>
        out.burpNull()
      case scala.Some(v) =>
        val vv: scala.Int = v.asInstanceOf[scala.Int]
        out.value(vv)
    }))
    out.endArray()
  }
  def w2(`in₂`: scala.collection.immutable.Map[scala.Predef.String, AliasSpec.this.CountX], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `in₂`.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, scala.Option[scala.Int]]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          `out₂`.maybeComma()
          `out₂`.valueEscaped(key)
          `out₂`.colon()
          value match {
            case null =>
              `out₂`.burpNull()
            case scala.None =>
              `out₂`.burpNull()
            case scala.Some(v) =>
              val `vv₂`: scala.Int = `v₂`.asInstanceOf[scala.Int]
              `out₂`.value(`vv₂`)
          }
        }
    }))
    `out₂`.endObject()
  }
  def w0(`in₃`: co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountX], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `out₃`.label("a")
    `in₃`.a match {
      case null =>
        `out₃`.burpNull()
      case scala.None =>
        `out₃`.burpNull()
      case scala.Some(v) =>
        val `vv₃`: scala.Int = `v₃`.asInstanceOf[scala.Int]
        `out₃`.value(`vv₃`)
    }
    `out₃`.label("b")
    w1(`in₃`.b, `out₃`)
    `out₃`.label("c")
    w2(`in₃`.c, `out₃`)
    `out₃`.endObject()
  }
  def r0(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountX] = {
    var _a: scala.Option[scala.Int] = scala.None
    var _b: scala.collection.immutable.List[AliasSpec.this.CountX] = null
    var _c: scala.collection.immutable.Map[scala.Predef.String, AliasSpec.this.CountX] = null
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_misc_AliasHolder2_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountX]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₄`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₄`.expectInt())
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₄`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Option[scala.Int]] = `in₄`.expectArray[scala.Option[scala.Int]]((() => if (`in₄`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₄`.expectInt())))

                (if (parsedArray.!=(null)) parsedArray.toList else null: scala.collection.immutable.List[scala.Option[scala.Int]])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₄`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _c = if (`in₄`.expectNull()) null else {
                `in₄`.expectToken('{')
                `in₄`.parseMap[java.lang.String, scala.Option[scala.Int]]((() => `in₄`.expectString()), (() => if (`in₄`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₄`.expectInt())), scala.Predef.Map.empty[java.lang.String, scala.Option[scala.Int]], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_misc_AliasHolder2_fields)
      }
      if (required.&(6).==(0)) new co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountX][scala.Option[scala.Int]](_a, _b, _c) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b", "c")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(6)))), `in₄`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountX]] {
    def encodeValue(`in₅`: co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountX], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₅`, `out₄`)
    def decodeValue(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountX] = r0(`in₆`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountX]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_AliasHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b", "c", "d")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.List[AliasSpec.this.CountY], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    in.foreach[scala.Unit](((i: java.lang.String) => out.valueEscaped(i)))
    out.endArray()
  }
  def w2(`in₂`: scala.collection.immutable.Map[AliasSpec.this.CountY, scala.Predef.String], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `in₂`.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, java.lang.String]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          `out₂`.maybeComma()
          `out₂`.valueEscaped(key)
          `out₂`.colon()
          `out₂`.valueEscaped(value)
        }
    }))
    `out₂`.endObject()
  }
  def w0(`in₃`: co.blocke.scalajack.json.misc.AliasHolder[AliasSpec.this.CountY], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `out₃`.label("a")
    `out₃`.valueEscaped(`in₃`.a)
    `out₃`.label("b")
    w1(`in₃`.b, `out₃`)
    `out₃`.label("c")
    w2(`in₃`.c, `out₃`)
    `out₃`.label("d")
    w2(`in₃`.d, `out₃`)
    `out₃`.endObject()
  }
  def r0(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.AliasHolder[AliasSpec.this.CountY] = {
    var _a: java.lang.String = ""
    var _b: scala.collection.immutable.List[AliasSpec.this.CountY] = null
    var _c: scala.collection.immutable.Map[AliasSpec.this.CountY, scala.Predef.String] = null
    var _d: scala.collection.immutable.Map[scala.Predef.String, AliasSpec.this.CountY] = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_misc_AliasHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.AliasHolder[AliasSpec.this.CountY]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = `in₄`.expectString()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₄`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b = {
                val parsedArray: scala.collection.mutable.ListBuffer[java.lang.String] = `in₄`.expectArray[java.lang.String]((() => `in₄`.expectString()))

                (if (parsedArray.!=(null)) parsedArray.toList else null: scala.collection.immutable.List[java.lang.String])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₄`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _c = if (`in₄`.expectNull()) null else {
                `in₄`.expectToken('{')
                `in₄`.parseMap[java.lang.String, java.lang.String]((() => `in₄`.expectString()), (() => `in₄`.expectString()), scala.Predef.Map.empty[java.lang.String, java.lang.String], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c"), `in₄`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _d = if (`in₄`.expectNull()) null else {
                `in₄`.expectToken('{')
                `in₄`.parseMap[java.lang.String, java.lang.String]((() => `in₄`.expectString()), (() => `in₄`.expectString()), scala.Predef.Map.empty[java.lang.String, java.lang.String], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_misc_AliasHolder_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.misc.AliasHolder[AliasSpec.this.CountY][java.lang.String](_a, _b, _c, _d) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b", "c", "d")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₄`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.AliasHolder[AliasSpec.this.CountY]] {
    def encodeValue(`in₅`: co.blocke.scalajack.json.misc.AliasHolder[AliasSpec.this.CountY], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₅`, `out₄`)
    def decodeValue(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.AliasHolder[AliasSpec.this.CountY] = r0(`in₆`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.AliasHolder[AliasSpec.this.CountY]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_AliasHolder2_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b", "c")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.List[AliasSpec.this.CountZ], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    in.foreach[scala.Unit](((i: scala.Option[scala.Predef.String]) => i match {
      case null =>
        out.burpNull()
      case scala.None =>
        ()
      case scala.Some(v) =>
        val vv: java.lang.String = v.asInstanceOf[java.lang.String]
        out.valueEscaped(vv)
    }))
    out.endArray()
  }
  def w2(`in₂`: scala.collection.immutable.Map[scala.Predef.String, AliasSpec.this.CountZ], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startObject()
    `in₂`.foreach[scala.Unit](((x$1: scala.Tuple2[java.lang.String, scala.Option[scala.Predef.String]]) => x$1 match {
      case scala.Tuple2(key, value) =>
        value match {
          case scala.None =>
            ()
          case scala.Some(v) =>
            {
              `out₂`.maybeComma()
              `out₂`.valueEscaped(key)
              `out₂`.colon()
              `out₂`.valueEscaped(`v₂`)
            }
        }
    }))
    `out₂`.endObject()
  }
  def w0(`in₃`: co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountZ], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `in₃`.a match {
      case scala.None =>
        ()
      case scala.Some(v) =>
        {
          `out₃`.label("a")
          `out₃`.valueEscaped(`v₃`)
        }
    }
    `out₃`.label("b")
    w1(`in₃`.b, `out₃`)
    `out₃`.label("c")
    w2(`in₃`.c, `out₃`)
    `out₃`.endObject()
  }
  def r0(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountZ] = {
    var _a: scala.Option[scala.Predef.String] = scala.None
    var _b: scala.collection.immutable.List[AliasSpec.this.CountZ] = null
    var _c: scala.collection.immutable.Map[scala.Predef.String, AliasSpec.this.CountZ] = null
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_misc_AliasHolder2_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountZ]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₄`.expectNull()) null else scala.Some.apply[java.lang.String](`in₄`.expectString())
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₄`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Option[scala.Predef.String]] = `in₄`.expectArray[scala.Option[scala.Predef.String]]((() => if (`in₄`.expectNull()) null else scala.Some.apply[java.lang.String](`in₄`.expectString())))

                (if (parsedArray.!=(null)) parsedArray.toList else null: scala.collection.immutable.List[scala.Option[scala.Predef.String]])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₄`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _c = if (`in₄`.expectNull()) null else {
                `in₄`.expectToken('{')
                `in₄`.parseMap[java.lang.String, scala.Option[scala.Predef.String]]((() => `in₄`.expectString()), (() => if (`in₄`.expectNull()) null else scala.Some.apply[java.lang.String](`in₄`.expectString())), scala.Predef.Map.empty[java.lang.String, scala.Option[scala.Predef.String]], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_misc_AliasHolder2_fields)
      }
      if (required.&(6).==(0)) new co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountZ][scala.Option[scala.Predef.String]](_a, _b, _c) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b", "c")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(6)))), `in₄`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountZ]] {
    def encodeValue(`in₅`: co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountZ], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₅`, `out₄`)
    def decodeValue(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountZ] = r0(`in₆`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.AliasHolder2[AliasSpec.this.CountZ]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_ComplexEither_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.ComplexEither[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.a match {
      case scala.None =>
        ()
      case scala.Some(v) =>
        {
          if (v.==(null)) out.burpNull() else ()
          v match {
            case scala.Left(v) =>
              {
                out.label("a")
                out.valueEscaped(`v₂`.asInstanceOf[java.lang.String])
              }
            case scala.Right(v) =>
              `v₃`.asInstanceOf[scala.Option[scala.Int]] match {
                case scala.None =>
                  ()
                case scala.Some(v) =>
                  {
                    out.label("a")
                    out.value(`v₄`)
                  }
              }
          }
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.ComplexEither[scala.Int] = {
    var _a: scala.Option[scala.util.Either[scala.Predef.String, scala.Option[scala.Int]]] = scala.None
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_ComplexEither_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₂`.expectNull()) null else scala.Some.apply[scala.util.Either[scala.Predef.String, scala.Option[scala.Int]]]({
                val mark: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[scala.Option[scala.Int]](if (`in₂`.expectNull()) null else scala.Some.apply[scala.Int](`in₂`.expectInt())) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Option[scala.Int]](rval)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(mark)
                    scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[java.lang.String, scala.Nothing](lval)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              })
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_ComplexEither_fields)
      }
      if (required.&(0).==(0)) new co.blocke.scalajack.json.misc.ComplexEither[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(0)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.ComplexEither[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.ComplexEither[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_ComplexEither_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.ComplexEither[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.a match {
      case scala.None =>
        ()
      case scala.Some(v) =>
        {
          if (v.==(null)) out.burpNull() else ()
          v match {
            case scala.Left(v) =>
              {
                out.label("a")
                out.valueEscaped(`v₂`.asInstanceOf[java.lang.String])
              }
            case scala.Right(v) =>
              `v₃`.asInstanceOf[scala.Option[scala.Int]] match {
                case scala.None =>
                  ()
                case scala.Some(v) =>
                  {
                    out.label("a")
                    out.value(`v₄`)
                  }
              }
          }
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.ComplexEither[scala.Int] = {
    var _a: scala.Option[scala.util.Either[scala.Predef.String, scala.Option[scala.Int]]] = scala.None
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_ComplexEither_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₂`.expectNull()) null else scala.Some.apply[scala.util.Either[scala.Predef.String, scala.Option[scala.Int]]]({
                val mark: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[scala.Option[scala.Int]](if (`in₂`.expectNull()) null else scala.Some.apply[scala.Int](`in₂`.expectInt())) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Option[scala.Int]](rval)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(mark)
                    scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[java.lang.String, scala.Nothing](lval)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              })
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_ComplexEither_fields)
      }
      if (required.&(0).==(0)) new co.blocke.scalajack.json.misc.ComplexEither[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(0)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.ComplexEither[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.ComplexEither[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_ComplexEither_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.ComplexEither[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("a")
    in.a match {
      case null =>
        out.burpNull()
      case scala.None =>
        out.burpNull()
      case scala.Some(v) =>
        val vv: scala.util.Either[scala.Predef.String, scala.Option[scala.Int]] = v.asInstanceOf[scala.util.Either[scala.Predef.String, scala.Option[scala.Int]]]
        if (vv.==(null)) out.burpNull() else vv match {
          case scala.Left(v) =>
            out.valueEscaped(`v₂`.asInstanceOf[java.lang.String])
          case scala.Right(v) =>
            `v₃`.asInstanceOf[scala.Option[scala.Int]] match {
              case null =>
                out.burpNull()
              case scala.None =>
                out.burpNull()
              case scala.Some(v) =>
                val `vv₂`: scala.Int = `v₄`.asInstanceOf[scala.Int]
                out.value(`vv₂`)
            }
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.ComplexEither[scala.Int] = {
    var _a: scala.Option[scala.util.Either[scala.Predef.String, scala.Option[scala.Int]]] = scala.None
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_ComplexEither_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₂`.expectNull()) scala.None else scala.Some.apply[scala.util.Either[scala.Predef.String, scala.Option[scala.Int]]]({
                val mark: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[scala.Option[scala.Int]](if (`in₂`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₂`.expectInt())) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Option[scala.Int]](rval)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(mark)
                    scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[java.lang.String, scala.Nothing](lval)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              })
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_ComplexEither_fields)
      }
      if (required.&(0).==(0)) new co.blocke.scalajack.json.misc.ComplexEither[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(0)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.ComplexEither[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.ComplexEither[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_ComplexEither_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.ComplexEither[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.a match {
      case scala.None =>
        ()
      case scala.Some(v) =>
        {
          if (v.==(null)) out.burpNull() else ()
          v match {
            case scala.Left(v) =>
              {
                out.label("a")
                out.valueEscaped(`v₂`.asInstanceOf[java.lang.String])
              }
            case scala.Right(v) =>
              `v₃`.asInstanceOf[scala.Option[scala.Int]] match {
                case scala.None =>
                  ()
                case scala.Some(v) =>
                  {
                    out.label("a")
                    out.value(`v₄`)
                  }
              }
          }
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.ComplexEither[scala.Int] = {
    var _a: scala.Option[scala.util.Either[scala.Predef.String, scala.Option[scala.Int]]] = scala.None
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_ComplexEither_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₂`.expectNull()) null else scala.Some.apply[scala.util.Either[scala.Predef.String, scala.Option[scala.Int]]]({
                val mark: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[scala.Option[scala.Int]](if (`in₂`.expectNull()) null else scala.Some.apply[scala.Int](`in₂`.expectInt())) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Option[scala.Int]](rval)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(mark)
                    scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[java.lang.String, scala.Nothing](lval)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              })
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_ComplexEither_fields)
      }
      if (required.&(0).==(0)) new co.blocke.scalajack.json.misc.ComplexEither[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(0)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.ComplexEither[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.ComplexEither[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_ComplexEither_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.ComplexEither[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.a match {
      case scala.None =>
        ()
      case scala.Some(v) =>
        {
          if (v.==(null)) out.burpNull() else ()
          v match {
            case scala.Left(v) =>
              {
                out.label("a")
                out.valueEscaped(`v₂`.asInstanceOf[java.lang.String])
              }
            case scala.Right(v) =>
              `v₃`.asInstanceOf[scala.Option[scala.Int]] match {
                case scala.None =>
                  ()
                case scala.Some(v) =>
                  {
                    out.label("a")
                    out.value(`v₄`)
                  }
              }
          }
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.ComplexEither[scala.Int] = {
    var _a: scala.Option[scala.util.Either[scala.Predef.String, scala.Option[scala.Int]]] = scala.None
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_ComplexEither_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₂`.expectNull()) null else scala.Some.apply[scala.util.Either[scala.Predef.String, scala.Option[scala.Int]]]({
                val mark: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[scala.Option[scala.Int]](if (`in₂`.expectNull()) null else scala.Some.apply[scala.Int](`in₂`.expectInt())) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Option[scala.Int]](rval)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(mark)
                    scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[java.lang.String, scala.Nothing](lval)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              })
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_ComplexEither_fields)
      }
      if (required.&(0).==(0)) new co.blocke.scalajack.json.misc.ComplexEither[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(0)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.ComplexEither[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.ComplexEither[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_ComplexEither_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.ComplexEither[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.a match {
      case scala.None =>
        ()
      case scala.Some(v) =>
        {
          if (v.==(null)) out.burpNull() else ()
          v match {
            case scala.Left(_) =>
              out.label("a")
              out.burpNull()
            case scala.Right(v) =>
              `v₂`.asInstanceOf[scala.Option[scala.Int]] match {
                case scala.None =>
                  ()
                case scala.Some(v) =>
                  {
                    out.label("a")
                    out.value(`v₃`)
                  }
              }
          }
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.ComplexEither[scala.Int] = {
    var _a: scala.Option[scala.util.Either[scala.Predef.String, scala.Option[scala.Int]]] = scala.None
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_ComplexEither_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₂`.expectNull()) null else scala.Some.apply[scala.util.Either[scala.Predef.String, scala.Option[scala.Int]]]({
                val mark: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[scala.Option[scala.Int]](if (`in₂`.expectNull()) null else scala.Some.apply[scala.Int](`in₂`.expectInt())) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Option[scala.Int]](rval)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(mark)
                    scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[java.lang.String, scala.Nothing](lval)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              })
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_ComplexEither_fields)
      }
      if (required.&(0).==(0)) new co.blocke.scalajack.json.misc.ComplexEither[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(0)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.ComplexEither[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.ComplexEither[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_ComplexEither_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.ComplexEither[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("a")
    in.a match {
      case null =>
        out.burpNull()
      case scala.None =>
        out.burpNull()
      case scala.Some(v) =>
        val vv: scala.util.Either[scala.Predef.String, scala.Option[scala.Int]] = v.asInstanceOf[scala.util.Either[scala.Predef.String, scala.Option[scala.Int]]]
        if (vv.==(null)) out.burpNull() else vv match {
          case scala.Left(v) =>
            out.burpNull()
          case scala.Right(v) =>
            `v₂`.asInstanceOf[scala.Option[scala.Int]] match {
              case null =>
                out.burpNull()
              case scala.None =>
                out.burpNull()
              case scala.Some(v) =>
                val `vv₂`: scala.Int = `v₃`.asInstanceOf[scala.Int]
                out.value(`vv₂`)
            }
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.ComplexEither[scala.Int] = {
    var _a: scala.Option[scala.util.Either[scala.Predef.String, scala.Option[scala.Int]]] = scala.None
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_ComplexEither_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = if (`in₂`.expectNull()) scala.None else scala.Some.apply[scala.util.Either[scala.Predef.String, scala.Option[scala.Int]]]({
                val mark: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[scala.Option[scala.Int]](if (`in₂`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₂`.expectInt())) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Option[scala.Int]](rval)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(mark)
                    scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[java.lang.String, scala.Nothing](lval)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              })
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_ComplexEither_fields)
      }
      if (required.&(0).==(0)) new co.blocke.scalajack.json.misc.ComplexEither[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(0)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.ComplexEither[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.ComplexEither[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.ComplexEither[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_EitherHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.EitherHolder[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    if (in.a.==(null)) out.burpNull() else ()
    in.a match {
      case scala.Left(v) =>
        {
          out.label("a")
          out.value(v.asInstanceOf[scala.Int])
        }
      case scala.Right(v) =>
        {
          out.label("a")
          out.valueEscaped(`v₂`.asInstanceOf[java.lang.String])
        }
    }
    if (in.b.==(null)) out.burpNull() else ()
    in.b match {
      case scala.Left(v) =>
        {
          out.label("b")
          out.valueEscaped(`v₃`.asInstanceOf[java.lang.String])
        }
      case scala.Right(v) =>
        {
          out.label("b")
          out.value(`v₄`.asInstanceOf[scala.Int])
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherHolder[scala.Int] = {
    var _a: scala.util.Either[scala.Int, scala.Predef.String] = null
    var _b: scala.util.Either[scala.Predef.String, scala.Int] = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_EitherHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.EitherHolder[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val mark: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, java.lang.String](rval)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(mark)
                    scala.util.Try.apply[scala.Int](`in₂`.expectInt()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[scala.Int, scala.Nothing](lval)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b = {
                val `mark₂`: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[scala.Int](`in₂`.expectInt()) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Int](`rval₂`)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(`mark₂`)
                    scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[java.lang.String, scala.Nothing](`lval₂`)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_EitherHolder_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.misc.EitherHolder[scala.Int][scala.Int](_a, _b) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherHolder[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.EitherHolder[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherHolder[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherHolder[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_EitherHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.EitherHolder[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    if (in.a.==(null)) out.burpNull() else ()
    in.a match {
      case scala.Left(_) =>
        out.label("a")
        out.burpNull()
      case scala.Right(v) =>
        {
          out.label("a")
          out.valueEscaped(v.asInstanceOf[java.lang.String])
        }
    }
    if (in.b.==(null)) out.burpNull() else ()
    in.b match {
      case scala.Left(_) =>
        out.label("b")
        out.burpNull()
      case scala.Right(v) =>
        {
          out.label("b")
          out.value(`v₂`.asInstanceOf[scala.Int])
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherHolder[scala.Int] = {
    var _a: scala.util.Either[scala.Int, scala.Predef.String] = null
    var _b: scala.util.Either[scala.Predef.String, scala.Int] = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_EitherHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.EitherHolder[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val mark: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, java.lang.String](rval)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(mark)
                    scala.util.Try.apply[scala.Int](`in₂`.expectInt()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[scala.Int, scala.Nothing](lval)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b = {
                val `mark₂`: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[scala.Int](`in₂`.expectInt()) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Int](`rval₂`)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(`mark₂`)
                    scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[java.lang.String, scala.Nothing](`lval₂`)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_EitherHolder_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.misc.EitherHolder[scala.Int][scala.Int](_a, _b) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherHolder[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.EitherHolder[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherHolder[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherHolder[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_EitherHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.EitherHolder[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    if (in.a.==(null)) out.burpNull() else ()
    in.a match {
      case scala.Left(err) =>
        out.label("a")
        out.value("Left Error: ".+(err.toString()))
      case scala.Right(v) =>
        {
          out.label("a")
          out.valueEscaped(v.asInstanceOf[java.lang.String])
        }
    }
    if (in.b.==(null)) out.burpNull() else ()
    in.b match {
      case scala.Left(err) =>
        out.label("b")
        out.value("Left Error: ".+(`err₂`.toString()))
      case scala.Right(v) =>
        {
          out.label("b")
          out.value(`v₂`.asInstanceOf[scala.Int])
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherHolder[scala.Int] = {
    var _a: scala.util.Either[scala.Int, scala.Predef.String] = null
    var _b: scala.util.Either[scala.Predef.String, scala.Int] = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_EitherHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.EitherHolder[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val mark: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, java.lang.String](rval)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(mark)
                    scala.util.Try.apply[scala.Int](`in₂`.expectInt()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[scala.Int, scala.Nothing](lval)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b = {
                val `mark₂`: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[scala.Int](`in₂`.expectInt()) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Int](`rval₂`)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(`mark₂`)
                    scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[java.lang.String, scala.Nothing](`lval₂`)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_EitherHolder_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.misc.EitherHolder[scala.Int][scala.Int](_a, _b) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherHolder[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.EitherHolder[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherHolder[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherHolder[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_EitherHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.EitherHolder[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    if (in.a.==(null)) out.burpNull() else ()
    in.a match {
      case scala.Left(err) =>
        throw new co.blocke.scalajack.json.JsonEitherLeftError("Left Error: ".+(err.toString()))
      case scala.Right(v) =>
        {
          out.label("a")
          out.valueEscaped(v.asInstanceOf[java.lang.String])
        }
    }
    if (in.b.==(null)) out.burpNull() else ()
    in.b match {
      case scala.Left(err) =>
        throw new co.blocke.scalajack.json.JsonEitherLeftError("Left Error: ".+(`err₂`.toString()))
      case scala.Right(v) =>
        {
          out.label("b")
          out.value(`v₂`.asInstanceOf[scala.Int])
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherHolder[scala.Int] = {
    var _a: scala.util.Either[scala.Int, scala.Predef.String] = null
    var _b: scala.util.Either[scala.Predef.String, scala.Int] = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_EitherHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.EitherHolder[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val mark: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, java.lang.String](rval)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(mark)
                    scala.util.Try.apply[scala.Int](`in₂`.expectInt()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[scala.Int, scala.Nothing](lval)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b = {
                val `mark₂`: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[scala.Int](`in₂`.expectInt()) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Int](`rval₂`)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(`mark₂`)
                    scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[java.lang.String, scala.Nothing](`lval₂`)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_EitherHolder_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.misc.EitherHolder[scala.Int][scala.Int](_a, _b) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherHolder[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.EitherHolder[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherHolder[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherHolder[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_LRUnionHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.Seq[scala.Option[scala.Int] | scala.Predef.String], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    in.foreach[scala.Unit](((i: scala.Option[scala.Int] | java.lang.String) => {
      out.mark()
      scala.util.Try.apply[scala.Unit](out.valueEscaped(i.asInstanceOf[java.lang.String])) match {
        case scala.util.Success(_) =>
          ()
        case scala.util.Failure(_) =>
          out.revert()
          i.asInstanceOf[scala.Option[scala.Int]] match {
            case null =>
              out.burpNull()
            case scala.None =>
              ()
            case scala.Some(v) =>
              val vv: scala.Int = v.asInstanceOf[scala.Int]
              out.value(vv)
          }
      }
    }))
    out.endArray()
  }
  def w2(`in₂`: scala.Tuple2[scala.Option[scala.Int] | scala.Predef.String, scala.Option[scala.Int] | scala.Predef.String], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startArray()
    `out₂`.mark()
    scala.util.Try.apply[scala.Unit](`out₂`.valueEscaped(`in₂`._1.asInstanceOf[java.lang.String])) match {
      case scala.util.Success(_) =>
        ()
      case scala.util.Failure(_) =>
        `out₂`.revert()
        `in₂`._1.asInstanceOf[scala.Option[scala.Int]] match {
          case null =>
            `out₂`.burpNull()
          case scala.None =>
            `out₂`.burpNull()
          case scala.Some(v) =>
            val `vv₂`: scala.Int = `v₂`.asInstanceOf[scala.Int]
            `out₂`.value(`vv₂`)
        }
    }
    `out₂`.mark()
    scala.util.Try.apply[scala.Unit](`out₂`.valueEscaped(`in₂`._2.asInstanceOf[java.lang.String])) match {
      case scala.util.Success(_) =>
        ()
      case scala.util.Failure(_) =>
        `out₂`.revert()
        `in₂`._2.asInstanceOf[scala.Option[scala.Int]] match {
          case null =>
            `out₂`.burpNull()
          case scala.None =>
            `out₂`.burpNull()
          case scala.Some(v) =>
            val `vv₃`: scala.Int = `v₃`.asInstanceOf[scala.Int]
            `out₂`.value(`vv₃`)
        }
    }
    `out₂`.endArray()
  }
  def w0(`in₃`: co.blocke.scalajack.json.misc.LRUnionHolder[scala.Option[scala.Int], scala.Predef.String], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `out₃`.label("a")
    w1(`in₃`.a, `out₃`)
    `out₃`.label("b")
    w2(`in₃`.b, `out₃`)
    `out₃`.endObject()
  }
  def r0(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.LRUnionHolder[scala.Option[scala.Int], scala.Predef.String] = {
    var _a: scala.collection.immutable.Seq[scala.Option[scala.Int] | scala.Predef.String] = null
    var _b: scala.Tuple2[scala.Option[scala.Int] | scala.Predef.String, scala.Option[scala.Int] | scala.Predef.String] = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_misc_LRUnionHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.LRUnionHolder[scala.Option[scala.Int], scala.Predef.String]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Option[scala.Int] | java.lang.String] = `in₄`.expectArray[scala.Option[scala.Int] | java.lang.String]((() => {
                  val mark: scala.Int = `in₄`.pos
                  scala.util.Try.apply[scala.Option[scala.Int]](if (`in₄`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₄`.expectInt())) match {
                    case scala.util.Success(lval) =>
                      (lval: scala.Option[scala.Int])
                    case scala.util.Failure(f) =>
                      `in₄`.revertToPos(mark)
                      scala.util.Try.apply[java.lang.String](`in₄`.expectString()) match {
                        case scala.util.Success(rval) =>
                          (rval: java.lang.String)
                        case scala.util.Failure(_) =>
                          `in₄`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₄`)
                      }
                  }
                }))

                (if (parsedArray.!=(null)) parsedArray.toSeq else null: scala.collection.immutable.Seq[scala.Option[scala.Int] | java.lang.String])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₄`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b = if (`in₄`.expectNull()) null else {
                `in₄`.expectToken('[')
                val tv: scala.Tuple2[scala.Option[scala.Int] | scala.Predef.String, scala.Option[scala.Int] | scala.Predef.String] = new scala.Tuple2[scala.Option[scala.Int] | scala.Predef.String, scala.Option[scala.Int] | scala.Predef.String][scala.Option[scala.Int] | scala.Predef.String, scala.Option[scala.Int] | scala.Predef.String]({
                  val `mark₂`: scala.Int = `in₄`.pos
                  scala.util.Try.apply[scala.Option[scala.Int]](if (`in₄`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₄`.expectInt())) match {
                    case scala.util.Success(lval) =>
                      (`lval₂`: scala.Option[scala.Int])
                    case scala.util.Failure(f) =>
                      `in₄`.revertToPos(`mark₂`)
                      scala.util.Try.apply[java.lang.String](`in₄`.expectString()) match {
                        case scala.util.Success(rval) =>
                          (`rval₂`: java.lang.String)
                        case scala.util.Failure(_) =>
                          `in₄`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₄`)
                      }
                  }
                }, {
                  `in₄`.expectToken(',')
                  val `mark₃`: scala.Int = `in₄`.pos
                  scala.util.Try.apply[scala.Option[scala.Int]](if (`in₄`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₄`.expectInt())) match {
                    case scala.util.Success(lval) =>
                      (`lval₃`: scala.Option[scala.Int])
                    case scala.util.Failure(f) =>
                      `in₄`.revertToPos(`mark₃`)
                      scala.util.Try.apply[java.lang.String](`in₄`.expectString()) match {
                        case scala.util.Success(rval) =>
                          (`rval₃`: java.lang.String)
                        case scala.util.Failure(_) =>
                          `in₄`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₄`)
                      }
                  }
                })
                `in₄`.expectToken(']')

                (tv: scala.Tuple2[scala.Option[scala.Int] | scala.Predef.String, scala.Option[scala.Int] | scala.Predef.String])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_misc_LRUnionHolder_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.misc.LRUnionHolder[scala.Option[scala.Int], scala.Predef.String][scala.Option[scala.Int], java.lang.String](_a, _b) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₄`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.LRUnionHolder[scala.Option[scala.Int], scala.Predef.String]] {
    def encodeValue(`in₅`: co.blocke.scalajack.json.misc.LRUnionHolder[scala.Option[scala.Int], scala.Predef.String], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₅`, `out₄`)
    def decodeValue(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.LRUnionHolder[scala.Option[scala.Int], scala.Predef.String] = r0(`in₆`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.LRUnionHolder[scala.Option[scala.Int], scala.Predef.String]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_LRUnionHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.Seq[scala.Option[scala.Int] | scala.Predef.String], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    in.foreach[scala.Unit](((i: scala.Option[scala.Int] | java.lang.String) => {
      out.mark()
      scala.util.Try.apply[scala.Unit](out.valueEscaped(i.asInstanceOf[java.lang.String])) match {
        case scala.util.Success(_) =>
          ()
        case scala.util.Failure(_) =>
          out.revert()
          i.asInstanceOf[scala.Option[scala.Int]] match {
            case null =>
              out.burpNull()
            case scala.None =>
              ()
            case scala.Some(v) =>
              val vv: scala.Int = v.asInstanceOf[scala.Int]
              out.value(vv)
          }
      }
    }))
    out.endArray()
  }
  def w2(`in₂`: scala.Tuple2[scala.Option[scala.Int] | scala.Predef.String, scala.Option[scala.Int] | scala.Predef.String], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startArray()
    `out₂`.mark()
    scala.util.Try.apply[scala.Unit](`out₂`.valueEscaped(`in₂`._1.asInstanceOf[java.lang.String])) match {
      case scala.util.Success(_) =>
        ()
      case scala.util.Failure(_) =>
        `out₂`.revert()
        `in₂`._1.asInstanceOf[scala.Option[scala.Int]] match {
          case null =>
            `out₂`.burpNull()
          case scala.None =>
            `out₂`.burpNull()
          case scala.Some(v) =>
            val `vv₂`: scala.Int = `v₂`.asInstanceOf[scala.Int]
            `out₂`.value(`vv₂`)
        }
    }
    `out₂`.mark()
    scala.util.Try.apply[scala.Unit](`out₂`.valueEscaped(`in₂`._2.asInstanceOf[java.lang.String])) match {
      case scala.util.Success(_) =>
        ()
      case scala.util.Failure(_) =>
        `out₂`.revert()
        `in₂`._2.asInstanceOf[scala.Option[scala.Int]] match {
          case null =>
            `out₂`.burpNull()
          case scala.None =>
            `out₂`.burpNull()
          case scala.Some(v) =>
            val `vv₃`: scala.Int = `v₃`.asInstanceOf[scala.Int]
            `out₂`.value(`vv₃`)
        }
    }
    `out₂`.endArray()
  }
  def w0(`in₃`: co.blocke.scalajack.json.misc.LRUnionHolder[scala.Option[scala.Int], scala.Predef.String], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `out₃`.label("a")
    w1(`in₃`.a, `out₃`)
    `out₃`.label("b")
    w2(`in₃`.b, `out₃`)
    `out₃`.endObject()
  }
  def r0(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.LRUnionHolder[scala.Option[scala.Int], scala.Predef.String] = {
    var _a: scala.collection.immutable.Seq[scala.Option[scala.Int] | scala.Predef.String] = null
    var _b: scala.Tuple2[scala.Option[scala.Int] | scala.Predef.String, scala.Option[scala.Int] | scala.Predef.String] = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_misc_LRUnionHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.LRUnionHolder[scala.Option[scala.Int], scala.Predef.String]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Option[scala.Int] | java.lang.String] = `in₄`.expectArray[scala.Option[scala.Int] | java.lang.String]((() => {
                  val mark: scala.Int = `in₄`.pos
                  scala.util.Try.apply[scala.Option[scala.Int]](if (`in₄`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₄`.expectInt())) match {
                    case scala.util.Success(lval) =>
                      (lval: scala.Option[scala.Int])
                    case scala.util.Failure(f) =>
                      `in₄`.revertToPos(mark)
                      scala.util.Try.apply[java.lang.String](`in₄`.expectString()) match {
                        case scala.util.Success(rval) =>
                          (rval: java.lang.String)
                        case scala.util.Failure(_) =>
                          `in₄`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₄`)
                      }
                  }
                }))

                (if (parsedArray.!=(null)) parsedArray.toSeq else null: scala.collection.immutable.Seq[scala.Option[scala.Int] | java.lang.String])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₄`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b = if (`in₄`.expectNull()) null else {
                `in₄`.expectToken('[')
                val tv: scala.Tuple2[scala.Option[scala.Int] | scala.Predef.String, scala.Option[scala.Int] | scala.Predef.String] = new scala.Tuple2[scala.Option[scala.Int] | scala.Predef.String, scala.Option[scala.Int] | scala.Predef.String][scala.Option[scala.Int] | scala.Predef.String, scala.Option[scala.Int] | scala.Predef.String]({
                  val `mark₂`: scala.Int = `in₄`.pos
                  scala.util.Try.apply[scala.Option[scala.Int]](if (`in₄`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₄`.expectInt())) match {
                    case scala.util.Success(lval) =>
                      (`lval₂`: scala.Option[scala.Int])
                    case scala.util.Failure(f) =>
                      `in₄`.revertToPos(`mark₂`)
                      scala.util.Try.apply[java.lang.String](`in₄`.expectString()) match {
                        case scala.util.Success(rval) =>
                          (`rval₂`: java.lang.String)
                        case scala.util.Failure(_) =>
                          `in₄`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₄`)
                      }
                  }
                }, {
                  `in₄`.expectToken(',')
                  val `mark₃`: scala.Int = `in₄`.pos
                  scala.util.Try.apply[scala.Option[scala.Int]](if (`in₄`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₄`.expectInt())) match {
                    case scala.util.Success(lval) =>
                      (`lval₃`: scala.Option[scala.Int])
                    case scala.util.Failure(f) =>
                      `in₄`.revertToPos(`mark₃`)
                      scala.util.Try.apply[java.lang.String](`in₄`.expectString()) match {
                        case scala.util.Success(rval) =>
                          (`rval₃`: java.lang.String)
                        case scala.util.Failure(_) =>
                          `in₄`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₄`)
                      }
                  }
                })
                `in₄`.expectToken(']')

                (tv: scala.Tuple2[scala.Option[scala.Int] | scala.Predef.String, scala.Option[scala.Int] | scala.Predef.String])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_misc_LRUnionHolder_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.misc.LRUnionHolder[scala.Option[scala.Int], scala.Predef.String][scala.Option[scala.Int], java.lang.String](_a, _b) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₄`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.LRUnionHolder[scala.Option[scala.Int], scala.Predef.String]] {
    def encodeValue(`in₅`: co.blocke.scalajack.json.misc.LRUnionHolder[scala.Option[scala.Int], scala.Predef.String], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₅`, `out₄`)
    def decodeValue(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.LRUnionHolder[scala.Option[scala.Int], scala.Predef.String] = r0(`in₆`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.LRUnionHolder[scala.Option[scala.Int], scala.Predef.String]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_LRUnionHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.Seq[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    in.foreach[scala.Unit](((i: scala.util.Try[scala.Option[scala.Int]] | java.lang.String) => {
      out.mark()
      scala.util.Try.apply[scala.Unit](out.valueEscaped(i.asInstanceOf[java.lang.String])) match {
        case scala.util.Success(_) =>
          ()
        case scala.util.Failure(_) =>
          out.revert()
          if (i.asInstanceOf[scala.util.Try[scala.Option[scala.Int]]].==(null)) out.burpNull() else i.asInstanceOf[scala.util.Try[scala.Option[scala.Int]]] match {
            case scala.util.Success(v) =>
              v match {
                case null =>
                  out.burpNull()
                case scala.None =>
                  ()
                case scala.Some(v) =>
                  val vv: scala.Int = `v₂`.asInstanceOf[scala.Int]
                  out.value(vv)
              }
            case scala.util.Failure(v) =>
              out.burpNull()
          }
      }
    }))
    out.endArray()
  }
  def w2(`in₂`: scala.Tuple2[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String, scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startArray()
    `out₂`.mark()
    scala.util.Try.apply[scala.Unit](`out₂`.valueEscaped(`in₂`._1.asInstanceOf[java.lang.String])) match {
      case scala.util.Success(_) =>
        ()
      case scala.util.Failure(_) =>
        `out₂`.revert()
        if (`in₂`._1.asInstanceOf[scala.util.Try[scala.Option[scala.Int]]].==(null)) `out₂`.burpNull() else `in₂`._1.asInstanceOf[scala.util.Try[scala.Option[scala.Int]]] match {
          case scala.util.Success(v) =>
            `v₃` match {
              case null =>
                `out₂`.burpNull()
              case scala.None =>
                `out₂`.burpNull()
              case scala.Some(v) =>
                val `vv₂`: scala.Int = `v₄`.asInstanceOf[scala.Int]
                `out₂`.value(`vv₂`)
            }
          case scala.util.Failure(v) =>
            `out₂`.burpNull()
        }
    }
    `out₂`.mark()
    scala.util.Try.apply[scala.Unit](`out₂`.valueEscaped(`in₂`._2.asInstanceOf[java.lang.String])) match {
      case scala.util.Success(_) =>
        ()
      case scala.util.Failure(_) =>
        `out₂`.revert()
        if (`in₂`._2.asInstanceOf[scala.util.Try[scala.Option[scala.Int]]].==(null)) `out₂`.burpNull() else `in₂`._2.asInstanceOf[scala.util.Try[scala.Option[scala.Int]]] match {
          case scala.util.Success(v) =>
            `v₅` match {
              case null =>
                `out₂`.burpNull()
              case scala.None =>
                `out₂`.burpNull()
              case scala.Some(v) =>
                val `vv₃`: scala.Int = `v₆`.asInstanceOf[scala.Int]
                `out₂`.value(`vv₃`)
            }
          case scala.util.Failure(v) =>
            `out₂`.burpNull()
        }
    }
    `out₂`.endArray()
  }
  def w0(`in₃`: co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `out₃`.label("a")
    w1(`in₃`.a, `out₃`)
    `out₃`.label("b")
    w2(`in₃`.b, `out₃`)
    `out₃`.endObject()
  }
  def r0(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String] = {
    var _a: scala.collection.immutable.Seq[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String] = null
    var _b: scala.Tuple2[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String, scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String] = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_misc_LRUnionHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.util.Try[scala.Option[scala.Int]] | java.lang.String] = `in₄`.expectArray[scala.util.Try[scala.Option[scala.Int]] | java.lang.String]((() => {
                  val mark: scala.Int = `in₄`.pos
                  scala.util.Try.apply[scala.util.Try[scala.Option[scala.Int]]]({
                    val `mark₂`: scala.Int = `in₄`.pos
                    try if (`in₄`.expectNull()) null else scala.util.Success.apply[scala.Option[scala.Int]](if (`in₄`.expectNull()) null else scala.Some.apply[scala.Int](`in₄`.expectInt())) catch {
                      case t: java.lang.Throwable =>
                        `in₄`.revertToPos(`mark₂`)
                        throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(t.getMessage()), `in₄`)
                    }
                  }) match {
                    case scala.util.Success(lval) =>
                      (lval: scala.util.Try[scala.Option[scala.Int]])
                    case scala.util.Failure(f) =>
                      `in₄`.revertToPos(mark)
                      scala.util.Try.apply[java.lang.String](`in₄`.expectString()) match {
                        case scala.util.Success(rval) =>
                          (rval: java.lang.String)
                        case scala.util.Failure(_) =>
                          `in₄`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₄`)
                      }
                  }
                }))

                (if (parsedArray.!=(null)) parsedArray.toSeq else null: scala.collection.immutable.Seq[scala.util.Try[scala.Option[scala.Int]] | java.lang.String])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₄`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b = if (`in₄`.expectNull()) null else {
                `in₄`.expectToken('[')
                val tv: scala.Tuple2[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String, scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String] = new scala.Tuple2[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String, scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String][scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String, scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String]({
                  val `mark₃`: scala.Int = `in₄`.pos
                  scala.util.Try.apply[scala.util.Try[scala.Option[scala.Int]]]({
                    val `mark₄`: scala.Int = `in₄`.pos
                    try if (`in₄`.expectNull()) null else scala.util.Success.apply[scala.Option[scala.Int]](if (`in₄`.expectNull()) null else scala.Some.apply[scala.Int](`in₄`.expectInt())) catch {
                      case t: java.lang.Throwable =>
                        `in₄`.revertToPos(`mark₄`)
                        throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(`t₂`.getMessage()), `in₄`)
                    }
                  }) match {
                    case scala.util.Success(lval) =>
                      (`lval₂`: scala.util.Try[scala.Option[scala.Int]])
                    case scala.util.Failure(f) =>
                      `in₄`.revertToPos(`mark₃`)
                      scala.util.Try.apply[java.lang.String](`in₄`.expectString()) match {
                        case scala.util.Success(rval) =>
                          (`rval₂`: java.lang.String)
                        case scala.util.Failure(_) =>
                          `in₄`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₄`)
                      }
                  }
                }, {
                  `in₄`.expectToken(',')
                  val `mark₅`: scala.Int = `in₄`.pos
                  scala.util.Try.apply[scala.util.Try[scala.Option[scala.Int]]]({
                    val `mark₆`: scala.Int = `in₄`.pos
                    try if (`in₄`.expectNull()) null else scala.util.Success.apply[scala.Option[scala.Int]](if (`in₄`.expectNull()) null else scala.Some.apply[scala.Int](`in₄`.expectInt())) catch {
                      case t: java.lang.Throwable =>
                        `in₄`.revertToPos(`mark₆`)
                        throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(`t₃`.getMessage()), `in₄`)
                    }
                  }) match {
                    case scala.util.Success(lval) =>
                      (`lval₃`: scala.util.Try[scala.Option[scala.Int]])
                    case scala.util.Failure(f) =>
                      `in₄`.revertToPos(`mark₅`)
                      scala.util.Try.apply[java.lang.String](`in₄`.expectString()) match {
                        case scala.util.Success(rval) =>
                          (`rval₃`: java.lang.String)
                        case scala.util.Failure(_) =>
                          `in₄`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₄`)
                      }
                  }
                })
                `in₄`.expectToken(']')

                (tv: scala.Tuple2[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String, scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_misc_LRUnionHolder_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String][scala.util.Try[scala.Option[scala.Int]], java.lang.String](_a, _b) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₄`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String]] {
    def encodeValue(`in₅`: co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₅`, `out₄`)
    def decodeValue(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String] = r0(`in₆`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_LRUnionHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.Seq[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    in.foreach[scala.Unit](((i: scala.util.Try[scala.Option[scala.Int]] | java.lang.String) => {
      out.mark()
      scala.util.Try.apply[scala.Unit](out.valueEscaped(i.asInstanceOf[java.lang.String])) match {
        case scala.util.Success(_) =>
          ()
        case scala.util.Failure(_) =>
          out.revert()
          if (i.asInstanceOf[scala.util.Try[scala.Option[scala.Int]]].==(null)) out.burpNull() else i.asInstanceOf[scala.util.Try[scala.Option[scala.Int]]] match {
            case scala.util.Success(v) =>
              v match {
                case null =>
                  out.burpNull()
                case scala.None =>
                  ()
                case scala.Some(v) =>
                  val vv: scala.Int = `v₂`.asInstanceOf[scala.Int]
                  out.value(vv)
              }
            case scala.util.Failure(v) =>
              out.burpNull()
          }
      }
    }))
    out.endArray()
  }
  def w2(`in₂`: scala.Tuple2[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String, scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startArray()
    `out₂`.mark()
    scala.util.Try.apply[scala.Unit](`out₂`.valueEscaped(`in₂`._1.asInstanceOf[java.lang.String])) match {
      case scala.util.Success(_) =>
        ()
      case scala.util.Failure(_) =>
        `out₂`.revert()
        if (`in₂`._1.asInstanceOf[scala.util.Try[scala.Option[scala.Int]]].==(null)) `out₂`.burpNull() else `in₂`._1.asInstanceOf[scala.util.Try[scala.Option[scala.Int]]] match {
          case scala.util.Success(v) =>
            `v₃` match {
              case null =>
                `out₂`.burpNull()
              case scala.None =>
                `out₂`.burpNull()
              case scala.Some(v) =>
                val `vv₂`: scala.Int = `v₄`.asInstanceOf[scala.Int]
                `out₂`.value(`vv₂`)
            }
          case scala.util.Failure(v) =>
            `out₂`.burpNull()
        }
    }
    `out₂`.mark()
    scala.util.Try.apply[scala.Unit](`out₂`.valueEscaped(`in₂`._2.asInstanceOf[java.lang.String])) match {
      case scala.util.Success(_) =>
        ()
      case scala.util.Failure(_) =>
        `out₂`.revert()
        if (`in₂`._2.asInstanceOf[scala.util.Try[scala.Option[scala.Int]]].==(null)) `out₂`.burpNull() else `in₂`._2.asInstanceOf[scala.util.Try[scala.Option[scala.Int]]] match {
          case scala.util.Success(v) =>
            `v₅` match {
              case null =>
                `out₂`.burpNull()
              case scala.None =>
                `out₂`.burpNull()
              case scala.Some(v) =>
                val `vv₃`: scala.Int = `v₆`.asInstanceOf[scala.Int]
                `out₂`.value(`vv₃`)
            }
          case scala.util.Failure(v) =>
            `out₂`.burpNull()
        }
    }
    `out₂`.endArray()
  }
  def w0(`in₃`: co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `out₃`.label("a")
    w1(`in₃`.a, `out₃`)
    `out₃`.label("b")
    w2(`in₃`.b, `out₃`)
    `out₃`.endObject()
  }
  def r0(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String] = {
    var _a: scala.collection.immutable.Seq[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String] = null
    var _b: scala.Tuple2[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String, scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String] = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_misc_LRUnionHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.util.Try[scala.Option[scala.Int]] | java.lang.String] = `in₄`.expectArray[scala.util.Try[scala.Option[scala.Int]] | java.lang.String]((() => {
                  val mark: scala.Int = `in₄`.pos
                  scala.util.Try.apply[scala.util.Try[scala.Option[scala.Int]]]({
                    val `mark₂`: scala.Int = `in₄`.pos
                    try if (`in₄`.expectNull()) null else scala.util.Success.apply[scala.Option[scala.Int]](if (`in₄`.expectNull()) null else scala.Some.apply[scala.Int](`in₄`.expectInt())) catch {
                      case t: java.lang.Throwable =>
                        `in₄`.revertToPos(`mark₂`)
                        throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(t.getMessage()), `in₄`)
                    }
                  }) match {
                    case scala.util.Success(lval) =>
                      (lval: scala.util.Try[scala.Option[scala.Int]])
                    case scala.util.Failure(f) =>
                      `in₄`.revertToPos(mark)
                      scala.util.Try.apply[java.lang.String](`in₄`.expectString()) match {
                        case scala.util.Success(rval) =>
                          (rval: java.lang.String)
                        case scala.util.Failure(_) =>
                          `in₄`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₄`)
                      }
                  }
                }))

                (if (parsedArray.!=(null)) parsedArray.toSeq else null: scala.collection.immutable.Seq[scala.util.Try[scala.Option[scala.Int]] | java.lang.String])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₄`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b = if (`in₄`.expectNull()) null else {
                `in₄`.expectToken('[')
                val tv: scala.Tuple2[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String, scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String] = new scala.Tuple2[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String, scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String][scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String, scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String]({
                  val `mark₃`: scala.Int = `in₄`.pos
                  scala.util.Try.apply[scala.util.Try[scala.Option[scala.Int]]]({
                    val `mark₄`: scala.Int = `in₄`.pos
                    try if (`in₄`.expectNull()) null else scala.util.Success.apply[scala.Option[scala.Int]](if (`in₄`.expectNull()) null else scala.Some.apply[scala.Int](`in₄`.expectInt())) catch {
                      case t: java.lang.Throwable =>
                        `in₄`.revertToPos(`mark₄`)
                        throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(`t₂`.getMessage()), `in₄`)
                    }
                  }) match {
                    case scala.util.Success(lval) =>
                      (`lval₂`: scala.util.Try[scala.Option[scala.Int]])
                    case scala.util.Failure(f) =>
                      `in₄`.revertToPos(`mark₃`)
                      scala.util.Try.apply[java.lang.String](`in₄`.expectString()) match {
                        case scala.util.Success(rval) =>
                          (`rval₂`: java.lang.String)
                        case scala.util.Failure(_) =>
                          `in₄`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₄`)
                      }
                  }
                }, {
                  `in₄`.expectToken(',')
                  val `mark₅`: scala.Int = `in₄`.pos
                  scala.util.Try.apply[scala.util.Try[scala.Option[scala.Int]]]({
                    val `mark₆`: scala.Int = `in₄`.pos
                    try if (`in₄`.expectNull()) null else scala.util.Success.apply[scala.Option[scala.Int]](if (`in₄`.expectNull()) null else scala.Some.apply[scala.Int](`in₄`.expectInt())) catch {
                      case t: java.lang.Throwable =>
                        `in₄`.revertToPos(`mark₆`)
                        throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(`t₃`.getMessage()), `in₄`)
                    }
                  }) match {
                    case scala.util.Success(lval) =>
                      (`lval₃`: scala.util.Try[scala.Option[scala.Int]])
                    case scala.util.Failure(f) =>
                      `in₄`.revertToPos(`mark₅`)
                      scala.util.Try.apply[java.lang.String](`in₄`.expectString()) match {
                        case scala.util.Success(rval) =>
                          (`rval₃`: java.lang.String)
                        case scala.util.Failure(_) =>
                          `in₄`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₄`)
                      }
                  }
                })
                `in₄`.expectToken(']')

                (tv: scala.Tuple2[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String, scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_misc_LRUnionHolder_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String][scala.util.Try[scala.Option[scala.Int]], java.lang.String](_a, _b) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₄`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String]] {
    def encodeValue(`in₅`: co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₅`, `out₄`)
    def decodeValue(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String] = r0(`in₆`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_LRUnionHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.Seq[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    in.foreach[scala.Unit](((i: scala.util.Try[scala.Option[scala.Int]] | java.lang.String) => {
      out.mark()
      scala.util.Try.apply[scala.Unit](out.valueEscaped(i.asInstanceOf[java.lang.String])) match {
        case scala.util.Success(_) =>
          ()
        case scala.util.Failure(_) =>
          out.revert()
          if (i.asInstanceOf[scala.util.Try[scala.Option[scala.Int]]].==(null)) out.burpNull() else i.asInstanceOf[scala.util.Try[scala.Option[scala.Int]]] match {
            case scala.util.Success(v) =>
              v match {
                case null =>
                  out.burpNull()
                case scala.None =>
                  ()
                case scala.Some(v) =>
                  val vv: scala.Int = `v₂`.asInstanceOf[scala.Int]
                  out.value(vv)
              }
            case scala.util.Failure(v) =>
              out.burpNull()
          }
      }
    }))
    out.endArray()
  }
  def w2(`in₂`: scala.Tuple2[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String, scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startArray()
    `out₂`.mark()
    scala.util.Try.apply[scala.Unit](`out₂`.valueEscaped(`in₂`._1.asInstanceOf[java.lang.String])) match {
      case scala.util.Success(_) =>
        ()
      case scala.util.Failure(_) =>
        `out₂`.revert()
        if (`in₂`._1.asInstanceOf[scala.util.Try[scala.Option[scala.Int]]].==(null)) `out₂`.burpNull() else `in₂`._1.asInstanceOf[scala.util.Try[scala.Option[scala.Int]]] match {
          case scala.util.Success(v) =>
            `v₃` match {
              case null =>
                `out₂`.burpNull()
              case scala.None =>
                `out₂`.burpNull()
              case scala.Some(v) =>
                val `vv₂`: scala.Int = `v₄`.asInstanceOf[scala.Int]
                `out₂`.value(`vv₂`)
            }
          case scala.util.Failure(v) =>
            `out₂`.burpNull()
        }
    }
    `out₂`.mark()
    scala.util.Try.apply[scala.Unit](`out₂`.valueEscaped(`in₂`._2.asInstanceOf[java.lang.String])) match {
      case scala.util.Success(_) =>
        ()
      case scala.util.Failure(_) =>
        `out₂`.revert()
        if (`in₂`._2.asInstanceOf[scala.util.Try[scala.Option[scala.Int]]].==(null)) `out₂`.burpNull() else `in₂`._2.asInstanceOf[scala.util.Try[scala.Option[scala.Int]]] match {
          case scala.util.Success(v) =>
            `v₅` match {
              case null =>
                `out₂`.burpNull()
              case scala.None =>
                `out₂`.burpNull()
              case scala.Some(v) =>
                val `vv₃`: scala.Int = `v₆`.asInstanceOf[scala.Int]
                `out₂`.value(`vv₃`)
            }
          case scala.util.Failure(v) =>
            `out₂`.burpNull()
        }
    }
    `out₂`.endArray()
  }
  def w0(`in₃`: co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `out₃`.label("a")
    w1(`in₃`.a, `out₃`)
    `out₃`.label("b")
    w2(`in₃`.b, `out₃`)
    `out₃`.endObject()
  }
  def r0(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String] = {
    var _a: scala.collection.immutable.Seq[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String] = null
    var _b: scala.Tuple2[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String, scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String] = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_misc_LRUnionHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.util.Try[scala.Option[scala.Int]] | java.lang.String] = `in₄`.expectArray[scala.util.Try[scala.Option[scala.Int]] | java.lang.String]((() => {
                  val mark: scala.Int = `in₄`.pos
                  scala.util.Try.apply[scala.util.Try[scala.Option[scala.Int]]]({
                    val `mark₂`: scala.Int = `in₄`.pos
                    try if (`in₄`.expectNull()) null else scala.util.Success.apply[scala.Option[scala.Int]](if (`in₄`.expectNull()) null else scala.Some.apply[scala.Int](`in₄`.expectInt())) catch {
                      case t: java.lang.Throwable =>
                        `in₄`.revertToPos(`mark₂`)
                        throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(t.getMessage()), `in₄`)
                    }
                  }) match {
                    case scala.util.Success(lval) =>
                      (lval: scala.util.Try[scala.Option[scala.Int]])
                    case scala.util.Failure(f) =>
                      `in₄`.revertToPos(mark)
                      scala.util.Try.apply[java.lang.String](`in₄`.expectString()) match {
                        case scala.util.Success(rval) =>
                          (rval: java.lang.String)
                        case scala.util.Failure(_) =>
                          `in₄`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₄`)
                      }
                  }
                }))

                (if (parsedArray.!=(null)) parsedArray.toSeq else null: scala.collection.immutable.Seq[scala.util.Try[scala.Option[scala.Int]] | java.lang.String])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₄`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b = if (`in₄`.expectNull()) null else {
                `in₄`.expectToken('[')
                val tv: scala.Tuple2[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String, scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String] = new scala.Tuple2[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String, scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String][scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String, scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String]({
                  val `mark₃`: scala.Int = `in₄`.pos
                  scala.util.Try.apply[scala.util.Try[scala.Option[scala.Int]]]({
                    val `mark₄`: scala.Int = `in₄`.pos
                    try if (`in₄`.expectNull()) null else scala.util.Success.apply[scala.Option[scala.Int]](if (`in₄`.expectNull()) null else scala.Some.apply[scala.Int](`in₄`.expectInt())) catch {
                      case t: java.lang.Throwable =>
                        `in₄`.revertToPos(`mark₄`)
                        throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(`t₂`.getMessage()), `in₄`)
                    }
                  }) match {
                    case scala.util.Success(lval) =>
                      (`lval₂`: scala.util.Try[scala.Option[scala.Int]])
                    case scala.util.Failure(f) =>
                      `in₄`.revertToPos(`mark₃`)
                      scala.util.Try.apply[java.lang.String](`in₄`.expectString()) match {
                        case scala.util.Success(rval) =>
                          (`rval₂`: java.lang.String)
                        case scala.util.Failure(_) =>
                          `in₄`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₄`)
                      }
                  }
                }, {
                  `in₄`.expectToken(',')
                  val `mark₅`: scala.Int = `in₄`.pos
                  scala.util.Try.apply[scala.util.Try[scala.Option[scala.Int]]]({
                    val `mark₆`: scala.Int = `in₄`.pos
                    try if (`in₄`.expectNull()) null else scala.util.Success.apply[scala.Option[scala.Int]](if (`in₄`.expectNull()) null else scala.Some.apply[scala.Int](`in₄`.expectInt())) catch {
                      case t: java.lang.Throwable =>
                        `in₄`.revertToPos(`mark₆`)
                        throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(`t₃`.getMessage()), `in₄`)
                    }
                  }) match {
                    case scala.util.Success(lval) =>
                      (`lval₃`: scala.util.Try[scala.Option[scala.Int]])
                    case scala.util.Failure(f) =>
                      `in₄`.revertToPos(`mark₅`)
                      scala.util.Try.apply[java.lang.String](`in₄`.expectString()) match {
                        case scala.util.Success(rval) =>
                          (`rval₃`: java.lang.String)
                        case scala.util.Failure(_) =>
                          `in₄`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₄`)
                      }
                  }
                })
                `in₄`.expectToken(']')

                (tv: scala.Tuple2[scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String, scala.util.Try[scala.Option[scala.Int]] | scala.Predef.String])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_misc_LRUnionHolder_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String][scala.util.Try[scala.Option[scala.Int]], java.lang.String](_a, _b) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₄`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String]] {
    def encodeValue(`in₅`: co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₅`, `out₄`)
    def decodeValue(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String] = r0(`in₆`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.LRUnionHolder[scala.util.Try[scala.Option[scala.Int]], scala.Predef.String]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_Person_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("name", "age")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  val __co_blocke_scalajack_json_misc_OptionHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.Tuple2[scala.Option[scala.Int], scala.Predef.String], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    in._1 match {
      case null =>
        out.burpNull()
      case scala.None =>
        out.burpNull()
      case scala.Some(v) =>
        val vv: scala.Int = v.asInstanceOf[scala.Int]
        out.value(vv)
    }
    out.valueEscaped(in._2)
    out.endArray()
  }
  def w2(`in₂`: scala.collection.immutable.List[scala.Option[scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startArray()
    `in₂`.foreach[scala.Unit](((i: scala.Option[scala.Int]) => i match {
      case null =>
        `out₂`.burpNull()
      case scala.None =>
        ()
      case scala.Some(v) =>
        val `vv₂`: scala.Int = `v₂`.asInstanceOf[scala.Int]
        `out₂`.value(`vv₂`)
    }))
    `out₂`.endArray()
  }
  def w3(`in₃`: scala.collection.immutable.Map[scala.Int, scala.Option[scala.Int]], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `in₃`.foreach[scala.Unit](((x$1: scala.Tuple2[scala.Int, scala.Option[scala.Int]]) => x$1 match {
      case scala.Tuple2(key, value) =>
        value match {
          case scala.None =>
            ()
          case scala.Some(v) =>
            {
              `out₃`.maybeComma()
              `out₃`.valueStringified(scala.Int.int2long(key))
              `out₃`.colon()
              `out₃`.value(`v₃`)
            }
        }
    }))
    `out₃`.endObject()
  }
  def w4(`in₄`: co.blocke.scalajack.json.misc.Person, `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₄`.==(null)) `out₄`.burpNull() else {
    `out₄`.startObject()
    `out₄`.label("name")
    `out₄`.valueEscaped(`in₄`.name)
    `out₄`.label("age")
    `out₄`.value(`in₄`.age)
    `out₄`.endObject()
  }
  def w0(`in₅`: co.blocke.scalajack.json.misc.OptionHolder[scala.Int], `out₅`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₅`.==(null)) `out₅`.burpNull() else {
    `out₅`.startObject()
    `in₅`.a match {
      case scala.None =>
        ()
      case scala.Some(v) =>
        {
          `out₅`.label("a")
          `out₅`.value(`v₄`)
        }
    }
    `out₅`.label("b")
    w1(`in₅`.b, `out₅`)
    `out₅`.label("c")
    w2(`in₅`.c, `out₅`)
    `out₅`.label("d")
    w3(`in₅`.d, `out₅`)
    if (`in₅`.e.==(null)) `out₅`.burpNull() else {
      `out₅`.mark()
      scala.util.Try.apply[scala.Unit](`in₅`.e.asInstanceOf[scala.Option[scala.Int]] match {
        case scala.None =>
          ()
        case scala.Some(v) =>
          {
            `out₅`.label("e")
            `out₅`.value(`v₅`)
          }
      }) match {
        case scala.util.Success(_) =>
          ()
        case scala.util.Failure(f) =>
          `out₅`.revert()
          {
            `out₅`.label("e")
            `out₅`.value(`in₅`.e.asInstanceOf[scala.Int])
          }
      }
    }
    if (`in₅`.f.==(null)) `out₅`.burpNull() else {
      `out₅`.mark()
      scala.util.Try.apply[scala.Unit]({
        `out₅`.label("f")
        `out₅`.value(`in₅`.f.asInstanceOf[scala.Int])
      }) match {
        case scala.util.Success(_) =>
          ()
        case scala.util.Failure(f) =>
          `out₅`.revert()
          `in₅`.f.asInstanceOf[scala.Option[scala.Int]] match {
            case scala.None =>
              ()
            case scala.Some(v) =>
              {
                `out₅`.label("f")
                `out₅`.value(`v₆`)
              }
          }
      }
    }
    `in₅`.g match {
      case scala.None =>
        ()
      case scala.Some(v) =>
        `v₇` match {
          case scala.None =>
            ()
          case scala.Some(v) =>
            {
              `out₅`.label("g")
              `out₅`.value(`v₈`)
            }
        }
    }
    `in₅`.h match {
      case scala.None =>
        ()
      case scala.Some(v) =>
        {
          `out₅`.label("h")
          w4(`v₉`, `out₅`)
        }
    }
    if (`in₅`.i.==(null)) `out₅`.burpNull() else ()
    `in₅`.i match {
      case scala.Left(v) =>
        {
          `out₅`.label("i")
          `out₅`.value(`v₁₀`.asInstanceOf[scala.Int])
        }
      case scala.Right(v) =>
        `v₁₁`.asInstanceOf[scala.Option[scala.Int]] match {
          case scala.None =>
            ()
          case scala.Some(v) =>
            {
              `out₅`.label("i")
              `out₅`.value(`v₁₂`)
            }
        }
    }
    if (`in₅`.j.==(null)) `out₅`.burpNull() else ()
    `in₅`.j match {
      case scala.Left(v) =>
        `v₁₃`.asInstanceOf[scala.Option[scala.Int]] match {
          case scala.None =>
            ()
          case scala.Some(v) =>
            {
              `out₅`.label("j")
              `out₅`.value(`v₁₄`)
            }
        }
      case scala.Right(v) =>
        {
          `out₅`.label("j")
          `out₅`.value(`v₁₅`.asInstanceOf[scala.Int])
        }
    }
    `out₅`.endObject()
  }
  def r1(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.Person = {
    var _name: java.lang.String = ""
    var _age: scala.Int = 0
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₆`.expectFirstObjectField(__co_blocke_scalajack_json_misc_Person_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.Person] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _name = `in₆`.expectString()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("name"), `in₆`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _age = `in₆`.expectInt()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("age"), `in₆`)
          case _ =>
            `in₆`.skipValue()
        }
        maybeFieldNum = `in₆`.expectObjectField(__co_blocke_scalajack_json_misc_Person_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.misc.Person(_name, _age) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("name", "age")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₆`)
    }
  }
  def r0(`in₇`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.OptionHolder[scala.Int] = {
    var _a: scala.Option[scala.Int] = scala.None
    var _b: scala.Tuple2[scala.Option[scala.Int], scala.Predef.String] = null
    var _c: scala.collection.immutable.List[scala.Option[scala.Int]] = null
    var _d: scala.collection.immutable.Map[scala.Int, scala.Option[scala.Int]] = null
    var _e: scala.Int | scala.Option[scala.Int] = scala.None
    var _f: scala.Option[scala.Int] | scala.Int = scala.None
    var _g: scala.Option[scala.Option[scala.Int]] = scala.None
    var _h: scala.Option[co.blocke.scalajack.json.misc.Person] = scala.None
    var _i: scala.util.Either[scala.Int, scala.Option[scala.Int]] = scala.Predef.augmentString("r").foldRight[scala.Any]((scala.None: scala.Any))(((c: scala.Char, acc: scala.Any) => if (c.==('r')) scala.Right.apply[scala.Nothing, scala.Any](acc) else scala.Left.apply[scala.Any, scala.Nothing](acc))).asInstanceOf[scala.util.Either[scala.Int, scala.Option[scala.Int]]]
    var _j: scala.util.Either[scala.Option[scala.Int], scala.Int] = scala.Predef.augmentString("l").foldRight[scala.Any]((scala.None: scala.Any))(((`c₂`: scala.Char, `acc₂`: scala.Any) => if (`c₂`.==('r')) scala.Right.apply[scala.Nothing, scala.Any](`acc₂`) else scala.Left.apply[scala.Any, scala.Nothing](`acc₂`))).asInstanceOf[scala.util.Either[scala.Option[scala.Int], scala.Int]]
    var `required₂`: scala.Int = 1023
    var `maybeFieldNum₂`: scala.Option[scala.Int] = `in₇`.expectFirstObjectField(__co_blocke_scalajack_json_misc_OptionHolder_fields)
    if (`maybeFieldNum₂`.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.OptionHolder[scala.Int]] else {
      while (`maybeFieldNum₂`.isDefined) {
        `maybeFieldNum₂`.get match {
          case 0 =>
            if (`required₂`.&(1).!=(0)) {
              `required₂` = `required₂`.^(1)
              _a = if (`in₇`.expectNull()) null else scala.Some.apply[scala.Int](`in₇`.expectInt())
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₇`)
          case 1 =>
            if (`required₂`.&(2).!=(0)) {
              `required₂` = `required₂`.^(2)
              _b = if (`in₇`.expectNull()) null else {
                `in₇`.expectToken('[')
                val tv: scala.Tuple2[scala.Option[scala.Int], scala.Predef.String] = new scala.Tuple2[scala.Option[scala.Int], scala.Predef.String][scala.Option[scala.Int], java.lang.String](if (`in₇`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₇`.expectInt()), {
                  `in₇`.expectToken(',')
                  `in₇`.expectString()
                })
                `in₇`.expectToken(']')

                (tv: scala.Tuple2[scala.Option[scala.Int], scala.Predef.String])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₇`)
          case 2 =>
            if (`required₂`.&(4).!=(0)) {
              `required₂` = `required₂`.^(4)
              _c = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Option[scala.Int]] = `in₇`.expectArray[scala.Option[scala.Int]]((() => if (`in₇`.expectNull()) null else scala.Some.apply[scala.Int](`in₇`.expectInt())))

                (if (parsedArray.!=(null)) parsedArray.toList else null: scala.collection.immutable.List[scala.Option[scala.Int]])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c"), `in₇`)
          case 3 =>
            if (`required₂`.&(8).!=(0)) {
              `required₂` = `required₂`.^(8)
              _d = if (`in₇`.expectNull()) null else {
                `in₇`.expectToken('{')
                `in₇`.parseMap[scala.Int, scala.Option[scala.Int]]((() => scala.Predef.augmentString(`in₇`.expectString()).toInt), (() => if (`in₇`.expectNull()) null else scala.Some.apply[scala.Int](`in₇`.expectInt())), scala.Predef.Map.empty[scala.Int, scala.Option[scala.Int]], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d"), `in₇`)
          case 4 =>
            if (`required₂`.&(16).!=(0)) {
              `required₂` = `required₂`.^(16)
              _e = {
                val mark: scala.Int = `in₇`.pos
                scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                  case scala.util.Success(lval) =>
                    (lval: scala.Int)
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(mark)
                    scala.util.Try.apply[scala.Option[scala.Int]](if (`in₇`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₇`.expectInt())) match {
                      case scala.util.Success(rval) =>
                        (rval: scala.Option[scala.Int])
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("e"), `in₇`)
          case 5 =>
            if (`required₂`.&(32).!=(0)) {
              `required₂` = `required₂`.^(32)
              _f = {
                val `mark₂`: scala.Int = `in₇`.pos
                scala.util.Try.apply[scala.Option[scala.Int]](if (`in₇`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₇`.expectInt())) match {
                  case scala.util.Success(lval) =>
                    (`lval₂`: scala.Option[scala.Int])
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(`mark₂`)
                    scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                      case scala.util.Success(rval) =>
                        (`rval₂`: scala.Int)
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f"), `in₇`)
          case 6 =>
            if (`required₂`.&(64).!=(0)) {
              `required₂` = `required₂`.^(64)
              _g = if (`in₇`.expectNull()) null else scala.Some.apply[scala.Option[scala.Int]](if (`in₇`.expectNull()) null else scala.Some.apply[scala.Int](`in₇`.expectInt()))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("g"), `in₇`)
          case 7 =>
            if (`required₂`.&(128).!=(0)) {
              `required₂` = `required₂`.^(128)
              _h = if (`in₇`.expectNull()) null else scala.Some.apply[co.blocke.scalajack.json.misc.Person](r1(`in₇`))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("h"), `in₇`)
          case 8 =>
            if (`required₂`.&(256).!=(0)) {
              `required₂` = `required₂`.^(256)
              _i = {
                val `mark₃`: scala.Int = `in₇`.pos
                if (`in₇`.expectNull()) null else scala.util.Try.apply[scala.Option[scala.Int]](if (`in₇`.expectNull()) null else scala.Some.apply[scala.Int](`in₇`.expectInt())) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Option[scala.Int]](`rval₃`)
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(`mark₃`)
                    scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[scala.Int, scala.Nothing](`lval₃`)
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i"), `in₇`)
          case 9 =>
            if (`required₂`.&(512).!=(0)) {
              `required₂` = `required₂`.^(512)
              _j = {
                val `mark₄`: scala.Int = `in₇`.pos
                if (`in₇`.expectNull()) null else scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Int](`rval₄`)
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(`mark₄`)
                    scala.util.Try.apply[scala.Option[scala.Int]](if (`in₇`.expectNull()) null else scala.Some.apply[scala.Int](`in₇`.expectInt())) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[scala.Option[scala.Int], scala.Nothing](`lval₄`)
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("j"), `in₇`)
          case _ =>
            `in₇`.skipValue()
        }
        `maybeFieldNum₂` = `in₇`.expectObjectField(__co_blocke_scalajack_json_misc_OptionHolder_fields)
      }
      if (`required₂`.&(14).==(0)) new co.blocke.scalajack.json.misc.OptionHolder[scala.Int][scala.Int](_a, _b, _c, _d, _e, _f, _g, _h, _i, _j) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(`required₂`.&(14)))), `in₇`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.OptionHolder[scala.Int]] {
    def encodeValue(`in₈`: co.blocke.scalajack.json.misc.OptionHolder[scala.Int], `out₆`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₈`, `out₆`)
    def decodeValue(`in₉`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.OptionHolder[scala.Int] = r0(`in₉`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.OptionHolder[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_Person_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("name", "age")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  val __co_blocke_scalajack_json_misc_OptionHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.Tuple2[scala.Option[scala.Int], scala.Predef.String], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    in._1 match {
      case null =>
        out.burpNull()
      case scala.None =>
        out.burpNull()
      case scala.Some(v) =>
        val vv: scala.Int = v.asInstanceOf[scala.Int]
        out.value(vv)
    }
    out.valueEscaped(in._2)
    out.endArray()
  }
  def w2(`in₂`: scala.collection.immutable.List[scala.Option[scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startArray()
    `in₂`.foreach[scala.Unit](((i: scala.Option[scala.Int]) => i match {
      case null =>
        `out₂`.burpNull()
      case scala.None =>
        ()
      case scala.Some(v) =>
        val `vv₂`: scala.Int = `v₂`.asInstanceOf[scala.Int]
        `out₂`.value(`vv₂`)
    }))
    `out₂`.endArray()
  }
  def w3(`in₃`: scala.collection.immutable.Map[scala.Int, scala.Option[scala.Int]], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `in₃`.foreach[scala.Unit](((x$1: scala.Tuple2[scala.Int, scala.Option[scala.Int]]) => x$1 match {
      case scala.Tuple2(key, value) =>
        value match {
          case scala.None =>
            ()
          case scala.Some(v) =>
            {
              `out₃`.maybeComma()
              `out₃`.valueStringified(scala.Int.int2long(key))
              `out₃`.colon()
              `out₃`.value(`v₃`)
            }
        }
    }))
    `out₃`.endObject()
  }
  def w4(`in₄`: co.blocke.scalajack.json.misc.Person, `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₄`.==(null)) `out₄`.burpNull() else {
    `out₄`.startObject()
    `out₄`.label("name")
    `out₄`.valueEscaped(`in₄`.name)
    `out₄`.label("age")
    `out₄`.value(`in₄`.age)
    `out₄`.endObject()
  }
  def w0(`in₅`: co.blocke.scalajack.json.misc.OptionHolder[scala.Int], `out₅`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₅`.==(null)) `out₅`.burpNull() else {
    `out₅`.startObject()
    `in₅`.a match {
      case scala.None =>
        ()
      case scala.Some(v) =>
        {
          `out₅`.label("a")
          `out₅`.value(`v₄`)
        }
    }
    `out₅`.label("b")
    w1(`in₅`.b, `out₅`)
    `out₅`.label("c")
    w2(`in₅`.c, `out₅`)
    `out₅`.label("d")
    w3(`in₅`.d, `out₅`)
    if (`in₅`.e.==(null)) `out₅`.burpNull() else {
      `out₅`.mark()
      scala.util.Try.apply[scala.Unit](`in₅`.e.asInstanceOf[scala.Option[scala.Int]] match {
        case scala.None =>
          ()
        case scala.Some(v) =>
          {
            `out₅`.label("e")
            `out₅`.value(`v₅`)
          }
      }) match {
        case scala.util.Success(_) =>
          ()
        case scala.util.Failure(f) =>
          `out₅`.revert()
          {
            `out₅`.label("e")
            `out₅`.value(`in₅`.e.asInstanceOf[scala.Int])
          }
      }
    }
    if (`in₅`.f.==(null)) `out₅`.burpNull() else {
      `out₅`.mark()
      scala.util.Try.apply[scala.Unit]({
        `out₅`.label("f")
        `out₅`.value(`in₅`.f.asInstanceOf[scala.Int])
      }) match {
        case scala.util.Success(_) =>
          ()
        case scala.util.Failure(f) =>
          `out₅`.revert()
          `in₅`.f.asInstanceOf[scala.Option[scala.Int]] match {
            case scala.None =>
              ()
            case scala.Some(v) =>
              {
                `out₅`.label("f")
                `out₅`.value(`v₆`)
              }
          }
      }
    }
    `in₅`.g match {
      case scala.None =>
        ()
      case scala.Some(v) =>
        `v₇` match {
          case scala.None =>
            ()
          case scala.Some(v) =>
            {
              `out₅`.label("g")
              `out₅`.value(`v₈`)
            }
        }
    }
    `in₅`.h match {
      case scala.None =>
        ()
      case scala.Some(v) =>
        {
          `out₅`.label("h")
          w4(`v₉`, `out₅`)
        }
    }
    if (`in₅`.i.==(null)) `out₅`.burpNull() else ()
    `in₅`.i match {
      case scala.Left(v) =>
        {
          `out₅`.label("i")
          `out₅`.value(`v₁₀`.asInstanceOf[scala.Int])
        }
      case scala.Right(v) =>
        `v₁₁`.asInstanceOf[scala.Option[scala.Int]] match {
          case scala.None =>
            ()
          case scala.Some(v) =>
            {
              `out₅`.label("i")
              `out₅`.value(`v₁₂`)
            }
        }
    }
    if (`in₅`.j.==(null)) `out₅`.burpNull() else ()
    `in₅`.j match {
      case scala.Left(v) =>
        `v₁₃`.asInstanceOf[scala.Option[scala.Int]] match {
          case scala.None =>
            ()
          case scala.Some(v) =>
            {
              `out₅`.label("j")
              `out₅`.value(`v₁₄`)
            }
        }
      case scala.Right(v) =>
        {
          `out₅`.label("j")
          `out₅`.value(`v₁₅`.asInstanceOf[scala.Int])
        }
    }
    `out₅`.endObject()
  }
  def r1(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.Person = {
    var _name: java.lang.String = ""
    var _age: scala.Int = 0
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₆`.expectFirstObjectField(__co_blocke_scalajack_json_misc_Person_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.Person] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _name = `in₆`.expectString()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("name"), `in₆`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _age = `in₆`.expectInt()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("age"), `in₆`)
          case _ =>
            `in₆`.skipValue()
        }
        maybeFieldNum = `in₆`.expectObjectField(__co_blocke_scalajack_json_misc_Person_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.misc.Person(_name, _age) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("name", "age")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₆`)
    }
  }
  def r0(`in₇`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.OptionHolder[scala.Int] = {
    var _a: scala.Option[scala.Int] = scala.None
    var _b: scala.Tuple2[scala.Option[scala.Int], scala.Predef.String] = null
    var _c: scala.collection.immutable.List[scala.Option[scala.Int]] = null
    var _d: scala.collection.immutable.Map[scala.Int, scala.Option[scala.Int]] = null
    var _e: scala.Int | scala.Option[scala.Int] = scala.None
    var _f: scala.Option[scala.Int] | scala.Int = scala.None
    var _g: scala.Option[scala.Option[scala.Int]] = scala.None
    var _h: scala.Option[co.blocke.scalajack.json.misc.Person] = scala.None
    var _i: scala.util.Either[scala.Int, scala.Option[scala.Int]] = scala.Predef.augmentString("r").foldRight[scala.Any]((scala.None: scala.Any))(((c: scala.Char, acc: scala.Any) => if (c.==('r')) scala.Right.apply[scala.Nothing, scala.Any](acc) else scala.Left.apply[scala.Any, scala.Nothing](acc))).asInstanceOf[scala.util.Either[scala.Int, scala.Option[scala.Int]]]
    var _j: scala.util.Either[scala.Option[scala.Int], scala.Int] = scala.Predef.augmentString("l").foldRight[scala.Any]((scala.None: scala.Any))(((`c₂`: scala.Char, `acc₂`: scala.Any) => if (`c₂`.==('r')) scala.Right.apply[scala.Nothing, scala.Any](`acc₂`) else scala.Left.apply[scala.Any, scala.Nothing](`acc₂`))).asInstanceOf[scala.util.Either[scala.Option[scala.Int], scala.Int]]
    var `required₂`: scala.Int = 1023
    var `maybeFieldNum₂`: scala.Option[scala.Int] = `in₇`.expectFirstObjectField(__co_blocke_scalajack_json_misc_OptionHolder_fields)
    if (`maybeFieldNum₂`.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.OptionHolder[scala.Int]] else {
      while (`maybeFieldNum₂`.isDefined) {
        `maybeFieldNum₂`.get match {
          case 0 =>
            if (`required₂`.&(1).!=(0)) {
              `required₂` = `required₂`.^(1)
              _a = if (`in₇`.expectNull()) null else scala.Some.apply[scala.Int](`in₇`.expectInt())
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₇`)
          case 1 =>
            if (`required₂`.&(2).!=(0)) {
              `required₂` = `required₂`.^(2)
              _b = if (`in₇`.expectNull()) null else {
                `in₇`.expectToken('[')
                val tv: scala.Tuple2[scala.Option[scala.Int], scala.Predef.String] = new scala.Tuple2[scala.Option[scala.Int], scala.Predef.String][scala.Option[scala.Int], java.lang.String](if (`in₇`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₇`.expectInt()), {
                  `in₇`.expectToken(',')
                  `in₇`.expectString()
                })
                `in₇`.expectToken(']')

                (tv: scala.Tuple2[scala.Option[scala.Int], scala.Predef.String])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₇`)
          case 2 =>
            if (`required₂`.&(4).!=(0)) {
              `required₂` = `required₂`.^(4)
              _c = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Option[scala.Int]] = `in₇`.expectArray[scala.Option[scala.Int]]((() => if (`in₇`.expectNull()) null else scala.Some.apply[scala.Int](`in₇`.expectInt())))

                (if (parsedArray.!=(null)) parsedArray.toList else null: scala.collection.immutable.List[scala.Option[scala.Int]])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c"), `in₇`)
          case 3 =>
            if (`required₂`.&(8).!=(0)) {
              `required₂` = `required₂`.^(8)
              _d = if (`in₇`.expectNull()) null else {
                `in₇`.expectToken('{')
                `in₇`.parseMap[scala.Int, scala.Option[scala.Int]]((() => scala.Predef.augmentString(`in₇`.expectString()).toInt), (() => if (`in₇`.expectNull()) null else scala.Some.apply[scala.Int](`in₇`.expectInt())), scala.Predef.Map.empty[scala.Int, scala.Option[scala.Int]], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d"), `in₇`)
          case 4 =>
            if (`required₂`.&(16).!=(0)) {
              `required₂` = `required₂`.^(16)
              _e = {
                val mark: scala.Int = `in₇`.pos
                scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                  case scala.util.Success(lval) =>
                    (lval: scala.Int)
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(mark)
                    scala.util.Try.apply[scala.Option[scala.Int]](if (`in₇`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₇`.expectInt())) match {
                      case scala.util.Success(rval) =>
                        (rval: scala.Option[scala.Int])
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("e"), `in₇`)
          case 5 =>
            if (`required₂`.&(32).!=(0)) {
              `required₂` = `required₂`.^(32)
              _f = {
                val `mark₂`: scala.Int = `in₇`.pos
                scala.util.Try.apply[scala.Option[scala.Int]](if (`in₇`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₇`.expectInt())) match {
                  case scala.util.Success(lval) =>
                    (`lval₂`: scala.Option[scala.Int])
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(`mark₂`)
                    scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                      case scala.util.Success(rval) =>
                        (`rval₂`: scala.Int)
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f"), `in₇`)
          case 6 =>
            if (`required₂`.&(64).!=(0)) {
              `required₂` = `required₂`.^(64)
              _g = if (`in₇`.expectNull()) null else scala.Some.apply[scala.Option[scala.Int]](if (`in₇`.expectNull()) null else scala.Some.apply[scala.Int](`in₇`.expectInt()))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("g"), `in₇`)
          case 7 =>
            if (`required₂`.&(128).!=(0)) {
              `required₂` = `required₂`.^(128)
              _h = if (`in₇`.expectNull()) null else scala.Some.apply[co.blocke.scalajack.json.misc.Person](r1(`in₇`))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("h"), `in₇`)
          case 8 =>
            if (`required₂`.&(256).!=(0)) {
              `required₂` = `required₂`.^(256)
              _i = {
                val `mark₃`: scala.Int = `in₇`.pos
                if (`in₇`.expectNull()) null else scala.util.Try.apply[scala.Option[scala.Int]](if (`in₇`.expectNull()) null else scala.Some.apply[scala.Int](`in₇`.expectInt())) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Option[scala.Int]](`rval₃`)
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(`mark₃`)
                    scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[scala.Int, scala.Nothing](`lval₃`)
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i"), `in₇`)
          case 9 =>
            if (`required₂`.&(512).!=(0)) {
              `required₂` = `required₂`.^(512)
              _j = {
                val `mark₄`: scala.Int = `in₇`.pos
                if (`in₇`.expectNull()) null else scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Int](`rval₄`)
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(`mark₄`)
                    scala.util.Try.apply[scala.Option[scala.Int]](if (`in₇`.expectNull()) null else scala.Some.apply[scala.Int](`in₇`.expectInt())) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[scala.Option[scala.Int], scala.Nothing](`lval₄`)
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("j"), `in₇`)
          case _ =>
            `in₇`.skipValue()
        }
        `maybeFieldNum₂` = `in₇`.expectObjectField(__co_blocke_scalajack_json_misc_OptionHolder_fields)
      }
      if (`required₂`.&(14).==(0)) new co.blocke.scalajack.json.misc.OptionHolder[scala.Int][scala.Int](_a, _b, _c, _d, _e, _f, _g, _h, _i, _j) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(`required₂`.&(14)))), `in₇`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.OptionHolder[scala.Int]] {
    def encodeValue(`in₈`: co.blocke.scalajack.json.misc.OptionHolder[scala.Int], `out₆`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₈`, `out₆`)
    def decodeValue(`in₉`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.OptionHolder[scala.Int] = r0(`in₉`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.OptionHolder[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_Person_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("name", "age")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  val __co_blocke_scalajack_json_misc_OptionHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.Tuple2[scala.Option[scala.Int], scala.Predef.String], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    in._1 match {
      case null =>
        out.burpNull()
      case scala.None =>
        out.burpNull()
      case scala.Some(v) =>
        val vv: scala.Int = v.asInstanceOf[scala.Int]
        out.value(vv)
    }
    out.valueEscaped(in._2)
    out.endArray()
  }
  def w2(`in₂`: scala.collection.immutable.List[scala.Option[scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startArray()
    `in₂`.foreach[scala.Unit](((i: scala.Option[scala.Int]) => i match {
      case null =>
        `out₂`.burpNull()
      case scala.None =>
        `out₂`.burpNull()
      case scala.Some(v) =>
        val `vv₂`: scala.Int = `v₂`.asInstanceOf[scala.Int]
        `out₂`.value(`vv₂`)
    }))
    `out₂`.endArray()
  }
  def w3(`in₃`: scala.collection.immutable.Map[scala.Int, scala.Option[scala.Int]], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `in₃`.foreach[scala.Unit](((x$1: scala.Tuple2[scala.Int, scala.Option[scala.Int]]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          `out₃`.maybeComma()
          `out₃`.valueStringified(scala.Int.int2long(key))
          `out₃`.colon()
          value match {
            case null =>
              `out₃`.burpNull()
            case scala.None =>
              `out₃`.burpNull()
            case scala.Some(v) =>
              val `vv₃`: scala.Int = `v₃`.asInstanceOf[scala.Int]
              `out₃`.value(`vv₃`)
          }
        }
    }))
    `out₃`.endObject()
  }
  def w4(`in₄`: co.blocke.scalajack.json.misc.Person, `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₄`.==(null)) `out₄`.burpNull() else {
    `out₄`.startObject()
    `out₄`.label("name")
    `out₄`.valueEscaped(`in₄`.name)
    `out₄`.label("age")
    `out₄`.value(`in₄`.age)
    `out₄`.endObject()
  }
  def w0(`in₅`: co.blocke.scalajack.json.misc.OptionHolder[scala.Int], `out₅`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₅`.==(null)) `out₅`.burpNull() else {
    `out₅`.startObject()
    `out₅`.label("a")
    `in₅`.a match {
      case null =>
        `out₅`.burpNull()
      case scala.None =>
        `out₅`.burpNull()
      case scala.Some(v) =>
        val `vv₄`: scala.Int = `v₄`.asInstanceOf[scala.Int]
        `out₅`.value(`vv₄`)
    }
    `out₅`.label("b")
    w1(`in₅`.b, `out₅`)
    `out₅`.label("c")
    w2(`in₅`.c, `out₅`)
    `out₅`.label("d")
    w3(`in₅`.d, `out₅`)
    if (`in₅`.e.==(null)) `out₅`.burpNull() else {
      `out₅`.mark()
      scala.util.Try.apply[scala.Unit]({
        `out₅`.label("e")
        `in₅`.e.asInstanceOf[scala.Option[scala.Int]] match {
          case null =>
            `out₅`.burpNull()
          case scala.None =>
            `out₅`.burpNull()
          case scala.Some(v) =>
            val `vv₅`: scala.Int = `v₅`.asInstanceOf[scala.Int]
            `out₅`.value(`vv₅`)
        }
      }) match {
        case scala.util.Success(_) =>
          ()
        case scala.util.Failure(f) =>
          `out₅`.revert()
          {
            `out₅`.label("e")
            `out₅`.value(`in₅`.e.asInstanceOf[scala.Int])
          }
      }
    }
    if (`in₅`.f.==(null)) `out₅`.burpNull() else {
      `out₅`.mark()
      scala.util.Try.apply[scala.Unit]({
        `out₅`.label("f")
        `out₅`.value(`in₅`.f.asInstanceOf[scala.Int])
      }) match {
        case scala.util.Success(_) =>
          ()
        case scala.util.Failure(f) =>
          `out₅`.revert()
          {
            `out₅`.label("f")
            `in₅`.f.asInstanceOf[scala.Option[scala.Int]] match {
              case null =>
                `out₅`.burpNull()
              case scala.None =>
                `out₅`.burpNull()
              case scala.Some(v) =>
                val `vv₆`: scala.Int = `v₆`.asInstanceOf[scala.Int]
                `out₅`.value(`vv₆`)
            }
          }
      }
    }
    `out₅`.label("g")
    `in₅`.g match {
      case null =>
        `out₅`.burpNull()
      case scala.None =>
        `out₅`.burpNull()
      case scala.Some(v) =>
        val `vv₇`: scala.Option[scala.Int] = `v₇`.asInstanceOf[scala.Option[scala.Int]]
        `vv₇` match {
          case null =>
            `out₅`.burpNull()
          case scala.None =>
            `out₅`.burpNull()
          case scala.Some(v) =>
            val `vv₈`: scala.Int = `v₈`.asInstanceOf[scala.Int]
            `out₅`.value(`vv₈`)
        }
    }
    `out₅`.label("h")
    `in₅`.h match {
      case null =>
        `out₅`.burpNull()
      case scala.None =>
        `out₅`.burpNull()
      case scala.Some(v) =>
        val `vv₉`: co.blocke.scalajack.json.misc.Person = `v₉`.asInstanceOf[co.blocke.scalajack.json.misc.Person]
        w4(`vv₉`, `out₅`)
    }
    if (`in₅`.i.==(null)) `out₅`.burpNull() else ()
    `in₅`.i match {
      case scala.Left(v) =>
        {
          `out₅`.label("i")
          `out₅`.value(`v₁₀`.asInstanceOf[scala.Int])
        }
      case scala.Right(v) =>
        {
          `out₅`.label("i")
          `v₁₁`.asInstanceOf[scala.Option[scala.Int]] match {
            case null =>
              `out₅`.burpNull()
            case scala.None =>
              `out₅`.burpNull()
            case scala.Some(v) =>
              val `vv₁₀`: scala.Int = `v₁₂`.asInstanceOf[scala.Int]
              `out₅`.value(`vv₁₀`)
          }
        }
    }
    if (`in₅`.j.==(null)) `out₅`.burpNull() else ()
    `in₅`.j match {
      case scala.Left(v) =>
        {
          `out₅`.label("j")
          `v₁₃`.asInstanceOf[scala.Option[scala.Int]] match {
            case null =>
              `out₅`.burpNull()
            case scala.None =>
              `out₅`.burpNull()
            case scala.Some(v) =>
              val `vv₁₁`: scala.Int = `v₁₄`.asInstanceOf[scala.Int]
              `out₅`.value(`vv₁₁`)
          }
        }
      case scala.Right(v) =>
        {
          `out₅`.label("j")
          `out₅`.value(`v₁₅`.asInstanceOf[scala.Int])
        }
    }
    `out₅`.endObject()
  }
  def r1(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.Person = {
    var _name: java.lang.String = ""
    var _age: scala.Int = 0
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₆`.expectFirstObjectField(__co_blocke_scalajack_json_misc_Person_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.Person] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _name = `in₆`.expectString()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("name"), `in₆`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _age = `in₆`.expectInt()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("age"), `in₆`)
          case _ =>
            `in₆`.skipValue()
        }
        maybeFieldNum = `in₆`.expectObjectField(__co_blocke_scalajack_json_misc_Person_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.misc.Person(_name, _age) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("name", "age")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₆`)
    }
  }
  def r0(`in₇`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.OptionHolder[scala.Int] = {
    var _a: scala.Option[scala.Int] = scala.None
    var _b: scala.Tuple2[scala.Option[scala.Int], scala.Predef.String] = null
    var _c: scala.collection.immutable.List[scala.Option[scala.Int]] = null
    var _d: scala.collection.immutable.Map[scala.Int, scala.Option[scala.Int]] = null
    var _e: scala.Int | scala.Option[scala.Int] = scala.None
    var _f: scala.Option[scala.Int] | scala.Int = scala.None
    var _g: scala.Option[scala.Option[scala.Int]] = scala.None
    var _h: scala.Option[co.blocke.scalajack.json.misc.Person] = scala.None
    var _i: scala.util.Either[scala.Int, scala.Option[scala.Int]] = scala.Predef.augmentString("r").foldRight[scala.Any]((scala.None: scala.Any))(((c: scala.Char, acc: scala.Any) => if (c.==('r')) scala.Right.apply[scala.Nothing, scala.Any](acc) else scala.Left.apply[scala.Any, scala.Nothing](acc))).asInstanceOf[scala.util.Either[scala.Int, scala.Option[scala.Int]]]
    var _j: scala.util.Either[scala.Option[scala.Int], scala.Int] = scala.Predef.augmentString("l").foldRight[scala.Any]((scala.None: scala.Any))(((`c₂`: scala.Char, `acc₂`: scala.Any) => if (`c₂`.==('r')) scala.Right.apply[scala.Nothing, scala.Any](`acc₂`) else scala.Left.apply[scala.Any, scala.Nothing](`acc₂`))).asInstanceOf[scala.util.Either[scala.Option[scala.Int], scala.Int]]
    var `required₂`: scala.Int = 1023
    var `maybeFieldNum₂`: scala.Option[scala.Int] = `in₇`.expectFirstObjectField(__co_blocke_scalajack_json_misc_OptionHolder_fields)
    if (`maybeFieldNum₂`.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.OptionHolder[scala.Int]] else {
      while (`maybeFieldNum₂`.isDefined) {
        `maybeFieldNum₂`.get match {
          case 0 =>
            if (`required₂`.&(1).!=(0)) {
              `required₂` = `required₂`.^(1)
              _a = if (`in₇`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₇`.expectInt())
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₇`)
          case 1 =>
            if (`required₂`.&(2).!=(0)) {
              `required₂` = `required₂`.^(2)
              _b = if (`in₇`.expectNull()) null else {
                `in₇`.expectToken('[')
                val tv: scala.Tuple2[scala.Option[scala.Int], scala.Predef.String] = new scala.Tuple2[scala.Option[scala.Int], scala.Predef.String][scala.Option[scala.Int], java.lang.String](if (`in₇`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₇`.expectInt()), {
                  `in₇`.expectToken(',')
                  `in₇`.expectString()
                })
                `in₇`.expectToken(']')

                (tv: scala.Tuple2[scala.Option[scala.Int], scala.Predef.String])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₇`)
          case 2 =>
            if (`required₂`.&(4).!=(0)) {
              `required₂` = `required₂`.^(4)
              _c = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.Option[scala.Int]] = `in₇`.expectArray[scala.Option[scala.Int]]((() => if (`in₇`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₇`.expectInt())))

                (if (parsedArray.!=(null)) parsedArray.toList else null: scala.collection.immutable.List[scala.Option[scala.Int]])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c"), `in₇`)
          case 3 =>
            if (`required₂`.&(8).!=(0)) {
              `required₂` = `required₂`.^(8)
              _d = if (`in₇`.expectNull()) null else {
                `in₇`.expectToken('{')
                `in₇`.parseMap[scala.Int, scala.Option[scala.Int]]((() => scala.Predef.augmentString(`in₇`.expectString()).toInt), (() => if (`in₇`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₇`.expectInt())), scala.Predef.Map.empty[scala.Int, scala.Option[scala.Int]], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d"), `in₇`)
          case 4 =>
            if (`required₂`.&(16).!=(0)) {
              `required₂` = `required₂`.^(16)
              _e = {
                val mark: scala.Int = `in₇`.pos
                scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                  case scala.util.Success(lval) =>
                    (lval: scala.Int)
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(mark)
                    scala.util.Try.apply[scala.Option[scala.Int]](if (`in₇`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₇`.expectInt())) match {
                      case scala.util.Success(rval) =>
                        (rval: scala.Option[scala.Int])
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("e"), `in₇`)
          case 5 =>
            if (`required₂`.&(32).!=(0)) {
              `required₂` = `required₂`.^(32)
              _f = {
                val `mark₂`: scala.Int = `in₇`.pos
                scala.util.Try.apply[scala.Option[scala.Int]](if (`in₇`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₇`.expectInt())) match {
                  case scala.util.Success(lval) =>
                    (`lval₂`: scala.Option[scala.Int])
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(`mark₂`)
                    scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                      case scala.util.Success(rval) =>
                        (`rval₂`: scala.Int)
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f"), `in₇`)
          case 6 =>
            if (`required₂`.&(64).!=(0)) {
              `required₂` = `required₂`.^(64)
              _g = if (`in₇`.expectNull()) scala.None else scala.Some.apply[scala.Option[scala.Int]](if (`in₇`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₇`.expectInt()))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("g"), `in₇`)
          case 7 =>
            if (`required₂`.&(128).!=(0)) {
              `required₂` = `required₂`.^(128)
              _h = if (`in₇`.expectNull()) scala.None else scala.Some.apply[co.blocke.scalajack.json.misc.Person](r1(`in₇`))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("h"), `in₇`)
          case 8 =>
            if (`required₂`.&(256).!=(0)) {
              `required₂` = `required₂`.^(256)
              _i = {
                val `mark₃`: scala.Int = `in₇`.pos
                if (`in₇`.expectNull()) null else scala.util.Try.apply[scala.Option[scala.Int]](if (`in₇`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₇`.expectInt())) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Option[scala.Int]](`rval₃`)
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(`mark₃`)
                    scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[scala.Int, scala.Nothing](`lval₃`)
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i"), `in₇`)
          case 9 =>
            if (`required₂`.&(512).!=(0)) {
              `required₂` = `required₂`.^(512)
              _j = {
                val `mark₄`: scala.Int = `in₇`.pos
                if (`in₇`.expectNull()) null else scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Int](`rval₄`)
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(`mark₄`)
                    scala.util.Try.apply[scala.Option[scala.Int]](if (`in₇`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₇`.expectInt())) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[scala.Option[scala.Int], scala.Nothing](`lval₄`)
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("j"), `in₇`)
          case _ =>
            `in₇`.skipValue()
        }
        `maybeFieldNum₂` = `in₇`.expectObjectField(__co_blocke_scalajack_json_misc_OptionHolder_fields)
      }
      if (`required₂`.&(14).==(0)) new co.blocke.scalajack.json.misc.OptionHolder[scala.Int][scala.Int](_a, _b, _c, _d, _e, _f, _g, _h, _i, _j) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(`required₂`.&(14)))), `in₇`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.OptionHolder[scala.Int]] {
    def encodeValue(`in₈`: co.blocke.scalajack.json.misc.OptionHolder[scala.Int], `out₆`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₈`, `out₆`)
    def decodeValue(`in₉`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.OptionHolder[scala.Int] = r0(`in₉`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.OptionHolder[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_EitherRecipe_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.EitherRecipe[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    if (in.a.==(null)) out.burpNull() else ()
    in.a match {
      case scala.Left(v) =>
        {
          out.label("a")
          out.value(v.asInstanceOf[scala.Boolean])
        }
      case scala.Right(v) =>
        {
          if (`v₂`.asInstanceOf[scala.util.Either[scala.Option[scala.Int], scala.Predef.String]].==(null)) out.burpNull() else ()
          `v₂`.asInstanceOf[scala.util.Either[scala.Option[scala.Int], scala.Predef.String]] match {
            case scala.Left(v) =>
              `v₃`.asInstanceOf[scala.Option[scala.Int]] match {
                case scala.None =>
                  ()
                case scala.Some(v) =>
                  {
                    out.label("a")
                    out.value(`v₄`)
                  }
              }
            case scala.Right(v) =>
              {
                out.label("a")
                out.valueEscaped(`v₅`.asInstanceOf[java.lang.String])
              }
          }
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherRecipe[scala.Int] = {
    var _a: scala.util.Either[scala.Boolean, scala.util.Either[scala.Option[scala.Int], scala.Predef.String]] = scala.Predef.augmentString("rl").foldRight[scala.Any]((scala.None: scala.Any))(((c: scala.Char, acc: scala.Any) => if (c.==('r')) scala.Right.apply[scala.Nothing, scala.Any](acc) else scala.Left.apply[scala.Any, scala.Nothing](acc))).asInstanceOf[scala.util.Either[scala.Boolean, scala.util.Either[scala.Option[scala.Int], scala.Predef.String]]]
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_EitherRecipe_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.EitherRecipe[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val mark: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[scala.util.Either[scala.Option[scala.Int], scala.Predef.String]]({
                  val `mark₂`: scala.Int = `in₂`.pos
                  if (`in₂`.expectNull()) null else scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                    case scala.util.Success(rval) =>
                      scala.Right.apply[scala.Nothing, java.lang.String](rval)
                    case scala.util.Failure(f) =>
                      `in₂`.revertToPos(`mark₂`)
                      scala.util.Try.apply[scala.Option[scala.Int]](if (`in₂`.expectNull()) null else scala.Some.apply[scala.Int](`in₂`.expectInt())) match {
                        case scala.util.Success(lval) =>
                          scala.Left.apply[scala.Option[scala.Int], scala.Nothing](lval)
                        case scala.util.Failure(_) =>
                          `in₂`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                      }
                  }
                }) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.util.Either[scala.Option[scala.Int], scala.Predef.String]](`rval₂`)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(mark)
                    scala.util.Try.apply[scala.Boolean](`in₂`.expectBoolean()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[scala.Boolean, scala.Nothing](`lval₂`)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_EitherRecipe_fields)
      }
      if (required.&(0).==(0)) new co.blocke.scalajack.json.misc.EitherRecipe[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(0)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherRecipe[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.EitherRecipe[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherRecipe[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherRecipe[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_EitherRecipe_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.EitherRecipe[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    if (in.a.==(null)) out.burpNull() else ()
    in.a match {
      case scala.Left(v) =>
        {
          out.label("a")
          out.value(v.asInstanceOf[scala.Boolean])
        }
      case scala.Right(v) =>
        {
          if (`v₂`.asInstanceOf[scala.util.Either[scala.Option[scala.Int], scala.Predef.String]].==(null)) out.burpNull() else ()
          `v₂`.asInstanceOf[scala.util.Either[scala.Option[scala.Int], scala.Predef.String]] match {
            case scala.Left(v) =>
              `v₃`.asInstanceOf[scala.Option[scala.Int]] match {
                case scala.None =>
                  ()
                case scala.Some(v) =>
                  {
                    out.label("a")
                    out.value(`v₄`)
                  }
              }
            case scala.Right(v) =>
              {
                out.label("a")
                out.valueEscaped(`v₅`.asInstanceOf[java.lang.String])
              }
          }
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherRecipe[scala.Int] = {
    var _a: scala.util.Either[scala.Boolean, scala.util.Either[scala.Option[scala.Int], scala.Predef.String]] = scala.Predef.augmentString("rl").foldRight[scala.Any]((scala.None: scala.Any))(((c: scala.Char, acc: scala.Any) => if (c.==('r')) scala.Right.apply[scala.Nothing, scala.Any](acc) else scala.Left.apply[scala.Any, scala.Nothing](acc))).asInstanceOf[scala.util.Either[scala.Boolean, scala.util.Either[scala.Option[scala.Int], scala.Predef.String]]]
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_EitherRecipe_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.EitherRecipe[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val mark: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[scala.util.Either[scala.Option[scala.Int], scala.Predef.String]]({
                  val `mark₂`: scala.Int = `in₂`.pos
                  if (`in₂`.expectNull()) null else scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                    case scala.util.Success(rval) =>
                      scala.Right.apply[scala.Nothing, java.lang.String](rval)
                    case scala.util.Failure(f) =>
                      `in₂`.revertToPos(`mark₂`)
                      scala.util.Try.apply[scala.Option[scala.Int]](if (`in₂`.expectNull()) null else scala.Some.apply[scala.Int](`in₂`.expectInt())) match {
                        case scala.util.Success(lval) =>
                          scala.Left.apply[scala.Option[scala.Int], scala.Nothing](lval)
                        case scala.util.Failure(_) =>
                          `in₂`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                      }
                  }
                }) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.util.Either[scala.Option[scala.Int], scala.Predef.String]](`rval₂`)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(mark)
                    scala.util.Try.apply[scala.Boolean](`in₂`.expectBoolean()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[scala.Boolean, scala.Nothing](`lval₂`)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_EitherRecipe_fields)
      }
      if (required.&(0).==(0)) new co.blocke.scalajack.json.misc.EitherRecipe[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(0)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherRecipe[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.EitherRecipe[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherRecipe[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherRecipe[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_EitherRecipe_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.EitherRecipe[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    if (in.a.==(null)) out.burpNull() else ()
    in.a match {
      case scala.Left(v) =>
        {
          out.label("a")
          out.value(v.asInstanceOf[scala.Boolean])
        }
      case scala.Right(v) =>
        {
          if (`v₂`.asInstanceOf[scala.util.Either[scala.Option[scala.Int], scala.Predef.String]].==(null)) out.burpNull() else ()
          `v₂`.asInstanceOf[scala.util.Either[scala.Option[scala.Int], scala.Predef.String]] match {
            case scala.Left(v) =>
              {
                out.label("a")
                `v₃`.asInstanceOf[scala.Option[scala.Int]] match {
                  case null =>
                    out.burpNull()
                  case scala.None =>
                    out.burpNull()
                  case scala.Some(v) =>
                    val vv: scala.Int = `v₄`.asInstanceOf[scala.Int]
                    out.value(vv)
                }
              }
            case scala.Right(v) =>
              {
                out.label("a")
                out.valueEscaped(`v₅`.asInstanceOf[java.lang.String])
              }
          }
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherRecipe[scala.Int] = {
    var _a: scala.util.Either[scala.Boolean, scala.util.Either[scala.Option[scala.Int], scala.Predef.String]] = scala.Predef.augmentString("rl").foldRight[scala.Any]((scala.None: scala.Any))(((c: scala.Char, acc: scala.Any) => if (c.==('r')) scala.Right.apply[scala.Nothing, scala.Any](acc) else scala.Left.apply[scala.Any, scala.Nothing](acc))).asInstanceOf[scala.util.Either[scala.Boolean, scala.util.Either[scala.Option[scala.Int], scala.Predef.String]]]
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_EitherRecipe_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.EitherRecipe[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val mark: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[scala.util.Either[scala.Option[scala.Int], scala.Predef.String]]({
                  val `mark₂`: scala.Int = `in₂`.pos
                  if (`in₂`.expectNull()) null else scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                    case scala.util.Success(rval) =>
                      scala.Right.apply[scala.Nothing, java.lang.String](rval)
                    case scala.util.Failure(f) =>
                      `in₂`.revertToPos(`mark₂`)
                      scala.util.Try.apply[scala.Option[scala.Int]](if (`in₂`.expectNull()) scala.None else scala.Some.apply[scala.Int](`in₂`.expectInt())) match {
                        case scala.util.Success(lval) =>
                          scala.Left.apply[scala.Option[scala.Int], scala.Nothing](lval)
                        case scala.util.Failure(_) =>
                          `in₂`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                      }
                  }
                }) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.util.Either[scala.Option[scala.Int], scala.Predef.String]](`rval₂`)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(mark)
                    scala.util.Try.apply[scala.Boolean](`in₂`.expectBoolean()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[scala.Boolean, scala.Nothing](`lval₂`)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_EitherRecipe_fields)
      }
      if (required.&(0).==(0)) new co.blocke.scalajack.json.misc.EitherRecipe[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(0)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherRecipe[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.EitherRecipe[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherRecipe[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherRecipe[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_Person_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("name", "age")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  val __co_blocke_scalajack_json_misc_OptionalHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.Tuple2[java.util.Optional[scala.Int], scala.Predef.String], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    in._1.asInstanceOf[java.util.Optional[scala.Int]] match {
      case null =>
        out.burpNull()
      case o if o.isEmpty() =>
        out.burpNull()
      case o =>
        val vv: scala.Int = `o₂`.get().asInstanceOf[scala.Int]
        out.value(vv)
    }
    out.valueEscaped(in._2)
    out.endArray()
  }
  def w2(`in₂`: scala.collection.immutable.List[java.util.Optional[scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startArray()
    `in₂`.foreach[scala.Unit](((i: java.util.Optional[scala.Int]) => i.asInstanceOf[java.util.Optional[scala.Int]] match {
      case null =>
        `out₂`.burpNull()
      case o if `o₃`.isEmpty() =>
        ()
      case o =>
        val `vv₂`: scala.Int = `o₄`.get().asInstanceOf[scala.Int]
        `out₂`.value(`vv₂`)
    }))
    `out₂`.endArray()
  }
  def w3(`in₃`: scala.collection.immutable.Map[scala.Int, java.util.Optional[scala.Int]], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `in₃`.foreach[scala.Unit](((x$1: scala.Tuple2[scala.Int, java.util.Optional[scala.Int]]) => x$1 match {
      case scala.Tuple2(key, value) =>
        if (value.isEmpty().unary_!) {
          `out₃`.maybeComma()
          `out₃`.valueStringified(scala.Int.int2long(key))
          `out₃`.colon()
          `out₃`.value(value.get())
        } else ()
    }))
    `out₃`.endObject()
  }
  def w4(`in₄`: co.blocke.scalajack.json.misc.Person, `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₄`.==(null)) `out₄`.burpNull() else {
    `out₄`.startObject()
    `out₄`.label("name")
    `out₄`.valueEscaped(`in₄`.name)
    `out₄`.label("age")
    `out₄`.value(`in₄`.age)
    `out₄`.endObject()
  }
  def w0(`in₅`: co.blocke.scalajack.json.misc.OptionalHolder[scala.Int], `out₅`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₅`.==(null)) `out₅`.burpNull() else {
    `out₅`.startObject()
    if (`in₅`.a.isEmpty().unary_!) {
      `out₅`.label("a")
      `out₅`.value(`in₅`.a.get())
    } else ()
    `out₅`.label("b")
    w1(`in₅`.b, `out₅`)
    `out₅`.label("c")
    w2(`in₅`.c, `out₅`)
    `out₅`.label("d")
    w3(`in₅`.d, `out₅`)
    if (`in₅`.e.==(null)) `out₅`.burpNull() else {
      `out₅`.mark()
      scala.util.Try.apply[scala.Unit](if (`in₅`.e.asInstanceOf[java.util.Optional[scala.Int]].isEmpty().unary_!) {
        `out₅`.label("e")
        `out₅`.value(`in₅`.e.asInstanceOf[java.util.Optional[scala.Int]].get())
      } else ()) match {
        case scala.util.Success(_) =>
          ()
        case scala.util.Failure(f) =>
          `out₅`.revert()
          {
            `out₅`.label("e")
            `out₅`.value(`in₅`.e.asInstanceOf[scala.Int])
          }
      }
    }
    if (`in₅`.f.==(null)) `out₅`.burpNull() else {
      `out₅`.mark()
      scala.util.Try.apply[scala.Unit]({
        `out₅`.label("f")
        `out₅`.value(`in₅`.f.asInstanceOf[scala.Int])
      }) match {
        case scala.util.Success(_) =>
          ()
        case scala.util.Failure(f) =>
          `out₅`.revert()
          if (`in₅`.f.asInstanceOf[java.util.Optional[scala.Int]].isEmpty().unary_!) {
            `out₅`.label("f")
            `out₅`.value(`in₅`.f.asInstanceOf[java.util.Optional[scala.Int]].get())
          } else ()
      }
    }
    if (`in₅`.g.isEmpty().unary_!) if (`in₅`.g.get().isEmpty().unary_!) {
      `out₅`.label("g")
      `out₅`.value(`in₅`.g.get().get())
    } else () else ()
    if (`in₅`.h.isEmpty().unary_!) {
      `out₅`.label("h")
      w4(`in₅`.h.get(), `out₅`)
    } else ()
    if (`in₅`.i.==(null)) `out₅`.burpNull() else ()
    `in₅`.i match {
      case scala.Left(v) =>
        {
          `out₅`.label("i")
          `out₅`.value(v.asInstanceOf[scala.Int])
        }
      case scala.Right(v) =>
        if (`v₂`.asInstanceOf[java.util.Optional[scala.Int]].isEmpty().unary_!) {
          `out₅`.label("i")
          `out₅`.value(`v₂`.asInstanceOf[java.util.Optional[scala.Int]].get())
        } else ()
    }
    if (`in₅`.j.==(null)) `out₅`.burpNull() else ()
    `in₅`.j match {
      case scala.Left(v) =>
        if (`v₃`.asInstanceOf[java.util.Optional[scala.Int]].isEmpty().unary_!) {
          `out₅`.label("j")
          `out₅`.value(`v₃`.asInstanceOf[java.util.Optional[scala.Int]].get())
        } else ()
      case scala.Right(v) =>
        {
          `out₅`.label("j")
          `out₅`.value(`v₄`.asInstanceOf[scala.Int])
        }
    }
    `out₅`.endObject()
  }
  def r1(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.Person = {
    var _name: java.lang.String = ""
    var _age: scala.Int = 0
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₆`.expectFirstObjectField(__co_blocke_scalajack_json_misc_Person_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.Person] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _name = `in₆`.expectString()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("name"), `in₆`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _age = `in₆`.expectInt()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("age"), `in₆`)
          case _ =>
            `in₆`.skipValue()
        }
        maybeFieldNum = `in₆`.expectObjectField(__co_blocke_scalajack_json_misc_Person_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.misc.Person(_name, _age) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("name", "age")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₆`)
    }
  }
  def r0(`in₇`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.OptionalHolder[scala.Int] = {
    var _a: java.util.Optional[scala.Int] = java.util.Optional.empty[java.lang.Object]().asInstanceOf[java.util.Optional[scala.Int]]
    var _b: scala.Tuple2[java.util.Optional[scala.Int], scala.Predef.String] = null
    var _c: scala.collection.immutable.List[java.util.Optional[scala.Int]] = null
    var _d: scala.collection.immutable.Map[scala.Int, java.util.Optional[scala.Int]] = null
    var _e: scala.Int | java.util.Optional[scala.Int] = java.util.Optional.empty[java.lang.Object]().asInstanceOf[scala.Int | java.util.Optional[scala.Int]]
    var _f: java.util.Optional[scala.Int] | scala.Int = java.util.Optional.empty[java.lang.Object]().asInstanceOf[java.util.Optional[scala.Int] | scala.Int]
    var _g: java.util.Optional[java.util.Optional[scala.Int]] = java.util.Optional.empty[java.lang.Object]().asInstanceOf[java.util.Optional[java.util.Optional[scala.Int]]]
    var _h: java.util.Optional[co.blocke.scalajack.json.misc.Person] = java.util.Optional.empty[java.lang.Object]().asInstanceOf[java.util.Optional[co.blocke.scalajack.json.misc.Person]]
    var _i: scala.util.Either[scala.Int, java.util.Optional[scala.Int]] = scala.Predef.augmentString("r").foldRight[scala.Any]((java.util.Optional.empty[java.lang.Object](): scala.Any))(((c: scala.Char, acc: scala.Any) => if (c.==('r')) scala.Right.apply[scala.Nothing, scala.Any](acc) else scala.Left.apply[scala.Any, scala.Nothing](acc))).asInstanceOf[scala.util.Either[scala.Int, java.util.Optional[scala.Int]]]
    var _j: scala.util.Either[java.util.Optional[scala.Int], scala.Int] = scala.Predef.augmentString("l").foldRight[scala.Any]((java.util.Optional.empty[java.lang.Object](): scala.Any))(((`c₂`: scala.Char, `acc₂`: scala.Any) => if (`c₂`.==('r')) scala.Right.apply[scala.Nothing, scala.Any](`acc₂`) else scala.Left.apply[scala.Any, scala.Nothing](`acc₂`))).asInstanceOf[scala.util.Either[java.util.Optional[scala.Int], scala.Int]]
    var `required₂`: scala.Int = 1023
    var `maybeFieldNum₂`: scala.Option[scala.Int] = `in₇`.expectFirstObjectField(__co_blocke_scalajack_json_misc_OptionalHolder_fields)
    if (`maybeFieldNum₂`.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.OptionalHolder[scala.Int]] else {
      while (`maybeFieldNum₂`.isDefined) {
        `maybeFieldNum₂`.get match {
          case 0 =>
            if (`required₂`.&(1).!=(0)) {
              `required₂` = `required₂`.^(1)
              _a = if (`in₇`.expectNull()) null else java.util.Optional.of[scala.Int](`in₇`.expectInt())
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₇`)
          case 1 =>
            if (`required₂`.&(2).!=(0)) {
              `required₂` = `required₂`.^(2)
              _b = if (`in₇`.expectNull()) null else {
                `in₇`.expectToken('[')
                val tv: scala.Tuple2[java.util.Optional[scala.Int], scala.Predef.String] = new scala.Tuple2[java.util.Optional[scala.Int], scala.Predef.String][java.util.Optional[scala.Int], java.lang.String](if (`in₇`.expectNull()) java.util.Optional.empty[scala.Int]() else java.util.Optional.of[scala.Int](`in₇`.expectInt()), {
                  `in₇`.expectToken(',')
                  `in₇`.expectString()
                })
                `in₇`.expectToken(']')

                (tv: scala.Tuple2[java.util.Optional[scala.Int], scala.Predef.String])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₇`)
          case 2 =>
            if (`required₂`.&(4).!=(0)) {
              `required₂` = `required₂`.^(4)
              _c = {
                val parsedArray: scala.collection.mutable.ListBuffer[java.util.Optional[scala.Int]] = `in₇`.expectArray[java.util.Optional[scala.Int]]((() => if (`in₇`.expectNull()) null else java.util.Optional.of[scala.Int](`in₇`.expectInt())))

                (if (parsedArray.!=(null)) parsedArray.toList else null: scala.collection.immutable.List[java.util.Optional[scala.Int]])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c"), `in₇`)
          case 3 =>
            if (`required₂`.&(8).!=(0)) {
              `required₂` = `required₂`.^(8)
              _d = if (`in₇`.expectNull()) null else {
                `in₇`.expectToken('{')
                `in₇`.parseMap[scala.Int, java.util.Optional[scala.Int]]((() => scala.Predef.augmentString(`in₇`.expectString()).toInt), (() => if (`in₇`.expectNull()) null else java.util.Optional.of[scala.Int](`in₇`.expectInt())), scala.Predef.Map.empty[scala.Int, java.util.Optional[scala.Int]], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d"), `in₇`)
          case 4 =>
            if (`required₂`.&(16).!=(0)) {
              `required₂` = `required₂`.^(16)
              _e = {
                val mark: scala.Int = `in₇`.pos
                scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                  case scala.util.Success(lval) =>
                    (lval: scala.Int)
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(mark)
                    scala.util.Try.apply[java.util.Optional[scala.Int]](if (`in₇`.expectNull()) java.util.Optional.empty[scala.Int]() else java.util.Optional.of[scala.Int](`in₇`.expectInt())) match {
                      case scala.util.Success(rval) =>
                        (rval: java.util.Optional[scala.Int])
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("e"), `in₇`)
          case 5 =>
            if (`required₂`.&(32).!=(0)) {
              `required₂` = `required₂`.^(32)
              _f = {
                val `mark₂`: scala.Int = `in₇`.pos
                scala.util.Try.apply[java.util.Optional[scala.Int]](if (`in₇`.expectNull()) java.util.Optional.empty[scala.Int]() else java.util.Optional.of[scala.Int](`in₇`.expectInt())) match {
                  case scala.util.Success(lval) =>
                    (`lval₂`: java.util.Optional[scala.Int])
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(`mark₂`)
                    scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                      case scala.util.Success(rval) =>
                        (`rval₂`: scala.Int)
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f"), `in₇`)
          case 6 =>
            if (`required₂`.&(64).!=(0)) {
              `required₂` = `required₂`.^(64)
              _g = if (`in₇`.expectNull()) null else java.util.Optional.of[java.util.Optional[scala.Int]](if (`in₇`.expectNull()) null else java.util.Optional.of[scala.Int](`in₇`.expectInt()))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("g"), `in₇`)
          case 7 =>
            if (`required₂`.&(128).!=(0)) {
              `required₂` = `required₂`.^(128)
              _h = if (`in₇`.expectNull()) null else java.util.Optional.of[co.blocke.scalajack.json.misc.Person](r1(`in₇`))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("h"), `in₇`)
          case 8 =>
            if (`required₂`.&(256).!=(0)) {
              `required₂` = `required₂`.^(256)
              _i = {
                val `mark₃`: scala.Int = `in₇`.pos
                if (`in₇`.expectNull()) null else scala.util.Try.apply[java.util.Optional[scala.Int]](if (`in₇`.expectNull()) null else java.util.Optional.of[scala.Int](`in₇`.expectInt())) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, java.util.Optional[scala.Int]](`rval₃`)
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(`mark₃`)
                    scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[scala.Int, scala.Nothing](`lval₃`)
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i"), `in₇`)
          case 9 =>
            if (`required₂`.&(512).!=(0)) {
              `required₂` = `required₂`.^(512)
              _j = {
                val `mark₄`: scala.Int = `in₇`.pos
                if (`in₇`.expectNull()) null else scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Int](`rval₄`)
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(`mark₄`)
                    scala.util.Try.apply[java.util.Optional[scala.Int]](if (`in₇`.expectNull()) null else java.util.Optional.of[scala.Int](`in₇`.expectInt())) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[java.util.Optional[scala.Int], scala.Nothing](`lval₄`)
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("j"), `in₇`)
          case _ =>
            `in₇`.skipValue()
        }
        `maybeFieldNum₂` = `in₇`.expectObjectField(__co_blocke_scalajack_json_misc_OptionalHolder_fields)
      }
      if (`required₂`.&(14).==(0)) new co.blocke.scalajack.json.misc.OptionalHolder[scala.Int][scala.Int](_a, _b, _c, _d, _e, _f, _g, _h, _i, _j) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(`required₂`.&(14)))), `in₇`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.OptionalHolder[scala.Int]] {
    def encodeValue(`in₈`: co.blocke.scalajack.json.misc.OptionalHolder[scala.Int], `out₆`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₈`, `out₆`)
    def decodeValue(`in₉`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.OptionalHolder[scala.Int] = r0(`in₉`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.OptionalHolder[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_Person_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("name", "age")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  val __co_blocke_scalajack_json_misc_OptionalHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.Tuple2[java.util.Optional[scala.Int], scala.Predef.String], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    in._1.asInstanceOf[java.util.Optional[scala.Int]] match {
      case null =>
        out.burpNull()
      case o if o.isEmpty() =>
        out.burpNull()
      case o =>
        val vv: scala.Int = `o₂`.get().asInstanceOf[scala.Int]
        out.value(vv)
    }
    out.valueEscaped(in._2)
    out.endArray()
  }
  def w2(`in₂`: scala.collection.immutable.List[java.util.Optional[scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startArray()
    `in₂`.foreach[scala.Unit](((i: java.util.Optional[scala.Int]) => i.asInstanceOf[java.util.Optional[scala.Int]] match {
      case null =>
        `out₂`.burpNull()
      case o if `o₃`.isEmpty() =>
        ()
      case o =>
        val `vv₂`: scala.Int = `o₄`.get().asInstanceOf[scala.Int]
        `out₂`.value(`vv₂`)
    }))
    `out₂`.endArray()
  }
  def w3(`in₃`: scala.collection.immutable.Map[scala.Int, java.util.Optional[scala.Int]], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `in₃`.foreach[scala.Unit](((x$1: scala.Tuple2[scala.Int, java.util.Optional[scala.Int]]) => x$1 match {
      case scala.Tuple2(key, value) =>
        if (value.isEmpty().unary_!) {
          `out₃`.maybeComma()
          `out₃`.valueStringified(scala.Int.int2long(key))
          `out₃`.colon()
          `out₃`.value(value.get())
        } else ()
    }))
    `out₃`.endObject()
  }
  def w4(`in₄`: co.blocke.scalajack.json.misc.Person, `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₄`.==(null)) `out₄`.burpNull() else {
    `out₄`.startObject()
    `out₄`.label("name")
    `out₄`.valueEscaped(`in₄`.name)
    `out₄`.label("age")
    `out₄`.value(`in₄`.age)
    `out₄`.endObject()
  }
  def w0(`in₅`: co.blocke.scalajack.json.misc.OptionalHolder[scala.Int], `out₅`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₅`.==(null)) `out₅`.burpNull() else {
    `out₅`.startObject()
    if (`in₅`.a.isEmpty().unary_!) {
      `out₅`.label("a")
      `out₅`.value(`in₅`.a.get())
    } else ()
    `out₅`.label("b")
    w1(`in₅`.b, `out₅`)
    `out₅`.label("c")
    w2(`in₅`.c, `out₅`)
    `out₅`.label("d")
    w3(`in₅`.d, `out₅`)
    if (`in₅`.e.==(null)) `out₅`.burpNull() else {
      `out₅`.mark()
      scala.util.Try.apply[scala.Unit](if (`in₅`.e.asInstanceOf[java.util.Optional[scala.Int]].isEmpty().unary_!) {
        `out₅`.label("e")
        `out₅`.value(`in₅`.e.asInstanceOf[java.util.Optional[scala.Int]].get())
      } else ()) match {
        case scala.util.Success(_) =>
          ()
        case scala.util.Failure(f) =>
          `out₅`.revert()
          {
            `out₅`.label("e")
            `out₅`.value(`in₅`.e.asInstanceOf[scala.Int])
          }
      }
    }
    if (`in₅`.f.==(null)) `out₅`.burpNull() else {
      `out₅`.mark()
      scala.util.Try.apply[scala.Unit]({
        `out₅`.label("f")
        `out₅`.value(`in₅`.f.asInstanceOf[scala.Int])
      }) match {
        case scala.util.Success(_) =>
          ()
        case scala.util.Failure(f) =>
          `out₅`.revert()
          if (`in₅`.f.asInstanceOf[java.util.Optional[scala.Int]].isEmpty().unary_!) {
            `out₅`.label("f")
            `out₅`.value(`in₅`.f.asInstanceOf[java.util.Optional[scala.Int]].get())
          } else ()
      }
    }
    if (`in₅`.g.isEmpty().unary_!) if (`in₅`.g.get().isEmpty().unary_!) {
      `out₅`.label("g")
      `out₅`.value(`in₅`.g.get().get())
    } else () else ()
    if (`in₅`.h.isEmpty().unary_!) {
      `out₅`.label("h")
      w4(`in₅`.h.get(), `out₅`)
    } else ()
    if (`in₅`.i.==(null)) `out₅`.burpNull() else ()
    `in₅`.i match {
      case scala.Left(v) =>
        {
          `out₅`.label("i")
          `out₅`.value(v.asInstanceOf[scala.Int])
        }
      case scala.Right(v) =>
        if (`v₂`.asInstanceOf[java.util.Optional[scala.Int]].isEmpty().unary_!) {
          `out₅`.label("i")
          `out₅`.value(`v₂`.asInstanceOf[java.util.Optional[scala.Int]].get())
        } else ()
    }
    if (`in₅`.j.==(null)) `out₅`.burpNull() else ()
    `in₅`.j match {
      case scala.Left(v) =>
        if (`v₃`.asInstanceOf[java.util.Optional[scala.Int]].isEmpty().unary_!) {
          `out₅`.label("j")
          `out₅`.value(`v₃`.asInstanceOf[java.util.Optional[scala.Int]].get())
        } else ()
      case scala.Right(v) =>
        {
          `out₅`.label("j")
          `out₅`.value(`v₄`.asInstanceOf[scala.Int])
        }
    }
    `out₅`.endObject()
  }
  def r1(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.Person = {
    var _name: java.lang.String = ""
    var _age: scala.Int = 0
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₆`.expectFirstObjectField(__co_blocke_scalajack_json_misc_Person_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.Person] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _name = `in₆`.expectString()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("name"), `in₆`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _age = `in₆`.expectInt()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("age"), `in₆`)
          case _ =>
            `in₆`.skipValue()
        }
        maybeFieldNum = `in₆`.expectObjectField(__co_blocke_scalajack_json_misc_Person_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.misc.Person(_name, _age) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("name", "age")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₆`)
    }
  }
  def r0(`in₇`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.OptionalHolder[scala.Int] = {
    var _a: java.util.Optional[scala.Int] = java.util.Optional.empty[java.lang.Object]().asInstanceOf[java.util.Optional[scala.Int]]
    var _b: scala.Tuple2[java.util.Optional[scala.Int], scala.Predef.String] = null
    var _c: scala.collection.immutable.List[java.util.Optional[scala.Int]] = null
    var _d: scala.collection.immutable.Map[scala.Int, java.util.Optional[scala.Int]] = null
    var _e: scala.Int | java.util.Optional[scala.Int] = java.util.Optional.empty[java.lang.Object]().asInstanceOf[scala.Int | java.util.Optional[scala.Int]]
    var _f: java.util.Optional[scala.Int] | scala.Int = java.util.Optional.empty[java.lang.Object]().asInstanceOf[java.util.Optional[scala.Int] | scala.Int]
    var _g: java.util.Optional[java.util.Optional[scala.Int]] = java.util.Optional.empty[java.lang.Object]().asInstanceOf[java.util.Optional[java.util.Optional[scala.Int]]]
    var _h: java.util.Optional[co.blocke.scalajack.json.misc.Person] = java.util.Optional.empty[java.lang.Object]().asInstanceOf[java.util.Optional[co.blocke.scalajack.json.misc.Person]]
    var _i: scala.util.Either[scala.Int, java.util.Optional[scala.Int]] = scala.Predef.augmentString("r").foldRight[scala.Any]((java.util.Optional.empty[java.lang.Object](): scala.Any))(((c: scala.Char, acc: scala.Any) => if (c.==('r')) scala.Right.apply[scala.Nothing, scala.Any](acc) else scala.Left.apply[scala.Any, scala.Nothing](acc))).asInstanceOf[scala.util.Either[scala.Int, java.util.Optional[scala.Int]]]
    var _j: scala.util.Either[java.util.Optional[scala.Int], scala.Int] = scala.Predef.augmentString("l").foldRight[scala.Any]((java.util.Optional.empty[java.lang.Object](): scala.Any))(((`c₂`: scala.Char, `acc₂`: scala.Any) => if (`c₂`.==('r')) scala.Right.apply[scala.Nothing, scala.Any](`acc₂`) else scala.Left.apply[scala.Any, scala.Nothing](`acc₂`))).asInstanceOf[scala.util.Either[java.util.Optional[scala.Int], scala.Int]]
    var `required₂`: scala.Int = 1023
    var `maybeFieldNum₂`: scala.Option[scala.Int] = `in₇`.expectFirstObjectField(__co_blocke_scalajack_json_misc_OptionalHolder_fields)
    if (`maybeFieldNum₂`.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.OptionalHolder[scala.Int]] else {
      while (`maybeFieldNum₂`.isDefined) {
        `maybeFieldNum₂`.get match {
          case 0 =>
            if (`required₂`.&(1).!=(0)) {
              `required₂` = `required₂`.^(1)
              _a = if (`in₇`.expectNull()) null else java.util.Optional.of[scala.Int](`in₇`.expectInt())
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₇`)
          case 1 =>
            if (`required₂`.&(2).!=(0)) {
              `required₂` = `required₂`.^(2)
              _b = if (`in₇`.expectNull()) null else {
                `in₇`.expectToken('[')
                val tv: scala.Tuple2[java.util.Optional[scala.Int], scala.Predef.String] = new scala.Tuple2[java.util.Optional[scala.Int], scala.Predef.String][java.util.Optional[scala.Int], java.lang.String](if (`in₇`.expectNull()) java.util.Optional.empty[scala.Int]() else java.util.Optional.of[scala.Int](`in₇`.expectInt()), {
                  `in₇`.expectToken(',')
                  `in₇`.expectString()
                })
                `in₇`.expectToken(']')

                (tv: scala.Tuple2[java.util.Optional[scala.Int], scala.Predef.String])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₇`)
          case 2 =>
            if (`required₂`.&(4).!=(0)) {
              `required₂` = `required₂`.^(4)
              _c = {
                val parsedArray: scala.collection.mutable.ListBuffer[java.util.Optional[scala.Int]] = `in₇`.expectArray[java.util.Optional[scala.Int]]((() => if (`in₇`.expectNull()) null else java.util.Optional.of[scala.Int](`in₇`.expectInt())))

                (if (parsedArray.!=(null)) parsedArray.toList else null: scala.collection.immutable.List[java.util.Optional[scala.Int]])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c"), `in₇`)
          case 3 =>
            if (`required₂`.&(8).!=(0)) {
              `required₂` = `required₂`.^(8)
              _d = if (`in₇`.expectNull()) null else {
                `in₇`.expectToken('{')
                `in₇`.parseMap[scala.Int, java.util.Optional[scala.Int]]((() => scala.Predef.augmentString(`in₇`.expectString()).toInt), (() => if (`in₇`.expectNull()) null else java.util.Optional.of[scala.Int](`in₇`.expectInt())), scala.Predef.Map.empty[scala.Int, java.util.Optional[scala.Int]], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d"), `in₇`)
          case 4 =>
            if (`required₂`.&(16).!=(0)) {
              `required₂` = `required₂`.^(16)
              _e = {
                val mark: scala.Int = `in₇`.pos
                scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                  case scala.util.Success(lval) =>
                    (lval: scala.Int)
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(mark)
                    scala.util.Try.apply[java.util.Optional[scala.Int]](if (`in₇`.expectNull()) java.util.Optional.empty[scala.Int]() else java.util.Optional.of[scala.Int](`in₇`.expectInt())) match {
                      case scala.util.Success(rval) =>
                        (rval: java.util.Optional[scala.Int])
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("e"), `in₇`)
          case 5 =>
            if (`required₂`.&(32).!=(0)) {
              `required₂` = `required₂`.^(32)
              _f = {
                val `mark₂`: scala.Int = `in₇`.pos
                scala.util.Try.apply[java.util.Optional[scala.Int]](if (`in₇`.expectNull()) java.util.Optional.empty[scala.Int]() else java.util.Optional.of[scala.Int](`in₇`.expectInt())) match {
                  case scala.util.Success(lval) =>
                    (`lval₂`: java.util.Optional[scala.Int])
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(`mark₂`)
                    scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                      case scala.util.Success(rval) =>
                        (`rval₂`: scala.Int)
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f"), `in₇`)
          case 6 =>
            if (`required₂`.&(64).!=(0)) {
              `required₂` = `required₂`.^(64)
              _g = if (`in₇`.expectNull()) null else java.util.Optional.of[java.util.Optional[scala.Int]](if (`in₇`.expectNull()) null else java.util.Optional.of[scala.Int](`in₇`.expectInt()))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("g"), `in₇`)
          case 7 =>
            if (`required₂`.&(128).!=(0)) {
              `required₂` = `required₂`.^(128)
              _h = if (`in₇`.expectNull()) null else java.util.Optional.of[co.blocke.scalajack.json.misc.Person](r1(`in₇`))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("h"), `in₇`)
          case 8 =>
            if (`required₂`.&(256).!=(0)) {
              `required₂` = `required₂`.^(256)
              _i = {
                val `mark₃`: scala.Int = `in₇`.pos
                if (`in₇`.expectNull()) null else scala.util.Try.apply[java.util.Optional[scala.Int]](if (`in₇`.expectNull()) null else java.util.Optional.of[scala.Int](`in₇`.expectInt())) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, java.util.Optional[scala.Int]](`rval₃`)
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(`mark₃`)
                    scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[scala.Int, scala.Nothing](`lval₃`)
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i"), `in₇`)
          case 9 =>
            if (`required₂`.&(512).!=(0)) {
              `required₂` = `required₂`.^(512)
              _j = {
                val `mark₄`: scala.Int = `in₇`.pos
                if (`in₇`.expectNull()) null else scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Int](`rval₄`)
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(`mark₄`)
                    scala.util.Try.apply[java.util.Optional[scala.Int]](if (`in₇`.expectNull()) null else java.util.Optional.of[scala.Int](`in₇`.expectInt())) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[java.util.Optional[scala.Int], scala.Nothing](`lval₄`)
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("j"), `in₇`)
          case _ =>
            `in₇`.skipValue()
        }
        `maybeFieldNum₂` = `in₇`.expectObjectField(__co_blocke_scalajack_json_misc_OptionalHolder_fields)
      }
      if (`required₂`.&(14).==(0)) new co.blocke.scalajack.json.misc.OptionalHolder[scala.Int][scala.Int](_a, _b, _c, _d, _e, _f, _g, _h, _i, _j) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(`required₂`.&(14)))), `in₇`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.OptionalHolder[scala.Int]] {
    def encodeValue(`in₈`: co.blocke.scalajack.json.misc.OptionalHolder[scala.Int], `out₆`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₈`, `out₆`)
    def decodeValue(`in₉`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.OptionalHolder[scala.Int] = r0(`in₉`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.OptionalHolder[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_Person_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("name", "age")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  val __co_blocke_scalajack_json_misc_OptionalHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.Tuple2[java.util.Optional[scala.Int], scala.Predef.String], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    in._1.asInstanceOf[java.util.Optional[scala.Int]] match {
      case null =>
        out.burpNull()
      case o if o.isEmpty() =>
        out.burpNull()
      case o =>
        val vv: scala.Int = `o₂`.get().asInstanceOf[scala.Int]
        out.value(vv)
    }
    out.valueEscaped(in._2)
    out.endArray()
  }
  def w2(`in₂`: scala.collection.immutable.List[java.util.Optional[scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startArray()
    `in₂`.foreach[scala.Unit](((i: java.util.Optional[scala.Int]) => i.asInstanceOf[java.util.Optional[scala.Int]] match {
      case null =>
        `out₂`.burpNull()
      case o if `o₃`.isEmpty() =>
        `out₂`.burpNull()
      case o =>
        val `vv₂`: scala.Int = `o₄`.get().asInstanceOf[scala.Int]
        `out₂`.value(`vv₂`)
    }))
    `out₂`.endArray()
  }
  def w3(`in₃`: scala.collection.immutable.Map[scala.Int, java.util.Optional[scala.Int]], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `in₃`.foreach[scala.Unit](((x$1: scala.Tuple2[scala.Int, java.util.Optional[scala.Int]]) => x$1 match {
      case scala.Tuple2(key, value) =>
        {
          `out₃`.maybeComma()
          `out₃`.valueStringified(scala.Int.int2long(key))
          `out₃`.colon()
          value.asInstanceOf[java.util.Optional[scala.Int]] match {
            case null =>
              `out₃`.burpNull()
            case o if `o₅`.isEmpty() =>
              `out₃`.burpNull()
            case o =>
              val `vv₃`: scala.Int = `o₆`.get().asInstanceOf[scala.Int]
              `out₃`.value(`vv₃`)
          }
        }
    }))
    `out₃`.endObject()
  }
  def w4(`in₄`: co.blocke.scalajack.json.misc.Person, `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₄`.==(null)) `out₄`.burpNull() else {
    `out₄`.startObject()
    `out₄`.label("name")
    `out₄`.valueEscaped(`in₄`.name)
    `out₄`.label("age")
    `out₄`.value(`in₄`.age)
    `out₄`.endObject()
  }
  def w0(`in₅`: co.blocke.scalajack.json.misc.OptionalHolder[scala.Int], `out₅`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₅`.==(null)) `out₅`.burpNull() else {
    `out₅`.startObject()
    `out₅`.label("a")
    `in₅`.a.asInstanceOf[java.util.Optional[scala.Int]] match {
      case null =>
        `out₅`.burpNull()
      case o if `o₇`.isEmpty() =>
        `out₅`.burpNull()
      case o =>
        val `vv₄`: scala.Int = `o₈`.get().asInstanceOf[scala.Int]
        `out₅`.value(`vv₄`)
    }
    `out₅`.label("b")
    w1(`in₅`.b, `out₅`)
    `out₅`.label("c")
    w2(`in₅`.c, `out₅`)
    `out₅`.label("d")
    w3(`in₅`.d, `out₅`)
    if (`in₅`.e.==(null)) `out₅`.burpNull() else {
      `out₅`.mark()
      scala.util.Try.apply[scala.Unit]({
        `out₅`.label("e")
        `in₅`.e.asInstanceOf[java.util.Optional[scala.Int]].asInstanceOf[java.util.Optional[scala.Int]] match {
          case null =>
            `out₅`.burpNull()
          case o if `o₉`.isEmpty() =>
            `out₅`.burpNull()
          case o =>
            val `vv₅`: scala.Int = `o₁₀`.get().asInstanceOf[scala.Int]
            `out₅`.value(`vv₅`)
        }
      }) match {
        case scala.util.Success(_) =>
          ()
        case scala.util.Failure(f) =>
          `out₅`.revert()
          {
            `out₅`.label("e")
            `out₅`.value(`in₅`.e.asInstanceOf[scala.Int])
          }
      }
    }
    if (`in₅`.f.==(null)) `out₅`.burpNull() else {
      `out₅`.mark()
      scala.util.Try.apply[scala.Unit]({
        `out₅`.label("f")
        `out₅`.value(`in₅`.f.asInstanceOf[scala.Int])
      }) match {
        case scala.util.Success(_) =>
          ()
        case scala.util.Failure(f) =>
          `out₅`.revert()
          {
            `out₅`.label("f")
            `in₅`.f.asInstanceOf[java.util.Optional[scala.Int]].asInstanceOf[java.util.Optional[scala.Int]] match {
              case null =>
                `out₅`.burpNull()
              case o if `o₁₁`.isEmpty() =>
                `out₅`.burpNull()
              case o =>
                val `vv₆`: scala.Int = `o₁₂`.get().asInstanceOf[scala.Int]
                `out₅`.value(`vv₆`)
            }
          }
      }
    }
    `out₅`.label("g")
    `in₅`.g.asInstanceOf[java.util.Optional[java.util.Optional[scala.Int]]] match {
      case null =>
        `out₅`.burpNull()
      case o if `o₁₃`.isEmpty() =>
        `out₅`.burpNull()
      case o =>
        val `vv₇`: java.util.Optional[scala.Int] = `o₁₄`.get().asInstanceOf[java.util.Optional[scala.Int]]
        `vv₇`.asInstanceOf[java.util.Optional[scala.Int]] match {
          case null =>
            `out₅`.burpNull()
          case o if `o₁₅`.isEmpty() =>
            `out₅`.burpNull()
          case o =>
            val `vv₈`: scala.Int = `o₁₆`.get().asInstanceOf[scala.Int]
            `out₅`.value(`vv₈`)
        }
    }
    `out₅`.label("h")
    `in₅`.h.asInstanceOf[java.util.Optional[co.blocke.scalajack.json.misc.Person]] match {
      case null =>
        `out₅`.burpNull()
      case o if `o₁₇`.isEmpty() =>
        `out₅`.burpNull()
      case o =>
        val `vv₉`: co.blocke.scalajack.json.misc.Person = `o₁₈`.get().asInstanceOf[co.blocke.scalajack.json.misc.Person]
        w4(`vv₉`, `out₅`)
    }
    if (`in₅`.i.==(null)) `out₅`.burpNull() else ()
    `in₅`.i match {
      case scala.Left(v) =>
        {
          `out₅`.label("i")
          `out₅`.value(v.asInstanceOf[scala.Int])
        }
      case scala.Right(v) =>
        {
          `out₅`.label("i")
          `v₂`.asInstanceOf[java.util.Optional[scala.Int]].asInstanceOf[java.util.Optional[scala.Int]] match {
            case null =>
              `out₅`.burpNull()
            case o if `o₁₉`.isEmpty() =>
              `out₅`.burpNull()
            case o =>
              val `vv₁₀`: scala.Int = `o₂₀`.get().asInstanceOf[scala.Int]
              `out₅`.value(`vv₁₀`)
          }
        }
    }
    if (`in₅`.j.==(null)) `out₅`.burpNull() else ()
    `in₅`.j match {
      case scala.Left(v) =>
        {
          `out₅`.label("j")
          `v₃`.asInstanceOf[java.util.Optional[scala.Int]].asInstanceOf[java.util.Optional[scala.Int]] match {
            case null =>
              `out₅`.burpNull()
            case o if `o₂₁`.isEmpty() =>
              `out₅`.burpNull()
            case o =>
              val `vv₁₁`: scala.Int = `o₂₂`.get().asInstanceOf[scala.Int]
              `out₅`.value(`vv₁₁`)
          }
        }
      case scala.Right(v) =>
        {
          `out₅`.label("j")
          `out₅`.value(`v₄`.asInstanceOf[scala.Int])
        }
    }
    `out₅`.endObject()
  }
  def r1(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.Person = {
    var _name: java.lang.String = ""
    var _age: scala.Int = 0
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₆`.expectFirstObjectField(__co_blocke_scalajack_json_misc_Person_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.Person] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _name = `in₆`.expectString()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("name"), `in₆`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _age = `in₆`.expectInt()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("age"), `in₆`)
          case _ =>
            `in₆`.skipValue()
        }
        maybeFieldNum = `in₆`.expectObjectField(__co_blocke_scalajack_json_misc_Person_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.misc.Person(_name, _age) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("name", "age")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₆`)
    }
  }
  def r0(`in₇`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.OptionalHolder[scala.Int] = {
    var _a: java.util.Optional[scala.Int] = java.util.Optional.empty[java.lang.Object]().asInstanceOf[java.util.Optional[scala.Int]]
    var _b: scala.Tuple2[java.util.Optional[scala.Int], scala.Predef.String] = null
    var _c: scala.collection.immutable.List[java.util.Optional[scala.Int]] = null
    var _d: scala.collection.immutable.Map[scala.Int, java.util.Optional[scala.Int]] = null
    var _e: scala.Int | java.util.Optional[scala.Int] = java.util.Optional.empty[java.lang.Object]().asInstanceOf[scala.Int | java.util.Optional[scala.Int]]
    var _f: java.util.Optional[scala.Int] | scala.Int = java.util.Optional.empty[java.lang.Object]().asInstanceOf[java.util.Optional[scala.Int] | scala.Int]
    var _g: java.util.Optional[java.util.Optional[scala.Int]] = java.util.Optional.empty[java.lang.Object]().asInstanceOf[java.util.Optional[java.util.Optional[scala.Int]]]
    var _h: java.util.Optional[co.blocke.scalajack.json.misc.Person] = java.util.Optional.empty[java.lang.Object]().asInstanceOf[java.util.Optional[co.blocke.scalajack.json.misc.Person]]
    var _i: scala.util.Either[scala.Int, java.util.Optional[scala.Int]] = scala.Predef.augmentString("r").foldRight[scala.Any]((java.util.Optional.empty[java.lang.Object](): scala.Any))(((c: scala.Char, acc: scala.Any) => if (c.==('r')) scala.Right.apply[scala.Nothing, scala.Any](acc) else scala.Left.apply[scala.Any, scala.Nothing](acc))).asInstanceOf[scala.util.Either[scala.Int, java.util.Optional[scala.Int]]]
    var _j: scala.util.Either[java.util.Optional[scala.Int], scala.Int] = scala.Predef.augmentString("l").foldRight[scala.Any]((java.util.Optional.empty[java.lang.Object](): scala.Any))(((`c₂`: scala.Char, `acc₂`: scala.Any) => if (`c₂`.==('r')) scala.Right.apply[scala.Nothing, scala.Any](`acc₂`) else scala.Left.apply[scala.Any, scala.Nothing](`acc₂`))).asInstanceOf[scala.util.Either[java.util.Optional[scala.Int], scala.Int]]
    var `required₂`: scala.Int = 1023
    var `maybeFieldNum₂`: scala.Option[scala.Int] = `in₇`.expectFirstObjectField(__co_blocke_scalajack_json_misc_OptionalHolder_fields)
    if (`maybeFieldNum₂`.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.OptionalHolder[scala.Int]] else {
      while (`maybeFieldNum₂`.isDefined) {
        `maybeFieldNum₂`.get match {
          case 0 =>
            if (`required₂`.&(1).!=(0)) {
              `required₂` = `required₂`.^(1)
              _a = if (`in₇`.expectNull()) java.util.Optional.empty[scala.Int]() else java.util.Optional.of[scala.Int](`in₇`.expectInt())
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₇`)
          case 1 =>
            if (`required₂`.&(2).!=(0)) {
              `required₂` = `required₂`.^(2)
              _b = if (`in₇`.expectNull()) null else {
                `in₇`.expectToken('[')
                val tv: scala.Tuple2[java.util.Optional[scala.Int], scala.Predef.String] = new scala.Tuple2[java.util.Optional[scala.Int], scala.Predef.String][java.util.Optional[scala.Int], java.lang.String](if (`in₇`.expectNull()) java.util.Optional.empty[scala.Int]() else java.util.Optional.of[scala.Int](`in₇`.expectInt()), {
                  `in₇`.expectToken(',')
                  `in₇`.expectString()
                })
                `in₇`.expectToken(']')

                (tv: scala.Tuple2[java.util.Optional[scala.Int], scala.Predef.String])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₇`)
          case 2 =>
            if (`required₂`.&(4).!=(0)) {
              `required₂` = `required₂`.^(4)
              _c = {
                val parsedArray: scala.collection.mutable.ListBuffer[java.util.Optional[scala.Int]] = `in₇`.expectArray[java.util.Optional[scala.Int]]((() => if (`in₇`.expectNull()) java.util.Optional.empty[scala.Int]() else java.util.Optional.of[scala.Int](`in₇`.expectInt())))

                (if (parsedArray.!=(null)) parsedArray.toList else null: scala.collection.immutable.List[java.util.Optional[scala.Int]])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c"), `in₇`)
          case 3 =>
            if (`required₂`.&(8).!=(0)) {
              `required₂` = `required₂`.^(8)
              _d = if (`in₇`.expectNull()) null else {
                `in₇`.expectToken('{')
                `in₇`.parseMap[scala.Int, java.util.Optional[scala.Int]]((() => scala.Predef.augmentString(`in₇`.expectString()).toInt), (() => if (`in₇`.expectNull()) java.util.Optional.empty[scala.Int]() else java.util.Optional.of[scala.Int](`in₇`.expectInt())), scala.Predef.Map.empty[scala.Int, java.util.Optional[scala.Int]], true)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d"), `in₇`)
          case 4 =>
            if (`required₂`.&(16).!=(0)) {
              `required₂` = `required₂`.^(16)
              _e = {
                val mark: scala.Int = `in₇`.pos
                scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                  case scala.util.Success(lval) =>
                    (lval: scala.Int)
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(mark)
                    scala.util.Try.apply[java.util.Optional[scala.Int]](if (`in₇`.expectNull()) java.util.Optional.empty[scala.Int]() else java.util.Optional.of[scala.Int](`in₇`.expectInt())) match {
                      case scala.util.Success(rval) =>
                        (rval: java.util.Optional[scala.Int])
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("e"), `in₇`)
          case 5 =>
            if (`required₂`.&(32).!=(0)) {
              `required₂` = `required₂`.^(32)
              _f = {
                val `mark₂`: scala.Int = `in₇`.pos
                scala.util.Try.apply[java.util.Optional[scala.Int]](if (`in₇`.expectNull()) java.util.Optional.empty[scala.Int]() else java.util.Optional.of[scala.Int](`in₇`.expectInt())) match {
                  case scala.util.Success(lval) =>
                    (`lval₂`: java.util.Optional[scala.Int])
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(`mark₂`)
                    scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                      case scala.util.Success(rval) =>
                        (`rval₂`: scala.Int)
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Union type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f"), `in₇`)
          case 6 =>
            if (`required₂`.&(64).!=(0)) {
              `required₂` = `required₂`.^(64)
              _g = if (`in₇`.expectNull()) java.util.Optional.empty[java.util.Optional[scala.Int]]() else java.util.Optional.of[java.util.Optional[scala.Int]](if (`in₇`.expectNull()) java.util.Optional.empty[scala.Int]() else java.util.Optional.of[scala.Int](`in₇`.expectInt()))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("g"), `in₇`)
          case 7 =>
            if (`required₂`.&(128).!=(0)) {
              `required₂` = `required₂`.^(128)
              _h = if (`in₇`.expectNull()) java.util.Optional.empty[co.blocke.scalajack.json.misc.Person]() else java.util.Optional.of[co.blocke.scalajack.json.misc.Person](r1(`in₇`))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("h"), `in₇`)
          case 8 =>
            if (`required₂`.&(256).!=(0)) {
              `required₂` = `required₂`.^(256)
              _i = {
                val `mark₃`: scala.Int = `in₇`.pos
                if (`in₇`.expectNull()) null else scala.util.Try.apply[java.util.Optional[scala.Int]](if (`in₇`.expectNull()) java.util.Optional.empty[scala.Int]() else java.util.Optional.of[scala.Int](`in₇`.expectInt())) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, java.util.Optional[scala.Int]](`rval₃`)
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(`mark₃`)
                    scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[scala.Int, scala.Nothing](`lval₃`)
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i"), `in₇`)
          case 9 =>
            if (`required₂`.&(512).!=(0)) {
              `required₂` = `required₂`.^(512)
              _j = {
                val `mark₄`: scala.Int = `in₇`.pos
                if (`in₇`.expectNull()) null else scala.util.Try.apply[scala.Int](`in₇`.expectInt()) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.Int](`rval₄`)
                  case scala.util.Failure(f) =>
                    `in₇`.revertToPos(`mark₄`)
                    scala.util.Try.apply[java.util.Optional[scala.Int]](if (`in₇`.expectNull()) java.util.Optional.empty[scala.Int]() else java.util.Optional.of[scala.Int](`in₇`.expectInt())) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[java.util.Optional[scala.Int], scala.Nothing](`lval₄`)
                      case scala.util.Failure(_) =>
                        `in₇`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₇`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("j"), `in₇`)
          case _ =>
            `in₇`.skipValue()
        }
        `maybeFieldNum₂` = `in₇`.expectObjectField(__co_blocke_scalajack_json_misc_OptionalHolder_fields)
      }
      if (`required₂`.&(14).==(0)) new co.blocke.scalajack.json.misc.OptionalHolder[scala.Int][scala.Int](_a, _b, _c, _d, _e, _f, _g, _h, _i, _j) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b", "c", "d", "e", "f", "g", "h", "i", "j")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(`required₂`.&(14)))), `in₇`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.OptionalHolder[scala.Int]] {
    def encodeValue(`in₈`: co.blocke.scalajack.json.misc.OptionalHolder[scala.Int], `out₆`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₈`, `out₆`)
    def decodeValue(`in₉`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.OptionalHolder[scala.Int] = r0(`in₉`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.OptionalHolder[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_EitherRecipeJ_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    if (in.a.==(null)) out.burpNull() else ()
    in.a match {
      case scala.Left(v) =>
        {
          out.label("a")
          out.value(v.asInstanceOf[scala.Boolean])
        }
      case scala.Right(v) =>
        {
          if (`v₂`.asInstanceOf[scala.util.Either[java.util.Optional[scala.Int], scala.Predef.String]].==(null)) out.burpNull() else ()
          `v₂`.asInstanceOf[scala.util.Either[java.util.Optional[scala.Int], scala.Predef.String]] match {
            case scala.Left(v) =>
              if (`v₃`.asInstanceOf[java.util.Optional[scala.Int]].isEmpty().unary_!) {
                out.label("a")
                out.value(`v₃`.asInstanceOf[java.util.Optional[scala.Int]].get())
              } else ()
            case scala.Right(v) =>
              {
                out.label("a")
                out.valueEscaped(`v₄`.asInstanceOf[java.lang.String])
              }
          }
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int] = {
    var _a: scala.util.Either[scala.Boolean, scala.util.Either[java.util.Optional[scala.Int], scala.Predef.String]] = scala.Predef.augmentString("rl").foldRight[scala.Any]((java.util.Optional.empty[java.lang.Object](): scala.Any))(((c: scala.Char, acc: scala.Any) => if (c.==('r')) scala.Right.apply[scala.Nothing, scala.Any](acc) else scala.Left.apply[scala.Any, scala.Nothing](acc))).asInstanceOf[scala.util.Either[scala.Boolean, scala.util.Either[java.util.Optional[scala.Int], scala.Predef.String]]]
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_EitherRecipeJ_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val mark: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[scala.util.Either[java.util.Optional[scala.Int], scala.Predef.String]]({
                  val `mark₂`: scala.Int = `in₂`.pos
                  if (`in₂`.expectNull()) null else scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                    case scala.util.Success(rval) =>
                      scala.Right.apply[scala.Nothing, java.lang.String](rval)
                    case scala.util.Failure(f) =>
                      `in₂`.revertToPos(`mark₂`)
                      scala.util.Try.apply[java.util.Optional[scala.Int]](if (`in₂`.expectNull()) null else java.util.Optional.of[scala.Int](`in₂`.expectInt())) match {
                        case scala.util.Success(lval) =>
                          scala.Left.apply[java.util.Optional[scala.Int], scala.Nothing](lval)
                        case scala.util.Failure(_) =>
                          `in₂`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                      }
                  }
                }) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.util.Either[java.util.Optional[scala.Int], scala.Predef.String]](`rval₂`)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(mark)
                    scala.util.Try.apply[scala.Boolean](`in₂`.expectBoolean()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[scala.Boolean, scala.Nothing](`lval₂`)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_EitherRecipeJ_fields)
      }
      if (required.&(0).==(0)) new co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(0)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_EitherRecipeJ_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    if (in.a.==(null)) out.burpNull() else ()
    in.a match {
      case scala.Left(v) =>
        {
          out.label("a")
          out.value(v.asInstanceOf[scala.Boolean])
        }
      case scala.Right(v) =>
        {
          if (`v₂`.asInstanceOf[scala.util.Either[java.util.Optional[scala.Int], scala.Predef.String]].==(null)) out.burpNull() else ()
          `v₂`.asInstanceOf[scala.util.Either[java.util.Optional[scala.Int], scala.Predef.String]] match {
            case scala.Left(v) =>
              if (`v₃`.asInstanceOf[java.util.Optional[scala.Int]].isEmpty().unary_!) {
                out.label("a")
                out.value(`v₃`.asInstanceOf[java.util.Optional[scala.Int]].get())
              } else ()
            case scala.Right(v) =>
              {
                out.label("a")
                out.valueEscaped(`v₄`.asInstanceOf[java.lang.String])
              }
          }
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int] = {
    var _a: scala.util.Either[scala.Boolean, scala.util.Either[java.util.Optional[scala.Int], scala.Predef.String]] = scala.Predef.augmentString("rl").foldRight[scala.Any]((java.util.Optional.empty[java.lang.Object](): scala.Any))(((c: scala.Char, acc: scala.Any) => if (c.==('r')) scala.Right.apply[scala.Nothing, scala.Any](acc) else scala.Left.apply[scala.Any, scala.Nothing](acc))).asInstanceOf[scala.util.Either[scala.Boolean, scala.util.Either[java.util.Optional[scala.Int], scala.Predef.String]]]
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_EitherRecipeJ_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val mark: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[scala.util.Either[java.util.Optional[scala.Int], scala.Predef.String]]({
                  val `mark₂`: scala.Int = `in₂`.pos
                  if (`in₂`.expectNull()) null else scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                    case scala.util.Success(rval) =>
                      scala.Right.apply[scala.Nothing, java.lang.String](rval)
                    case scala.util.Failure(f) =>
                      `in₂`.revertToPos(`mark₂`)
                      scala.util.Try.apply[java.util.Optional[scala.Int]](if (`in₂`.expectNull()) null else java.util.Optional.of[scala.Int](`in₂`.expectInt())) match {
                        case scala.util.Success(lval) =>
                          scala.Left.apply[java.util.Optional[scala.Int], scala.Nothing](lval)
                        case scala.util.Failure(_) =>
                          `in₂`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                      }
                  }
                }) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.util.Either[java.util.Optional[scala.Int], scala.Predef.String]](`rval₂`)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(mark)
                    scala.util.Try.apply[scala.Boolean](`in₂`.expectBoolean()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[scala.Boolean, scala.Nothing](`lval₂`)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_EitherRecipeJ_fields)
      }
      if (required.&(0).==(0)) new co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(0)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_EitherRecipeJ_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    if (in.a.==(null)) out.burpNull() else ()
    in.a match {
      case scala.Left(v) =>
        {
          out.label("a")
          out.value(v.asInstanceOf[scala.Boolean])
        }
      case scala.Right(v) =>
        {
          if (`v₂`.asInstanceOf[scala.util.Either[java.util.Optional[scala.Int], scala.Predef.String]].==(null)) out.burpNull() else ()
          `v₂`.asInstanceOf[scala.util.Either[java.util.Optional[scala.Int], scala.Predef.String]] match {
            case scala.Left(v) =>
              {
                out.label("a")
                `v₃`.asInstanceOf[java.util.Optional[scala.Int]].asInstanceOf[java.util.Optional[scala.Int]] match {
                  case null =>
                    out.burpNull()
                  case o if o.isEmpty() =>
                    out.burpNull()
                  case o =>
                    val vv: scala.Int = `o₂`.get().asInstanceOf[scala.Int]
                    out.value(vv)
                }
              }
            case scala.Right(v) =>
              {
                out.label("a")
                out.valueEscaped(`v₄`.asInstanceOf[java.lang.String])
              }
          }
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int] = {
    var _a: scala.util.Either[scala.Boolean, scala.util.Either[java.util.Optional[scala.Int], scala.Predef.String]] = scala.Predef.augmentString("rl").foldRight[scala.Any]((java.util.Optional.empty[java.lang.Object](): scala.Any))(((c: scala.Char, acc: scala.Any) => if (c.==('r')) scala.Right.apply[scala.Nothing, scala.Any](acc) else scala.Left.apply[scala.Any, scala.Nothing](acc))).asInstanceOf[scala.util.Either[scala.Boolean, scala.util.Either[java.util.Optional[scala.Int], scala.Predef.String]]]
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_EitherRecipeJ_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val mark: scala.Int = `in₂`.pos
                if (`in₂`.expectNull()) null else scala.util.Try.apply[scala.util.Either[java.util.Optional[scala.Int], scala.Predef.String]]({
                  val `mark₂`: scala.Int = `in₂`.pos
                  if (`in₂`.expectNull()) null else scala.util.Try.apply[java.lang.String](`in₂`.expectString()) match {
                    case scala.util.Success(rval) =>
                      scala.Right.apply[scala.Nothing, java.lang.String](rval)
                    case scala.util.Failure(f) =>
                      `in₂`.revertToPos(`mark₂`)
                      scala.util.Try.apply[java.util.Optional[scala.Int]](if (`in₂`.expectNull()) java.util.Optional.empty[scala.Int]() else java.util.Optional.of[scala.Int](`in₂`.expectInt())) match {
                        case scala.util.Success(lval) =>
                          scala.Left.apply[java.util.Optional[scala.Int], scala.Nothing](lval)
                        case scala.util.Failure(_) =>
                          `in₂`.backspace()
                          throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                      }
                  }
                }) match {
                  case scala.util.Success(rval) =>
                    scala.Right.apply[scala.Nothing, scala.util.Either[java.util.Optional[scala.Int], scala.Predef.String]](`rval₂`)
                  case scala.util.Failure(f) =>
                    `in₂`.revertToPos(mark)
                    scala.util.Try.apply[scala.Boolean](`in₂`.expectBoolean()) match {
                      case scala.util.Success(lval) =>
                        scala.Left.apply[scala.Boolean, scala.Nothing](`lval₂`)
                      case scala.util.Failure(_) =>
                        `in₂`.backspace()
                        throw co.blocke.scalajack.json.JsonParseError.apply("Failed to read either side of Either type", `in₂`)
                    }
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_EitherRecipeJ_fields)
      }
      if (required.&(0).==(0)) new co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(0)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.EitherRecipeJ[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_TryHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.TryHolder[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.a match {
      case scala.util.Failure(v) =>
        {
          out.label("a")
          out.burpNull()
        }
      case _ =>
        {
          out.label("a")
          out.value(in.a.get)
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.TryHolder[scala.Int] = {
    var _a: scala.util.Try[scala.Int] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_TryHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.TryHolder[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val mark: scala.Int = `in₂`.pos
                try if (`in₂`.expectNull()) null else scala.util.Success.apply[scala.Int](`in₂`.expectInt()) catch {
                  case t: java.lang.Throwable =>
                    `in₂`.revertToPos(mark)
                    throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(t.getMessage()), `in₂`)
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_TryHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.misc.TryHolder[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.TryHolder[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.TryHolder[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.TryHolder[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.TryHolder[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_TryHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.TryHolder[scala.Option[scala.Int]], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.a match {
      case scala.util.Failure(v) =>
        {
          out.label("a")
          out.burpNull()
        }
      case _ =>
        in.a.get match {
          case scala.None =>
            ()
          case scala.Some(v) =>
            {
              out.label("a")
              out.value(v)
            }
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.TryHolder[scala.Option[scala.Int]] = {
    var _a: scala.util.Try[scala.Option[scala.Int]] = scala.util.Success.apply[scala.None.type](scala.None)
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_TryHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.TryHolder[scala.Option[scala.Int]]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val mark: scala.Int = `in₂`.pos
                try if (`in₂`.expectNull()) null else scala.util.Success.apply[scala.Option[scala.Int]](if (`in₂`.expectNull()) null else scala.Some.apply[scala.Int](`in₂`.expectInt())) catch {
                  case t: java.lang.Throwable =>
                    `in₂`.revertToPos(mark)
                    throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(t.getMessage()), `in₂`)
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_TryHolder_fields)
      }
      if (required.&(0).==(0)) new co.blocke.scalajack.json.misc.TryHolder[scala.Option[scala.Int]][scala.Option[scala.Int]](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(0)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.TryHolder[scala.Option[scala.Int]]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.TryHolder[scala.Option[scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.TryHolder[scala.Option[scala.Int]] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.TryHolder[scala.Option[scala.Int]]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_TryHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.TryHolder[scala.Option[scala.Int]], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.a match {
      case scala.util.Failure(v) =>
        {
          out.label("a")
          out.burpNull()
        }
      case _ =>
        in.a.get match {
          case scala.None =>
            ()
          case scala.Some(v) =>
            {
              out.label("a")
              out.value(v)
            }
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.TryHolder[scala.Option[scala.Int]] = {
    var _a: scala.util.Try[scala.Option[scala.Int]] = scala.util.Success.apply[scala.None.type](scala.None)
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_TryHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.TryHolder[scala.Option[scala.Int]]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val mark: scala.Int = `in₂`.pos
                try if (`in₂`.expectNull()) null else scala.util.Success.apply[scala.Option[scala.Int]](if (`in₂`.expectNull()) null else scala.Some.apply[scala.Int](`in₂`.expectInt())) catch {
                  case t: java.lang.Throwable =>
                    `in₂`.revertToPos(mark)
                    throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(t.getMessage()), `in₂`)
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_TryHolder_fields)
      }
      if (required.&(0).==(0)) new co.blocke.scalajack.json.misc.TryHolder[scala.Option[scala.Int]][scala.Option[scala.Int]](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(0)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.TryHolder[scala.Option[scala.Int]]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.TryHolder[scala.Option[scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.TryHolder[scala.Option[scala.Int]] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.TryHolder[scala.Option[scala.Int]]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_TryHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.TryHolder[java.util.Optional[scala.Int]], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.a match {
      case scala.util.Failure(v) =>
        {
          out.label("a")
          out.burpNull()
        }
      case _ =>
        if (in.a.get.isEmpty().unary_!) {
          out.label("a")
          out.value(in.a.get.get())
        } else ()
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.TryHolder[java.util.Optional[scala.Int]] = {
    var _a: scala.util.Try[java.util.Optional[scala.Int]] = scala.util.Success.apply[java.util.Optional[java.lang.Object]](java.util.Optional.empty[java.lang.Object]()).asInstanceOf[scala.util.Try[java.util.Optional[scala.Int]]]
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_TryHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.TryHolder[java.util.Optional[scala.Int]]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val mark: scala.Int = `in₂`.pos
                try if (`in₂`.expectNull()) null else scala.util.Success.apply[java.util.Optional[scala.Int]](if (`in₂`.expectNull()) null else java.util.Optional.of[scala.Int](`in₂`.expectInt())) catch {
                  case t: java.lang.Throwable =>
                    `in₂`.revertToPos(mark)
                    throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(t.getMessage()), `in₂`)
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_TryHolder_fields)
      }
      if (required.&(0).==(0)) new co.blocke.scalajack.json.misc.TryHolder[java.util.Optional[scala.Int]][java.util.Optional[scala.Int]](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(0)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.TryHolder[java.util.Optional[scala.Int]]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.TryHolder[java.util.Optional[scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.TryHolder[java.util.Optional[scala.Int]] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.TryHolder[java.util.Optional[scala.Int]]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_TryHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.TryHolder[java.util.Optional[scala.Int]], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.a match {
      case scala.util.Failure(v) =>
        {
          out.label("a")
          out.burpNull()
        }
      case _ =>
        if (in.a.get.isEmpty().unary_!) {
          out.label("a")
          out.value(in.a.get.get())
        } else ()
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.TryHolder[java.util.Optional[scala.Int]] = {
    var _a: scala.util.Try[java.util.Optional[scala.Int]] = scala.util.Success.apply[java.util.Optional[java.lang.Object]](java.util.Optional.empty[java.lang.Object]()).asInstanceOf[scala.util.Try[java.util.Optional[scala.Int]]]
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_TryHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.TryHolder[java.util.Optional[scala.Int]]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val mark: scala.Int = `in₂`.pos
                try if (`in₂`.expectNull()) null else scala.util.Success.apply[java.util.Optional[scala.Int]](if (`in₂`.expectNull()) null else java.util.Optional.of[scala.Int](`in₂`.expectInt())) catch {
                  case t: java.lang.Throwable =>
                    `in₂`.revertToPos(mark)
                    throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(t.getMessage()), `in₂`)
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_TryHolder_fields)
      }
      if (required.&(0).==(0)) new co.blocke.scalajack.json.misc.TryHolder[java.util.Optional[scala.Int]][java.util.Optional[scala.Int]](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(0)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.TryHolder[java.util.Optional[scala.Int]]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.TryHolder[java.util.Optional[scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.TryHolder[java.util.Optional[scala.Int]] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.TryHolder[java.util.Optional[scala.Int]]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_TryHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.TryHolder[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.a match {
      case scala.util.Failure(v) =>
        {
          out.label("a")
          out.burpNull()
        }
      case _ =>
        {
          out.label("a")
          out.value(in.a.get)
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.TryHolder[scala.Int] = {
    var _a: scala.util.Try[scala.Int] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_TryHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.TryHolder[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val mark: scala.Int = `in₂`.pos
                try if (`in₂`.expectNull()) null else scala.util.Success.apply[scala.Int](`in₂`.expectInt()) catch {
                  case t: java.lang.Throwable =>
                    `in₂`.revertToPos(mark)
                    throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(t.getMessage()), `in₂`)
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_TryHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.misc.TryHolder[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.TryHolder[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.TryHolder[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.TryHolder[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.TryHolder[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_TryHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.TryHolder[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.a match {
      case scala.util.Failure(v) =>
        {
          out.label("a")
          out.value("Try Failure with msg: ".+(v.getMessage()))
        }
      case _ =>
        {
          out.label("a")
          out.value(in.a.get)
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.TryHolder[scala.Int] = {
    var _a: scala.util.Try[scala.Int] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_TryHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.TryHolder[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val mark: scala.Int = `in₂`.pos
                try if (`in₂`.expectNull()) null else scala.util.Success.apply[scala.Int](`in₂`.expectInt()) catch {
                  case t: java.lang.Throwable =>
                    `in₂`.revertToPos(mark)
                    throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(t.getMessage()), `in₂`)
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_TryHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.misc.TryHolder[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.TryHolder[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.TryHolder[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.TryHolder[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.TryHolder[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_TryHolder_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.misc.TryHolder[scala.Int], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    in.a match {
      case scala.util.Failure(v) =>
        throw v
      case _ =>
        {
          out.label("a")
          out.value(in.a.get)
        }
    }
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.TryHolder[scala.Int] = {
    var _a: scala.util.Try[scala.Int] = null
    var required: scala.Int = 1
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_misc_TryHolder_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.TryHolder[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val mark: scala.Int = `in₂`.pos
                try if (`in₂`.expectNull()) null else scala.util.Success.apply[scala.Int](`in₂`.expectInt()) catch {
                  case t: java.lang.Throwable =>
                    `in₂`.revertToPos(mark)
                    throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(t.getMessage()), `in₂`)
                }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_misc_TryHolder_fields)
      }
      if (required.&(1).==(0)) new co.blocke.scalajack.json.misc.TryHolder[scala.Int][scala.Int](_a) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(1)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.TryHolder[scala.Int]] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.misc.TryHolder[scala.Int], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.TryHolder[scala.Int] = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.TryHolder[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_misc_TryHolder2_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w1(in: scala.collection.immutable.Seq[scala.util.Try[scala.Int]], out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startArray()
    in.foreach[scala.Unit](((i: scala.util.Try[scala.Int]) => if (i.==(null)) out.burpNull() else i match {
      case scala.util.Success(v) =>
        out.value(v)
      case scala.util.Failure(v) =>
        out.burpNull()
    }))
    out.endArray()
  }
  def w2(`in₂`: scala.Tuple2[scala.util.Try[scala.Int], scala.util.Try[scala.Int]], `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₂`.==(null)) `out₂`.burpNull() else {
    `out₂`.startArray()
    if (`in₂`._1.==(null)) `out₂`.burpNull() else `in₂`._1 match {
      case scala.util.Success(v) =>
        `out₂`.value(`v₂`)
      case scala.util.Failure(v) =>
        `out₂`.burpNull()
    }
    if (`in₂`._2.==(null)) `out₂`.burpNull() else `in₂`._2 match {
      case scala.util.Success(v) =>
        `out₂`.value(`v₃`)
      case scala.util.Failure(v) =>
        `out₂`.burpNull()
    }
    `out₂`.endArray()
  }
  def w0(`in₃`: co.blocke.scalajack.json.misc.TryHolder2[scala.Int], `out₃`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (`in₃`.==(null)) `out₃`.burpNull() else {
    `out₃`.startObject()
    `out₃`.label("a")
    w1(`in₃`.a, `out₃`)
    `out₃`.label("b")
    w2(`in₃`.b, `out₃`)
    `out₃`.endObject()
  }
  def r0(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.TryHolder2[scala.Int] = {
    var _a: scala.collection.immutable.Seq[scala.util.Try[scala.Int]] = null
    var _b: scala.Tuple2[scala.util.Try[scala.Int], scala.util.Try[scala.Int]] = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₄`.expectFirstObjectField(__co_blocke_scalajack_json_misc_TryHolder2_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.misc.TryHolder2[scala.Int]] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _a = {
                val parsedArray: scala.collection.mutable.ListBuffer[scala.util.Try[scala.Int]] = `in₄`.expectArray[scala.util.Try[scala.Int]]((() => {
                  val mark: scala.Int = `in₄`.pos
                  try if (`in₄`.expectNull()) null else scala.util.Success.apply[scala.Int](`in₄`.expectInt()) catch {
                    case t: java.lang.Throwable =>
                      `in₄`.revertToPos(mark)
                      throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(t.getMessage()), `in₄`)
                  }
                }))

                (if (parsedArray.!=(null)) parsedArray.toSeq else null: scala.collection.immutable.Seq[scala.util.Try[scala.Int]])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("a"), `in₄`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b = if (`in₄`.expectNull()) null else {
                `in₄`.expectToken('[')
                val tv: scala.Tuple2[scala.util.Try[scala.Int], scala.util.Try[scala.Int]] = new scala.Tuple2[scala.util.Try[scala.Int], scala.util.Try[scala.Int]][scala.util.Try[scala.Int], scala.util.Try[scala.Int]]({
                  val `mark₂`: scala.Int = `in₄`.pos
                  try if (`in₄`.expectNull()) null else scala.util.Success.apply[scala.Int](`in₄`.expectInt()) catch {
                    case t: java.lang.Throwable =>
                      `in₄`.revertToPos(`mark₂`)
                      throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(`t₂`.getMessage()), `in₄`)
                  }
                }, {
                  `in₄`.expectToken(',')
                  val `mark₃`: scala.Int = `in₄`.pos
                  try if (`in₄`.expectNull()) null else scala.util.Success.apply[scala.Int](`in₄`.expectInt()) catch {
                    case t: java.lang.Throwable =>
                      `in₄`.revertToPos(`mark₃`)
                      throw co.blocke.scalajack.json.JsonParseError.apply("Unsuccessful attempt to read Try type with failure: ".+(`t₃`.getMessage()), `in₄`)
                  }
                })
                `in₄`.expectToken(']')

                (tv: scala.Tuple2[scala.util.Try[scala.Int], scala.util.Try[scala.Int]])
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b"), `in₄`)
          case _ =>
            `in₄`.skipValue()
        }
        maybeFieldNum = `in₄`.expectObjectField(__co_blocke_scalajack_json_misc_TryHolder2_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.misc.TryHolder2[scala.Int][scala.Int](_a, _b) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("a", "b")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₄`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.TryHolder2[scala.Int]] {
    def encodeValue(`in₅`: co.blocke.scalajack.json.misc.TryHolder2[scala.Int], `out₄`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₅`, `out₄`)
    def decodeValue(`in₆`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.misc.TryHolder2[scala.Int] = r0(`in₆`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.misc.TryHolder2[scala.Int]])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJBigDecimal_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("bd1", "bd2", "bd3", "bd4", "bd5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJBigDecimal, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("bd1")
    out.value(in.bd1)
    out.label("bd2")
    out.value(in.bd2)
    out.label("bd3")
    out.value(in.bd3)
    out.label("bd4")
    out.value(in.bd4)
    out.label("bd5")
    out.value(in.bd5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJBigDecimal = {
    var _bd1: java.math.BigDecimal = new java.math.BigDecimal(0.0)
    var _bd2: java.math.BigDecimal = new java.math.BigDecimal(0.0)
    var _bd3: java.math.BigDecimal = new java.math.BigDecimal(0.0)
    var _bd4: java.math.BigDecimal = new java.math.BigDecimal(0.0)
    var _bd5: java.math.BigDecimal = new java.math.BigDecimal(0.0)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJBigDecimal_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJBigDecimal] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _bd1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigDecimal(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _bd2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigDecimal(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _bd3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigDecimal(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _bd4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigDecimal(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _bd5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigDecimal(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJBigDecimal_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJBigDecimal(_bd1, _bd2, _bd3, _bd4, _bd5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("bd1", "bd2", "bd3", "bd4", "bd5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJBigDecimal] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJBigDecimal, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJBigDecimal = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJBigDecimal])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJBigDecimal_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("bd1", "bd2", "bd3", "bd4", "bd5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJBigDecimal, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("bd1")
    out.value(in.bd1)
    out.label("bd2")
    out.value(in.bd2)
    out.label("bd3")
    out.value(in.bd3)
    out.label("bd4")
    out.value(in.bd4)
    out.label("bd5")
    out.value(in.bd5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJBigDecimal = {
    var _bd1: java.math.BigDecimal = new java.math.BigDecimal(0.0)
    var _bd2: java.math.BigDecimal = new java.math.BigDecimal(0.0)
    var _bd3: java.math.BigDecimal = new java.math.BigDecimal(0.0)
    var _bd4: java.math.BigDecimal = new java.math.BigDecimal(0.0)
    var _bd5: java.math.BigDecimal = new java.math.BigDecimal(0.0)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJBigDecimal_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJBigDecimal] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _bd1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigDecimal(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _bd2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigDecimal(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _bd3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigDecimal(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _bd4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigDecimal(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _bd5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigDecimal(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJBigDecimal_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJBigDecimal(_bd1, _bd2, _bd3, _bd4, _bd5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("bd1", "bd2", "bd3", "bd4", "bd5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJBigDecimal] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJBigDecimal, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJBigDecimal = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJBigDecimal])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJBigInteger_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("bi1", "bi2", "bi3", "bi4", "bi5", "bi6", "bi7")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJBigInteger, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("bi1")
    out.value(in.bi1)
    out.label("bi2")
    out.value(in.bi2)
    out.label("bi3")
    out.value(in.bi3)
    out.label("bi4")
    out.value(in.bi4)
    out.label("bi5")
    out.value(in.bi5)
    out.label("bi6")
    out.value(in.bi6)
    out.label("bi7")
    out.value(in.bi7)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJBigInteger = {
    var _bi1: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var _bi2: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var _bi3: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var _bi4: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var _bi5: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var _bi6: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var _bi7: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var required: scala.Int = 127
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJBigInteger_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJBigInteger] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _bi1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _bi2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _bi3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _bi4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _bi5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi5"), `in₂`)
          case 5 =>
            if (required.&(32).!=(0)) {
              required = required.^(32)
              _bi6 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(`n₆`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi6"), `in₂`)
          case 6 =>
            if (required.&(64).!=(0)) {
              required = required.^(64)
              _bi7 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(`n₇`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi7"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJBigInteger_fields)
      }
      if (required.&(127).==(0)) new co.blocke.scalajack.json.primitives.SampleJBigInteger(_bi1, _bi2, _bi3, _bi4, _bi5, _bi6, _bi7) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("bi1", "bi2", "bi3", "bi4", "bi5", "bi6", "bi7")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(127)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJBigInteger] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJBigInteger, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJBigInteger = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJBigInteger])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJBigInteger_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("bi1", "bi2", "bi3", "bi4", "bi5", "bi6", "bi7")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJBigInteger, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("bi1")
    out.value(in.bi1)
    out.label("bi2")
    out.value(in.bi2)
    out.label("bi3")
    out.value(in.bi3)
    out.label("bi4")
    out.value(in.bi4)
    out.label("bi5")
    out.value(in.bi5)
    out.label("bi6")
    out.value(in.bi6)
    out.label("bi7")
    out.value(in.bi7)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJBigInteger = {
    var _bi1: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var _bi2: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var _bi3: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var _bi4: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var _bi5: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var _bi6: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var _bi7: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var required: scala.Int = 127
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJBigInteger_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJBigInteger] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _bi1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _bi2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _bi3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _bi4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _bi5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi5"), `in₂`)
          case 5 =>
            if (required.&(32).!=(0)) {
              required = required.^(32)
              _bi6 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(`n₆`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi6"), `in₂`)
          case 6 =>
            if (required.&(64).!=(0)) {
              required = required.^(64)
              _bi7 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(`n₇`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi7"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJBigInteger_fields)
      }
      if (required.&(127).==(0)) new co.blocke.scalajack.json.primitives.SampleJBigInteger(_bi1, _bi2, _bi3, _bi4, _bi5, _bi6, _bi7) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("bi1", "bi2", "bi3", "bi4", "bi5", "bi6", "bi7")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(127)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJBigInteger] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJBigInteger, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJBigInteger = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJBigInteger])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJBoolean_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("bool1", "bool2", "bool3", "bool4", "bool5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJBoolean, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("bool1")
    out.value(in.bool1)
    out.label("bool2")
    out.value(in.bool2)
    out.label("bool3")
    out.value(in.bool3)
    out.label("bool4")
    out.value(in.bool4)
    out.label("bool5")
    out.value(in.bool5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJBoolean = {
    var _bool1: java.lang.Boolean = java.lang.Boolean.FALSE
    var _bool2: java.lang.Boolean = java.lang.Boolean.FALSE
    var _bool3: java.lang.Boolean = java.lang.Boolean.FALSE
    var _bool4: java.lang.Boolean = java.lang.Boolean.FALSE
    var _bool5: java.lang.Boolean = java.lang.Boolean.FALSE
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJBoolean_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJBoolean] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _bool1 = `in₂`.expectJavaBoolean()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bool1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _bool2 = `in₂`.expectJavaBoolean()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bool2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _bool3 = `in₂`.expectJavaBoolean()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bool3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _bool4 = `in₂`.expectJavaBoolean()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bool4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _bool5 = `in₂`.expectJavaBoolean()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bool5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJBoolean_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJBoolean(_bool1, _bool2, _bool3, _bool4, _bool5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("bool1", "bool2", "bool3", "bool4", "bool5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJBoolean] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJBoolean, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJBoolean = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJBoolean])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJBoolean_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("bool1", "bool2", "bool3", "bool4", "bool5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJBoolean, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("bool1")
    out.value(in.bool1)
    out.label("bool2")
    out.value(in.bool2)
    out.label("bool3")
    out.value(in.bool3)
    out.label("bool4")
    out.value(in.bool4)
    out.label("bool5")
    out.value(in.bool5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJBoolean = {
    var _bool1: java.lang.Boolean = java.lang.Boolean.FALSE
    var _bool2: java.lang.Boolean = java.lang.Boolean.FALSE
    var _bool3: java.lang.Boolean = java.lang.Boolean.FALSE
    var _bool4: java.lang.Boolean = java.lang.Boolean.FALSE
    var _bool5: java.lang.Boolean = java.lang.Boolean.FALSE
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJBoolean_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJBoolean] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _bool1 = `in₂`.expectJavaBoolean()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bool1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _bool2 = `in₂`.expectJavaBoolean()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bool2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _bool3 = `in₂`.expectJavaBoolean()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bool3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _bool4 = `in₂`.expectJavaBoolean()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bool4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _bool5 = `in₂`.expectJavaBoolean()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bool5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJBoolean_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJBoolean(_bool1, _bool2, _bool3, _bool4, _bool5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("bool1", "bool2", "bool3", "bool4", "bool5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJBoolean] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJBoolean, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJBoolean = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJBoolean])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJByte_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("b1", "b2", "b3", "b4", "b5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJByte, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("b1")
    out.value(in.b1)
    out.label("b2")
    out.value(in.b2)
    out.label("b3")
    out.value(in.b3)
    out.label("b4")
    out.value(in.b4)
    out.label("b5")
    out.value(in.b5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJByte = {
    var _b1: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var _b2: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var _b3: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var _b4: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var _b5: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJByte_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJByte] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _b1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _b3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _b4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _b5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJByte_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJByte(_b1, _b2, _b3, _b4, _b5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("b1", "b2", "b3", "b4", "b5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJByte] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJByte, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJByte = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJByte])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJByte_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("b1", "b2", "b3", "b4", "b5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJByte, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("b1")
    out.value(in.b1)
    out.label("b2")
    out.value(in.b2)
    out.label("b3")
    out.value(in.b3)
    out.label("b4")
    out.value(in.b4)
    out.label("b5")
    out.value(in.b5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJByte = {
    var _b1: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var _b2: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var _b3: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var _b4: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var _b5: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJByte_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJByte] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _b1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _b3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _b4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _b5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJByte_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJByte(_b1, _b2, _b3, _b4, _b5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("b1", "b2", "b3", "b4", "b5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJByte] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJByte, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJByte = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJByte])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJChar_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("c1", "c2", "c3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJChar, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("c1")
    out.value(in.c1)
    out.label("c2")
    out.value(in.c2)
    out.label("c3")
    out.value(in.c3)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJChar = {
    var _c1: java.lang.Character = java.lang.Character.valueOf('x')
    var _c2: java.lang.Character = java.lang.Character.valueOf('x')
    var _c3: java.lang.Character = java.lang.Character.valueOf('x')
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJChar_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJChar] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _c1 = {
                val c: java.lang.String = `in₂`.expectString()
                if (c.==(null)) null else if (c.length().==(0)) {
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Character value expected but empty string found in json", `in₂`)
                } else java.lang.Character.valueOf(c.charAt(0))
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _c2 = {
                val `c₂`: java.lang.String = `in₂`.expectString()
                if (`c₂`.==(null)) null else if (`c₂`.length().==(0)) {
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Character value expected but empty string found in json", `in₂`)
                } else java.lang.Character.valueOf(`c₂`.charAt(0))
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _c3 = {
                val `c₃`: java.lang.String = `in₂`.expectString()
                if (`c₃`.==(null)) null else if (`c₃`.length().==(0)) {
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Character value expected but empty string found in json", `in₂`)
                } else java.lang.Character.valueOf(`c₃`.charAt(0))
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c3"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJChar_fields)
      }
      if (required.&(7).==(0)) new co.blocke.scalajack.json.primitives.SampleJChar(_c1, _c2, _c3) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("c1", "c2", "c3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(7)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJChar] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJChar, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJChar = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJChar])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJChar_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("c1", "c2", "c3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJChar, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("c1")
    out.value(in.c1)
    out.label("c2")
    out.value(in.c2)
    out.label("c3")
    out.value(in.c3)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJChar = {
    var _c1: java.lang.Character = java.lang.Character.valueOf('x')
    var _c2: java.lang.Character = java.lang.Character.valueOf('x')
    var _c3: java.lang.Character = java.lang.Character.valueOf('x')
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJChar_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJChar] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _c1 = {
                val c: java.lang.String = `in₂`.expectString()
                if (c.==(null)) null else if (c.length().==(0)) {
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Character value expected but empty string found in json", `in₂`)
                } else java.lang.Character.valueOf(c.charAt(0))
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _c2 = {
                val `c₂`: java.lang.String = `in₂`.expectString()
                if (`c₂`.==(null)) null else if (`c₂`.length().==(0)) {
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Character value expected but empty string found in json", `in₂`)
                } else java.lang.Character.valueOf(`c₂`.charAt(0))
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _c3 = {
                val `c₃`: java.lang.String = `in₂`.expectString()
                if (`c₃`.==(null)) null else if (`c₃`.length().==(0)) {
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Character value expected but empty string found in json", `in₂`)
                } else java.lang.Character.valueOf(`c₃`.charAt(0))
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c3"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJChar_fields)
      }
      if (required.&(7).==(0)) new co.blocke.scalajack.json.primitives.SampleJChar(_c1, _c2, _c3) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("c1", "c2", "c3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(7)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJChar] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJChar, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJChar = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJChar])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJDouble_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4", "d5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJDouble, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.label("d4")
    out.value(in.d4)
    out.label("d5")
    out.value(in.d5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJDouble = {
    var _d1: java.lang.Double = java.lang.Double.valueOf(0.0)
    var _d2: java.lang.Double = java.lang.Double.valueOf(0.0)
    var _d3: java.lang.Double = java.lang.Double.valueOf(0.0)
    var _d4: java.lang.Double = java.lang.Double.valueOf(0.0)
    var _d5: java.lang.Double = java.lang.Double.valueOf(0.0)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJDouble_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJDouble] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Double.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Double.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Double.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _d4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Double.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _d5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Double.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJDouble_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJDouble(_d1, _d2, _d3, _d4, _d5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4", "d5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJDouble] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJDouble, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJDouble = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJDouble])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJDouble_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4", "d5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJDouble, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.label("d4")
    out.value(in.d4)
    out.label("d5")
    out.value(in.d5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJDouble = {
    var _d1: java.lang.Double = java.lang.Double.valueOf(0.0)
    var _d2: java.lang.Double = java.lang.Double.valueOf(0.0)
    var _d3: java.lang.Double = java.lang.Double.valueOf(0.0)
    var _d4: java.lang.Double = java.lang.Double.valueOf(0.0)
    var _d5: java.lang.Double = java.lang.Double.valueOf(0.0)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJDouble_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJDouble] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Double.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Double.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Double.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _d4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Double.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _d5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Double.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJDouble_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJDouble(_d1, _d2, _d3, _d4, _d5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4", "d5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJDouble] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJDouble, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJDouble = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJDouble])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJFloat_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("f1", "f2", "f3", "f4", "f5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJFloat, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("f1")
    out.value(in.f1)
    out.label("f2")
    out.value(in.f2)
    out.label("f3")
    out.value(in.f3)
    out.label("f4")
    out.value(in.f4)
    out.label("f5")
    out.value(in.f5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJFloat = {
    var _f1: java.lang.Float = java.lang.Float.valueOf(0.0f)
    var _f2: java.lang.Float = java.lang.Float.valueOf(0.0f)
    var _f3: java.lang.Float = java.lang.Float.valueOf(0.0f)
    var _f4: java.lang.Float = java.lang.Float.valueOf(0.0f)
    var _f5: java.lang.Float = java.lang.Float.valueOf(0.0f)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJFloat_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJFloat] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _f1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Float.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _f2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Float.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _f3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Float.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _f4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Float.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _f5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Float.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJFloat_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJFloat(_f1, _f2, _f3, _f4, _f5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("f1", "f2", "f3", "f4", "f5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJFloat] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJFloat, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJFloat = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJFloat])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJFloat_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("f1", "f2", "f3", "f4", "f5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJFloat, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("f1")
    out.value(in.f1)
    out.label("f2")
    out.value(in.f2)
    out.label("f3")
    out.value(in.f3)
    out.label("f4")
    out.value(in.f4)
    out.label("f5")
    out.value(in.f5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJFloat = {
    var _f1: java.lang.Float = java.lang.Float.valueOf(0.0f)
    var _f2: java.lang.Float = java.lang.Float.valueOf(0.0f)
    var _f3: java.lang.Float = java.lang.Float.valueOf(0.0f)
    var _f4: java.lang.Float = java.lang.Float.valueOf(0.0f)
    var _f5: java.lang.Float = java.lang.Float.valueOf(0.0f)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJFloat_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJFloat] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _f1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Float.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _f2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Float.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _f3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Float.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _f4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Float.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _f5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Float.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJFloat_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJFloat(_f1, _f2, _f3, _f4, _f5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("f1", "f2", "f3", "f4", "f5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJFloat] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJFloat, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJFloat = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJFloat])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJInt_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4", "i5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJInt, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("i1")
    out.value(in.i1)
    out.label("i2")
    out.value(in.i2)
    out.label("i3")
    out.value(in.i3)
    out.label("i4")
    out.value(in.i4)
    out.label("i5")
    out.value(in.i5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJInt = {
    var _i1: java.lang.Integer = java.lang.Integer.valueOf(0)
    var _i2: java.lang.Integer = java.lang.Integer.valueOf(0)
    var _i3: java.lang.Integer = java.lang.Integer.valueOf(0)
    var _i4: java.lang.Integer = java.lang.Integer.valueOf(0)
    var _i5: java.lang.Integer = java.lang.Integer.valueOf(0)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJInt_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJInt] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _i1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _i2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _i3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _i4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _i5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJInt_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJInt(_i1, _i2, _i3, _i4, _i5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4", "i5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJInt] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJInt, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJInt = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJInt])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJInt_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4", "i5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJInt, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("i1")
    out.value(in.i1)
    out.label("i2")
    out.value(in.i2)
    out.label("i3")
    out.value(in.i3)
    out.label("i4")
    out.value(in.i4)
    out.label("i5")
    out.value(in.i5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJInt = {
    var _i1: java.lang.Integer = java.lang.Integer.valueOf(0)
    var _i2: java.lang.Integer = java.lang.Integer.valueOf(0)
    var _i3: java.lang.Integer = java.lang.Integer.valueOf(0)
    var _i4: java.lang.Integer = java.lang.Integer.valueOf(0)
    var _i5: java.lang.Integer = java.lang.Integer.valueOf(0)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJInt_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJInt] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _i1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _i2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _i3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _i4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _i5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJInt_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJInt(_i1, _i2, _i3, _i4, _i5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4", "i5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJInt] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJInt, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJInt = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJInt])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJLong_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("l1", "l2", "l3", "l4", "l5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJLong, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("l1")
    out.value(in.l1)
    out.label("l2")
    out.value(in.l2)
    out.label("l3")
    out.value(in.l3)
    out.label("l4")
    out.value(in.l4)
    out.label("l5")
    out.value(in.l5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJLong = {
    var _l1: java.lang.Long = java.lang.Long.valueOf(0L)
    var _l2: java.lang.Long = java.lang.Long.valueOf(0L)
    var _l3: java.lang.Long = java.lang.Long.valueOf(0L)
    var _l4: java.lang.Long = java.lang.Long.valueOf(0L)
    var _l5: java.lang.Long = java.lang.Long.valueOf(0L)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJLong_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJLong] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _l1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _l2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _l3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _l4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _l5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJLong_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJLong(_l1, _l2, _l3, _l4, _l5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("l1", "l2", "l3", "l4", "l5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJLong] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJLong, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJLong = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJLong])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJLong_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("l1", "l2", "l3", "l4", "l5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJLong, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("l1")
    out.value(in.l1)
    out.label("l2")
    out.value(in.l2)
    out.label("l3")
    out.value(in.l3)
    out.label("l4")
    out.value(in.l4)
    out.label("l5")
    out.value(in.l5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJLong = {
    var _l1: java.lang.Long = java.lang.Long.valueOf(0L)
    var _l2: java.lang.Long = java.lang.Long.valueOf(0L)
    var _l3: java.lang.Long = java.lang.Long.valueOf(0L)
    var _l4: java.lang.Long = java.lang.Long.valueOf(0L)
    var _l5: java.lang.Long = java.lang.Long.valueOf(0L)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJLong_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJLong] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _l1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _l2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _l3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _l4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _l5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJLong_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJLong(_l1, _l2, _l3, _l4, _l5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("l1", "l2", "l3", "l4", "l5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJLong] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJLong, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJLong = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJLong])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJNumber_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("n1", "n2", "n3", "n4", "n5", "n6", "n7", "n8", "n9", "n10", "n11", "n12", "n13", "n14", "n15", "n16", "n17")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJNumber, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("n1")
    out.value(in.n1)
    out.label("n2")
    out.value(in.n2)
    out.label("n3")
    out.value(in.n3)
    out.label("n4")
    out.value(in.n4)
    out.label("n5")
    out.value(in.n5)
    out.label("n6")
    out.value(in.n6)
    out.label("n7")
    out.value(in.n7)
    out.label("n8")
    out.value(in.n8)
    out.label("n9")
    out.value(in.n9)
    out.label("n10")
    out.value(in.n10)
    out.label("n11")
    out.value(in.n11)
    out.label("n12")
    out.value(in.n12)
    out.label("n13")
    out.value(in.n13)
    out.label("n14")
    out.value(in.n14)
    out.label("n15")
    out.value(in.n15)
    out.label("n16")
    out.value(in.n16)
    out.label("n17")
    out.value(in.n17)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJNumber = {
    var _n1: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n2: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n3: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n4: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n5: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n6: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n7: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n8: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n9: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n10: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n11: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n12: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n13: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n14: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n15: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n16: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n17: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var required: scala.Int = 131071
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJNumber_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJNumber] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _n1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(n) match {
                    case d if d.isValidByte =>
                      java.lang.Byte.valueOf(d.toByteExact)
                    case d if `d₂`.isValidShort =>
                      java.lang.Short.valueOf(`d₂`.toShortExact)
                    case d if `d₃`.isValidInt =>
                      java.lang.Integer.valueOf(`d₃`.toIntExact)
                    case d if `d₄`.isValidLong =>
                      java.lang.Long.valueOf(`d₄`.toLongExact)
                    case d if `d₅`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₅`.toFloat)
                    case d if `d₆`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₆`.toDouble)
                    case d =>
                      (`d₇`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _n2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₂`) match {
                    case d if `d₈`.isValidByte =>
                      java.lang.Byte.valueOf(`d₈`.toByteExact)
                    case d if `d₉`.isValidShort =>
                      java.lang.Short.valueOf(`d₉`.toShortExact)
                    case d if `d₁₀`.isValidInt =>
                      java.lang.Integer.valueOf(`d₁₀`.toIntExact)
                    case d if `d₁₁`.isValidLong =>
                      java.lang.Long.valueOf(`d₁₁`.toLongExact)
                    case d if `d₁₂`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₁₂`.toFloat)
                    case d if `d₁₃`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₁₃`.toDouble)
                    case d =>
                      (`d₁₄`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _n3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₃`) match {
                    case d if `d₁₅`.isValidByte =>
                      java.lang.Byte.valueOf(`d₁₅`.toByteExact)
                    case d if `d₁₆`.isValidShort =>
                      java.lang.Short.valueOf(`d₁₆`.toShortExact)
                    case d if `d₁₇`.isValidInt =>
                      java.lang.Integer.valueOf(`d₁₇`.toIntExact)
                    case d if `d₁₈`.isValidLong =>
                      java.lang.Long.valueOf(`d₁₈`.toLongExact)
                    case d if `d₁₉`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₁₉`.toFloat)
                    case d if `d₂₀`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₂₀`.toDouble)
                    case d =>
                      (`d₂₁`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _n4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₄`) match {
                    case d if `d₂₂`.isValidByte =>
                      java.lang.Byte.valueOf(`d₂₂`.toByteExact)
                    case d if `d₂₃`.isValidShort =>
                      java.lang.Short.valueOf(`d₂₃`.toShortExact)
                    case d if `d₂₄`.isValidInt =>
                      java.lang.Integer.valueOf(`d₂₄`.toIntExact)
                    case d if `d₂₅`.isValidLong =>
                      java.lang.Long.valueOf(`d₂₅`.toLongExact)
                    case d if `d₂₆`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₂₆`.toFloat)
                    case d if `d₂₇`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₂₇`.toDouble)
                    case d =>
                      (`d₂₈`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _n5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₅`) match {
                    case d if `d₂₉`.isValidByte =>
                      java.lang.Byte.valueOf(`d₂₉`.toByteExact)
                    case d if `d₃₀`.isValidShort =>
                      java.lang.Short.valueOf(`d₃₀`.toShortExact)
                    case d if `d₃₁`.isValidInt =>
                      java.lang.Integer.valueOf(`d₃₁`.toIntExact)
                    case d if `d₃₂`.isValidLong =>
                      java.lang.Long.valueOf(`d₃₂`.toLongExact)
                    case d if `d₃₃`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₃₃`.toFloat)
                    case d if `d₃₄`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₃₄`.toDouble)
                    case d =>
                      (`d₃₅`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n5"), `in₂`)
          case 5 =>
            if (required.&(32).!=(0)) {
              required = required.^(32)
              _n6 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₆`) match {
                    case d if `d₃₆`.isValidByte =>
                      java.lang.Byte.valueOf(`d₃₆`.toByteExact)
                    case d if `d₃₇`.isValidShort =>
                      java.lang.Short.valueOf(`d₃₇`.toShortExact)
                    case d if `d₃₈`.isValidInt =>
                      java.lang.Integer.valueOf(`d₃₈`.toIntExact)
                    case d if `d₃₉`.isValidLong =>
                      java.lang.Long.valueOf(`d₃₉`.toLongExact)
                    case d if `d₄₀`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₄₀`.toFloat)
                    case d if `d₄₁`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₄₁`.toDouble)
                    case d =>
                      (`d₄₂`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n6"), `in₂`)
          case 6 =>
            if (required.&(64).!=(0)) {
              required = required.^(64)
              _n7 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₇`) match {
                    case d if `d₄₃`.isValidByte =>
                      java.lang.Byte.valueOf(`d₄₃`.toByteExact)
                    case d if `d₄₄`.isValidShort =>
                      java.lang.Short.valueOf(`d₄₄`.toShortExact)
                    case d if `d₄₅`.isValidInt =>
                      java.lang.Integer.valueOf(`d₄₅`.toIntExact)
                    case d if `d₄₆`.isValidLong =>
                      java.lang.Long.valueOf(`d₄₆`.toLongExact)
                    case d if `d₄₇`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₄₇`.toFloat)
                    case d if `d₄₈`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₄₈`.toDouble)
                    case d =>
                      (`d₄₉`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n7"), `in₂`)
          case 7 =>
            if (required.&(128).!=(0)) {
              required = required.^(128)
              _n8 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₈`) match {
                    case d if `d₅₀`.isValidByte =>
                      java.lang.Byte.valueOf(`d₅₀`.toByteExact)
                    case d if `d₅₁`.isValidShort =>
                      java.lang.Short.valueOf(`d₅₁`.toShortExact)
                    case d if `d₅₂`.isValidInt =>
                      java.lang.Integer.valueOf(`d₅₂`.toIntExact)
                    case d if `d₅₃`.isValidLong =>
                      java.lang.Long.valueOf(`d₅₃`.toLongExact)
                    case d if `d₅₄`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₅₄`.toFloat)
                    case d if `d₅₅`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₅₅`.toDouble)
                    case d =>
                      (`d₅₆`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n8"), `in₂`)
          case 8 =>
            if (required.&(256).!=(0)) {
              required = required.^(256)
              _n9 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₉`) match {
                    case d if `d₅₇`.isValidByte =>
                      java.lang.Byte.valueOf(`d₅₇`.toByteExact)
                    case d if `d₅₈`.isValidShort =>
                      java.lang.Short.valueOf(`d₅₈`.toShortExact)
                    case d if `d₅₉`.isValidInt =>
                      java.lang.Integer.valueOf(`d₅₉`.toIntExact)
                    case d if `d₆₀`.isValidLong =>
                      java.lang.Long.valueOf(`d₆₀`.toLongExact)
                    case d if `d₆₁`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₆₁`.toFloat)
                    case d if `d₆₂`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₆₂`.toDouble)
                    case d =>
                      (`d₆₃`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n9"), `in₂`)
          case 9 =>
            if (required.&(512).!=(0)) {
              required = required.^(512)
              _n10 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₀`) match {
                    case d if `d₆₄`.isValidByte =>
                      java.lang.Byte.valueOf(`d₆₄`.toByteExact)
                    case d if `d₆₅`.isValidShort =>
                      java.lang.Short.valueOf(`d₆₅`.toShortExact)
                    case d if `d₆₆`.isValidInt =>
                      java.lang.Integer.valueOf(`d₆₆`.toIntExact)
                    case d if `d₆₇`.isValidLong =>
                      java.lang.Long.valueOf(`d₆₇`.toLongExact)
                    case d if `d₆₈`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₆₈`.toFloat)
                    case d if `d₆₉`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₆₉`.toDouble)
                    case d =>
                      (`d₇₀`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n10"), `in₂`)
          case 10 =>
            if (required.&(1024).!=(0)) {
              required = required.^(1024)
              _n11 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₁`) match {
                    case d if `d₇₁`.isValidByte =>
                      java.lang.Byte.valueOf(`d₇₁`.toByteExact)
                    case d if `d₇₂`.isValidShort =>
                      java.lang.Short.valueOf(`d₇₂`.toShortExact)
                    case d if `d₇₃`.isValidInt =>
                      java.lang.Integer.valueOf(`d₇₃`.toIntExact)
                    case d if `d₇₄`.isValidLong =>
                      java.lang.Long.valueOf(`d₇₄`.toLongExact)
                    case d if `d₇₅`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₇₅`.toFloat)
                    case d if `d₇₆`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₇₆`.toDouble)
                    case d =>
                      (`d₇₇`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n11"), `in₂`)
          case 11 =>
            if (required.&(2048).!=(0)) {
              required = required.^(2048)
              _n12 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₂`) match {
                    case d if `d₇₈`.isValidByte =>
                      java.lang.Byte.valueOf(`d₇₈`.toByteExact)
                    case d if `d₇₉`.isValidShort =>
                      java.lang.Short.valueOf(`d₇₉`.toShortExact)
                    case d if `d₈₀`.isValidInt =>
                      java.lang.Integer.valueOf(`d₈₀`.toIntExact)
                    case d if `d₈₁`.isValidLong =>
                      java.lang.Long.valueOf(`d₈₁`.toLongExact)
                    case d if `d₈₂`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₈₂`.toFloat)
                    case d if `d₈₃`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₈₃`.toDouble)
                    case d =>
                      (`d₈₄`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n12"), `in₂`)
          case 12 =>
            if (required.&(4096).!=(0)) {
              required = required.^(4096)
              _n13 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₃`) match {
                    case d if `d₈₅`.isValidByte =>
                      java.lang.Byte.valueOf(`d₈₅`.toByteExact)
                    case d if `d₈₆`.isValidShort =>
                      java.lang.Short.valueOf(`d₈₆`.toShortExact)
                    case d if `d₈₇`.isValidInt =>
                      java.lang.Integer.valueOf(`d₈₇`.toIntExact)
                    case d if `d₈₈`.isValidLong =>
                      java.lang.Long.valueOf(`d₈₈`.toLongExact)
                    case d if `d₈₉`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₈₉`.toFloat)
                    case d if `d₉₀`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₉₀`.toDouble)
                    case d =>
                      (`d₉₁`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n13"), `in₂`)
          case 13 =>
            if (required.&(8192).!=(0)) {
              required = required.^(8192)
              _n14 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₄`) match {
                    case d if `d₉₂`.isValidByte =>
                      java.lang.Byte.valueOf(`d₉₂`.toByteExact)
                    case d if `d₉₃`.isValidShort =>
                      java.lang.Short.valueOf(`d₉₃`.toShortExact)
                    case d if `d₉₄`.isValidInt =>
                      java.lang.Integer.valueOf(`d₉₄`.toIntExact)
                    case d if `d₉₅`.isValidLong =>
                      java.lang.Long.valueOf(`d₉₅`.toLongExact)
                    case d if `d₉₆`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₉₆`.toFloat)
                    case d if `d₉₇`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₉₇`.toDouble)
                    case d =>
                      (`d₉₈`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n14"), `in₂`)
          case 14 =>
            if (required.&(16384).!=(0)) {
              required = required.^(16384)
              _n15 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₅`) match {
                    case d if `d₉₉`.isValidByte =>
                      java.lang.Byte.valueOf(`d₉₉`.toByteExact)
                    case d if `d₁₀₀`.isValidShort =>
                      java.lang.Short.valueOf(`d₁₀₀`.toShortExact)
                    case d if `d₁₀₁`.isValidInt =>
                      java.lang.Integer.valueOf(`d₁₀₁`.toIntExact)
                    case d if `d₁₀₂`.isValidLong =>
                      java.lang.Long.valueOf(`d₁₀₂`.toLongExact)
                    case d if `d₁₀₃`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₁₀₃`.toFloat)
                    case d if `d₁₀₄`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₁₀₄`.toDouble)
                    case d =>
                      (`d₁₀₅`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n15"), `in₂`)
          case 15 =>
            if (required.&(32768).!=(0)) {
              required = required.^(32768)
              _n16 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₆`) match {
                    case d if `d₁₀₆`.isValidByte =>
                      java.lang.Byte.valueOf(`d₁₀₆`.toByteExact)
                    case d if `d₁₀₇`.isValidShort =>
                      java.lang.Short.valueOf(`d₁₀₇`.toShortExact)
                    case d if `d₁₀₈`.isValidInt =>
                      java.lang.Integer.valueOf(`d₁₀₈`.toIntExact)
                    case d if `d₁₀₉`.isValidLong =>
                      java.lang.Long.valueOf(`d₁₀₉`.toLongExact)
                    case d if `d₁₁₀`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₁₁₀`.toFloat)
                    case d if `d₁₁₁`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₁₁₁`.toDouble)
                    case d =>
                      (`d₁₁₂`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n16"), `in₂`)
          case 16 =>
            if (required.&(65536).!=(0)) {
              required = required.^(65536)
              _n17 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₇`) match {
                    case d if `d₁₁₃`.isValidByte =>
                      java.lang.Byte.valueOf(`d₁₁₃`.toByteExact)
                    case d if `d₁₁₄`.isValidShort =>
                      java.lang.Short.valueOf(`d₁₁₄`.toShortExact)
                    case d if `d₁₁₅`.isValidInt =>
                      java.lang.Integer.valueOf(`d₁₁₅`.toIntExact)
                    case d if `d₁₁₆`.isValidLong =>
                      java.lang.Long.valueOf(`d₁₁₆`.toLongExact)
                    case d if `d₁₁₇`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₁₁₇`.toFloat)
                    case d if `d₁₁₈`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₁₁₈`.toDouble)
                    case d =>
                      (`d₁₁₉`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n17"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJNumber_fields)
      }
      if (required.&(131071).==(0)) new co.blocke.scalajack.json.primitives.SampleJNumber(_n1, _n2, _n3, _n4, _n5, _n6, _n7, _n8, _n9, _n10, _n11, _n12, _n13, _n14, _n15, _n16, _n17) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("n1", "n2", "n3", "n4", "n5", "n6", "n7", "n8", "n9", "n10", "n11", "n12", "n13", "n14", "n15", "n16", "n17")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(131071)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJNumber] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJNumber, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJNumber = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJNumber])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJNumber_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("n1", "n2", "n3", "n4", "n5", "n6", "n7", "n8", "n9", "n10", "n11", "n12", "n13", "n14", "n15", "n16", "n17")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJNumber, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("n1")
    out.value(in.n1)
    out.label("n2")
    out.value(in.n2)
    out.label("n3")
    out.value(in.n3)
    out.label("n4")
    out.value(in.n4)
    out.label("n5")
    out.value(in.n5)
    out.label("n6")
    out.value(in.n6)
    out.label("n7")
    out.value(in.n7)
    out.label("n8")
    out.value(in.n8)
    out.label("n9")
    out.value(in.n9)
    out.label("n10")
    out.value(in.n10)
    out.label("n11")
    out.value(in.n11)
    out.label("n12")
    out.value(in.n12)
    out.label("n13")
    out.value(in.n13)
    out.label("n14")
    out.value(in.n14)
    out.label("n15")
    out.value(in.n15)
    out.label("n16")
    out.value(in.n16)
    out.label("n17")
    out.value(in.n17)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJNumber = {
    var _n1: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n2: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n3: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n4: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n5: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n6: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n7: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n8: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n9: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n10: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n11: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n12: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n13: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n14: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n15: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n16: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n17: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var required: scala.Int = 131071
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJNumber_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJNumber] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _n1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(n) match {
                    case d if d.isValidByte =>
                      java.lang.Byte.valueOf(d.toByteExact)
                    case d if `d₂`.isValidShort =>
                      java.lang.Short.valueOf(`d₂`.toShortExact)
                    case d if `d₃`.isValidInt =>
                      java.lang.Integer.valueOf(`d₃`.toIntExact)
                    case d if `d₄`.isValidLong =>
                      java.lang.Long.valueOf(`d₄`.toLongExact)
                    case d if `d₅`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₅`.toFloat)
                    case d if `d₆`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₆`.toDouble)
                    case d =>
                      (`d₇`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _n2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₂`) match {
                    case d if `d₈`.isValidByte =>
                      java.lang.Byte.valueOf(`d₈`.toByteExact)
                    case d if `d₉`.isValidShort =>
                      java.lang.Short.valueOf(`d₉`.toShortExact)
                    case d if `d₁₀`.isValidInt =>
                      java.lang.Integer.valueOf(`d₁₀`.toIntExact)
                    case d if `d₁₁`.isValidLong =>
                      java.lang.Long.valueOf(`d₁₁`.toLongExact)
                    case d if `d₁₂`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₁₂`.toFloat)
                    case d if `d₁₃`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₁₃`.toDouble)
                    case d =>
                      (`d₁₄`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _n3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₃`) match {
                    case d if `d₁₅`.isValidByte =>
                      java.lang.Byte.valueOf(`d₁₅`.toByteExact)
                    case d if `d₁₆`.isValidShort =>
                      java.lang.Short.valueOf(`d₁₆`.toShortExact)
                    case d if `d₁₇`.isValidInt =>
                      java.lang.Integer.valueOf(`d₁₇`.toIntExact)
                    case d if `d₁₈`.isValidLong =>
                      java.lang.Long.valueOf(`d₁₈`.toLongExact)
                    case d if `d₁₉`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₁₉`.toFloat)
                    case d if `d₂₀`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₂₀`.toDouble)
                    case d =>
                      (`d₂₁`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _n4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₄`) match {
                    case d if `d₂₂`.isValidByte =>
                      java.lang.Byte.valueOf(`d₂₂`.toByteExact)
                    case d if `d₂₃`.isValidShort =>
                      java.lang.Short.valueOf(`d₂₃`.toShortExact)
                    case d if `d₂₄`.isValidInt =>
                      java.lang.Integer.valueOf(`d₂₄`.toIntExact)
                    case d if `d₂₅`.isValidLong =>
                      java.lang.Long.valueOf(`d₂₅`.toLongExact)
                    case d if `d₂₆`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₂₆`.toFloat)
                    case d if `d₂₇`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₂₇`.toDouble)
                    case d =>
                      (`d₂₈`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _n5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₅`) match {
                    case d if `d₂₉`.isValidByte =>
                      java.lang.Byte.valueOf(`d₂₉`.toByteExact)
                    case d if `d₃₀`.isValidShort =>
                      java.lang.Short.valueOf(`d₃₀`.toShortExact)
                    case d if `d₃₁`.isValidInt =>
                      java.lang.Integer.valueOf(`d₃₁`.toIntExact)
                    case d if `d₃₂`.isValidLong =>
                      java.lang.Long.valueOf(`d₃₂`.toLongExact)
                    case d if `d₃₃`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₃₃`.toFloat)
                    case d if `d₃₄`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₃₄`.toDouble)
                    case d =>
                      (`d₃₅`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n5"), `in₂`)
          case 5 =>
            if (required.&(32).!=(0)) {
              required = required.^(32)
              _n6 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₆`) match {
                    case d if `d₃₆`.isValidByte =>
                      java.lang.Byte.valueOf(`d₃₆`.toByteExact)
                    case d if `d₃₇`.isValidShort =>
                      java.lang.Short.valueOf(`d₃₇`.toShortExact)
                    case d if `d₃₈`.isValidInt =>
                      java.lang.Integer.valueOf(`d₃₈`.toIntExact)
                    case d if `d₃₉`.isValidLong =>
                      java.lang.Long.valueOf(`d₃₉`.toLongExact)
                    case d if `d₄₀`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₄₀`.toFloat)
                    case d if `d₄₁`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₄₁`.toDouble)
                    case d =>
                      (`d₄₂`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n6"), `in₂`)
          case 6 =>
            if (required.&(64).!=(0)) {
              required = required.^(64)
              _n7 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₇`) match {
                    case d if `d₄₃`.isValidByte =>
                      java.lang.Byte.valueOf(`d₄₃`.toByteExact)
                    case d if `d₄₄`.isValidShort =>
                      java.lang.Short.valueOf(`d₄₄`.toShortExact)
                    case d if `d₄₅`.isValidInt =>
                      java.lang.Integer.valueOf(`d₄₅`.toIntExact)
                    case d if `d₄₆`.isValidLong =>
                      java.lang.Long.valueOf(`d₄₆`.toLongExact)
                    case d if `d₄₇`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₄₇`.toFloat)
                    case d if `d₄₈`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₄₈`.toDouble)
                    case d =>
                      (`d₄₉`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n7"), `in₂`)
          case 7 =>
            if (required.&(128).!=(0)) {
              required = required.^(128)
              _n8 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₈`) match {
                    case d if `d₅₀`.isValidByte =>
                      java.lang.Byte.valueOf(`d₅₀`.toByteExact)
                    case d if `d₅₁`.isValidShort =>
                      java.lang.Short.valueOf(`d₅₁`.toShortExact)
                    case d if `d₅₂`.isValidInt =>
                      java.lang.Integer.valueOf(`d₅₂`.toIntExact)
                    case d if `d₅₃`.isValidLong =>
                      java.lang.Long.valueOf(`d₅₃`.toLongExact)
                    case d if `d₅₄`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₅₄`.toFloat)
                    case d if `d₅₅`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₅₅`.toDouble)
                    case d =>
                      (`d₅₆`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n8"), `in₂`)
          case 8 =>
            if (required.&(256).!=(0)) {
              required = required.^(256)
              _n9 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₉`) match {
                    case d if `d₅₇`.isValidByte =>
                      java.lang.Byte.valueOf(`d₅₇`.toByteExact)
                    case d if `d₅₈`.isValidShort =>
                      java.lang.Short.valueOf(`d₅₈`.toShortExact)
                    case d if `d₅₉`.isValidInt =>
                      java.lang.Integer.valueOf(`d₅₉`.toIntExact)
                    case d if `d₆₀`.isValidLong =>
                      java.lang.Long.valueOf(`d₆₀`.toLongExact)
                    case d if `d₆₁`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₆₁`.toFloat)
                    case d if `d₆₂`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₆₂`.toDouble)
                    case d =>
                      (`d₆₃`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n9"), `in₂`)
          case 9 =>
            if (required.&(512).!=(0)) {
              required = required.^(512)
              _n10 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₀`) match {
                    case d if `d₆₄`.isValidByte =>
                      java.lang.Byte.valueOf(`d₆₄`.toByteExact)
                    case d if `d₆₅`.isValidShort =>
                      java.lang.Short.valueOf(`d₆₅`.toShortExact)
                    case d if `d₆₆`.isValidInt =>
                      java.lang.Integer.valueOf(`d₆₆`.toIntExact)
                    case d if `d₆₇`.isValidLong =>
                      java.lang.Long.valueOf(`d₆₇`.toLongExact)
                    case d if `d₆₈`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₆₈`.toFloat)
                    case d if `d₆₉`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₆₉`.toDouble)
                    case d =>
                      (`d₇₀`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n10"), `in₂`)
          case 10 =>
            if (required.&(1024).!=(0)) {
              required = required.^(1024)
              _n11 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₁`) match {
                    case d if `d₇₁`.isValidByte =>
                      java.lang.Byte.valueOf(`d₇₁`.toByteExact)
                    case d if `d₇₂`.isValidShort =>
                      java.lang.Short.valueOf(`d₇₂`.toShortExact)
                    case d if `d₇₃`.isValidInt =>
                      java.lang.Integer.valueOf(`d₇₃`.toIntExact)
                    case d if `d₇₄`.isValidLong =>
                      java.lang.Long.valueOf(`d₇₄`.toLongExact)
                    case d if `d₇₅`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₇₅`.toFloat)
                    case d if `d₇₆`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₇₆`.toDouble)
                    case d =>
                      (`d₇₇`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n11"), `in₂`)
          case 11 =>
            if (required.&(2048).!=(0)) {
              required = required.^(2048)
              _n12 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₂`) match {
                    case d if `d₇₈`.isValidByte =>
                      java.lang.Byte.valueOf(`d₇₈`.toByteExact)
                    case d if `d₇₉`.isValidShort =>
                      java.lang.Short.valueOf(`d₇₉`.toShortExact)
                    case d if `d₈₀`.isValidInt =>
                      java.lang.Integer.valueOf(`d₈₀`.toIntExact)
                    case d if `d₈₁`.isValidLong =>
                      java.lang.Long.valueOf(`d₈₁`.toLongExact)
                    case d if `d₈₂`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₈₂`.toFloat)
                    case d if `d₈₃`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₈₃`.toDouble)
                    case d =>
                      (`d₈₄`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n12"), `in₂`)
          case 12 =>
            if (required.&(4096).!=(0)) {
              required = required.^(4096)
              _n13 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₃`) match {
                    case d if `d₈₅`.isValidByte =>
                      java.lang.Byte.valueOf(`d₈₅`.toByteExact)
                    case d if `d₈₆`.isValidShort =>
                      java.lang.Short.valueOf(`d₈₆`.toShortExact)
                    case d if `d₈₇`.isValidInt =>
                      java.lang.Integer.valueOf(`d₈₇`.toIntExact)
                    case d if `d₈₈`.isValidLong =>
                      java.lang.Long.valueOf(`d₈₈`.toLongExact)
                    case d if `d₈₉`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₈₉`.toFloat)
                    case d if `d₉₀`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₉₀`.toDouble)
                    case d =>
                      (`d₉₁`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n13"), `in₂`)
          case 13 =>
            if (required.&(8192).!=(0)) {
              required = required.^(8192)
              _n14 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₄`) match {
                    case d if `d₉₂`.isValidByte =>
                      java.lang.Byte.valueOf(`d₉₂`.toByteExact)
                    case d if `d₉₃`.isValidShort =>
                      java.lang.Short.valueOf(`d₉₃`.toShortExact)
                    case d if `d₉₄`.isValidInt =>
                      java.lang.Integer.valueOf(`d₉₄`.toIntExact)
                    case d if `d₉₅`.isValidLong =>
                      java.lang.Long.valueOf(`d₉₅`.toLongExact)
                    case d if `d₉₆`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₉₆`.toFloat)
                    case d if `d₉₇`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₉₇`.toDouble)
                    case d =>
                      (`d₉₈`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n14"), `in₂`)
          case 14 =>
            if (required.&(16384).!=(0)) {
              required = required.^(16384)
              _n15 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₅`) match {
                    case d if `d₉₉`.isValidByte =>
                      java.lang.Byte.valueOf(`d₉₉`.toByteExact)
                    case d if `d₁₀₀`.isValidShort =>
                      java.lang.Short.valueOf(`d₁₀₀`.toShortExact)
                    case d if `d₁₀₁`.isValidInt =>
                      java.lang.Integer.valueOf(`d₁₀₁`.toIntExact)
                    case d if `d₁₀₂`.isValidLong =>
                      java.lang.Long.valueOf(`d₁₀₂`.toLongExact)
                    case d if `d₁₀₃`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₁₀₃`.toFloat)
                    case d if `d₁₀₄`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₁₀₄`.toDouble)
                    case d =>
                      (`d₁₀₅`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n15"), `in₂`)
          case 15 =>
            if (required.&(32768).!=(0)) {
              required = required.^(32768)
              _n16 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₆`) match {
                    case d if `d₁₀₆`.isValidByte =>
                      java.lang.Byte.valueOf(`d₁₀₆`.toByteExact)
                    case d if `d₁₀₇`.isValidShort =>
                      java.lang.Short.valueOf(`d₁₀₇`.toShortExact)
                    case d if `d₁₀₈`.isValidInt =>
                      java.lang.Integer.valueOf(`d₁₀₈`.toIntExact)
                    case d if `d₁₀₉`.isValidLong =>
                      java.lang.Long.valueOf(`d₁₀₉`.toLongExact)
                    case d if `d₁₁₀`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₁₁₀`.toFloat)
                    case d if `d₁₁₁`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₁₁₁`.toDouble)
                    case d =>
                      (`d₁₁₂`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n16"), `in₂`)
          case 16 =>
            if (required.&(65536).!=(0)) {
              required = required.^(65536)
              _n17 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₇`) match {
                    case d if `d₁₁₃`.isValidByte =>
                      java.lang.Byte.valueOf(`d₁₁₃`.toByteExact)
                    case d if `d₁₁₄`.isValidShort =>
                      java.lang.Short.valueOf(`d₁₁₄`.toShortExact)
                    case d if `d₁₁₅`.isValidInt =>
                      java.lang.Integer.valueOf(`d₁₁₅`.toIntExact)
                    case d if `d₁₁₆`.isValidLong =>
                      java.lang.Long.valueOf(`d₁₁₆`.toLongExact)
                    case d if `d₁₁₇`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₁₁₇`.toFloat)
                    case d if `d₁₁₈`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₁₁₈`.toDouble)
                    case d =>
                      (`d₁₁₉`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n17"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJNumber_fields)
      }
      if (required.&(131071).==(0)) new co.blocke.scalajack.json.primitives.SampleJNumber(_n1, _n2, _n3, _n4, _n5, _n6, _n7, _n8, _n9, _n10, _n11, _n12, _n13, _n14, _n15, _n16, _n17) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("n1", "n2", "n3", "n4", "n5", "n6", "n7", "n8", "n9", "n10", "n11", "n12", "n13", "n14", "n15", "n16", "n17")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(131071)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJNumber] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJNumber, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJNumber = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJNumber])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJShort_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("s1", "s2", "s3", "s4", "s5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJShort, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("s1")
    out.value(in.s1)
    out.label("s2")
    out.value(in.s2)
    out.label("s3")
    out.value(in.s3)
    out.label("s4")
    out.value(in.s4)
    out.label("s5")
    out.value(in.s5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJShort = {
    var _s1: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var _s2: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var _s3: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var _s4: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var _s5: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJShort_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJShort] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _s1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _s2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _s3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _s4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _s5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJShort_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJShort(_s1, _s2, _s3, _s4, _s5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("s1", "s2", "s3", "s4", "s5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJShort] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJShort, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJShort = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJShort])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJShort_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("s1", "s2", "s3", "s4", "s5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJShort, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("s1")
    out.value(in.s1)
    out.label("s2")
    out.value(in.s2)
    out.label("s3")
    out.value(in.s3)
    out.label("s4")
    out.value(in.s4)
    out.label("s5")
    out.value(in.s5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJShort = {
    var _s1: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var _s2: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var _s3: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var _s4: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var _s5: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJShort_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJShort] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _s1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _s2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _s3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _s4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _s5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJShort_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJShort(_s1, _s2, _s3, _s4, _s5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("s1", "s2", "s3", "s4", "s5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJShort] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJShort, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJShort = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJShort])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJBigDecimal_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("bd1", "bd2", "bd3", "bd4", "bd5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJBigDecimal, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("bd1")
    out.value(in.bd1)
    out.label("bd2")
    out.value(in.bd2)
    out.label("bd3")
    out.value(in.bd3)
    out.label("bd4")
    out.value(in.bd4)
    out.label("bd5")
    out.value(in.bd5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJBigDecimal = {
    var _bd1: java.math.BigDecimal = new java.math.BigDecimal(0.0)
    var _bd2: java.math.BigDecimal = new java.math.BigDecimal(0.0)
    var _bd3: java.math.BigDecimal = new java.math.BigDecimal(0.0)
    var _bd4: java.math.BigDecimal = new java.math.BigDecimal(0.0)
    var _bd5: java.math.BigDecimal = new java.math.BigDecimal(0.0)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJBigDecimal_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJBigDecimal] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _bd1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigDecimal(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _bd2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigDecimal(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _bd3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigDecimal(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _bd4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigDecimal(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _bd5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigDecimal(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJBigDecimal_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJBigDecimal(_bd1, _bd2, _bd3, _bd4, _bd5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("bd1", "bd2", "bd3", "bd4", "bd5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJBigDecimal] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJBigDecimal, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJBigDecimal = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJBigDecimal])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJBigInteger_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("bi1", "bi2", "bi3", "bi4", "bi5", "bi6", "bi7")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJBigInteger, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("bi1")
    out.value(in.bi1)
    out.label("bi2")
    out.value(in.bi2)
    out.label("bi3")
    out.value(in.bi3)
    out.label("bi4")
    out.value(in.bi4)
    out.label("bi5")
    out.value(in.bi5)
    out.label("bi6")
    out.value(in.bi6)
    out.label("bi7")
    out.value(in.bi7)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJBigInteger = {
    var _bi1: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var _bi2: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var _bi3: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var _bi4: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var _bi5: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var _bi6: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var _bi7: java.math.BigInteger = java.math.BigInteger.valueOf(0L)
    var required: scala.Int = 127
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJBigInteger_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJBigInteger] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _bi1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _bi2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _bi3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _bi4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _bi5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi5"), `in₂`)
          case 5 =>
            if (required.&(32).!=(0)) {
              required = required.^(32)
              _bi6 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(`n₆`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi6"), `in₂`)
          case 6 =>
            if (required.&(64).!=(0)) {
              required = required.^(64)
              _bi7 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  new java.math.BigInteger(`n₇`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi7"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJBigInteger_fields)
      }
      if (required.&(127).==(0)) new co.blocke.scalajack.json.primitives.SampleJBigInteger(_bi1, _bi2, _bi3, _bi4, _bi5, _bi6, _bi7) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("bi1", "bi2", "bi3", "bi4", "bi5", "bi6", "bi7")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(127)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJBigInteger] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJBigInteger, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJBigInteger = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJBigInteger])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJBoolean_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("bool1", "bool2", "bool3", "bool4", "bool5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJBoolean, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("bool1")
    out.value(in.bool1)
    out.label("bool2")
    out.value(in.bool2)
    out.label("bool3")
    out.value(in.bool3)
    out.label("bool4")
    out.value(in.bool4)
    out.label("bool5")
    out.value(in.bool5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJBoolean = {
    var _bool1: java.lang.Boolean = java.lang.Boolean.FALSE
    var _bool2: java.lang.Boolean = java.lang.Boolean.FALSE
    var _bool3: java.lang.Boolean = java.lang.Boolean.FALSE
    var _bool4: java.lang.Boolean = java.lang.Boolean.FALSE
    var _bool5: java.lang.Boolean = java.lang.Boolean.FALSE
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJBoolean_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJBoolean] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _bool1 = `in₂`.expectJavaBoolean()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bool1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _bool2 = `in₂`.expectJavaBoolean()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bool2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _bool3 = `in₂`.expectJavaBoolean()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bool3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _bool4 = `in₂`.expectJavaBoolean()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bool4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _bool5 = `in₂`.expectJavaBoolean()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bool5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJBoolean_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJBoolean(_bool1, _bool2, _bool3, _bool4, _bool5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("bool1", "bool2", "bool3", "bool4", "bool5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJBoolean] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJBoolean, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJBoolean = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJBoolean])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJByte_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("b1", "b2", "b3", "b4", "b5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJByte, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("b1")
    out.value(in.b1)
    out.label("b2")
    out.value(in.b2)
    out.label("b3")
    out.value(in.b3)
    out.label("b4")
    out.value(in.b4)
    out.label("b5")
    out.value(in.b5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJByte = {
    var _b1: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var _b2: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var _b3: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var _b4: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var _b5: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJByte_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJByte] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _b1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _b3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _b4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _b5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJByte_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJByte(_b1, _b2, _b3, _b4, _b5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("b1", "b2", "b3", "b4", "b5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJByte] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJByte, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJByte = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJByte])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJChar_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("c1", "c2", "c3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJChar, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("c1")
    out.value(in.c1)
    out.label("c2")
    out.value(in.c2)
    out.label("c3")
    out.value(in.c3)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJChar = {
    var _c1: java.lang.Character = java.lang.Character.valueOf('x')
    var _c2: java.lang.Character = java.lang.Character.valueOf('x')
    var _c3: java.lang.Character = java.lang.Character.valueOf('x')
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJChar_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJChar] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _c1 = {
                val c: java.lang.String = `in₂`.expectString()
                if (c.==(null)) null else if (c.length().==(0)) {
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Character value expected but empty string found in json", `in₂`)
                } else java.lang.Character.valueOf(c.charAt(0))
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _c2 = {
                val `c₂`: java.lang.String = `in₂`.expectString()
                if (`c₂`.==(null)) null else if (`c₂`.length().==(0)) {
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Character value expected but empty string found in json", `in₂`)
                } else java.lang.Character.valueOf(`c₂`.charAt(0))
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _c3 = {
                val `c₃`: java.lang.String = `in₂`.expectString()
                if (`c₃`.==(null)) null else if (`c₃`.length().==(0)) {
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Character value expected but empty string found in json", `in₂`)
                } else java.lang.Character.valueOf(`c₃`.charAt(0))
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c3"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJChar_fields)
      }
      if (required.&(7).==(0)) new co.blocke.scalajack.json.primitives.SampleJChar(_c1, _c2, _c3) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("c1", "c2", "c3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(7)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJChar] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJChar, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJChar = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJChar])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJChar_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("c1", "c2", "c3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJChar, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("c1")
    out.value(in.c1)
    out.label("c2")
    out.value(in.c2)
    out.label("c3")
    out.value(in.c3)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJChar = {
    var _c1: java.lang.Character = java.lang.Character.valueOf('x')
    var _c2: java.lang.Character = java.lang.Character.valueOf('x')
    var _c3: java.lang.Character = java.lang.Character.valueOf('x')
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJChar_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJChar] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _c1 = {
                val c: java.lang.String = `in₂`.expectString()
                if (c.==(null)) null else if (c.length().==(0)) {
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Character value expected but empty string found in json", `in₂`)
                } else java.lang.Character.valueOf(c.charAt(0))
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _c2 = {
                val `c₂`: java.lang.String = `in₂`.expectString()
                if (`c₂`.==(null)) null else if (`c₂`.length().==(0)) {
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Character value expected but empty string found in json", `in₂`)
                } else java.lang.Character.valueOf(`c₂`.charAt(0))
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _c3 = {
                val `c₃`: java.lang.String = `in₂`.expectString()
                if (`c₃`.==(null)) null else if (`c₃`.length().==(0)) {
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Character value expected but empty string found in json", `in₂`)
                } else java.lang.Character.valueOf(`c₃`.charAt(0))
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c3"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJChar_fields)
      }
      if (required.&(7).==(0)) new co.blocke.scalajack.json.primitives.SampleJChar(_c1, _c2, _c3) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("c1", "c2", "c3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(7)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJChar] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJChar, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJChar = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJChar])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJChar_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("c1", "c2", "c3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJChar, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("c1")
    out.value(in.c1)
    out.label("c2")
    out.value(in.c2)
    out.label("c3")
    out.value(in.c3)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJChar = {
    var _c1: java.lang.Character = java.lang.Character.valueOf('x')
    var _c2: java.lang.Character = java.lang.Character.valueOf('x')
    var _c3: java.lang.Character = java.lang.Character.valueOf('x')
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJChar_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJChar] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _c1 = {
                val c: java.lang.String = `in₂`.expectString()
                if (c.==(null)) null else if (c.length().==(0)) {
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Character value expected but empty string found in json", `in₂`)
                } else java.lang.Character.valueOf(c.charAt(0))
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _c2 = {
                val `c₂`: java.lang.String = `in₂`.expectString()
                if (`c₂`.==(null)) null else if (`c₂`.length().==(0)) {
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Character value expected but empty string found in json", `in₂`)
                } else java.lang.Character.valueOf(`c₂`.charAt(0))
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _c3 = {
                val `c₃`: java.lang.String = `in₂`.expectString()
                if (`c₃`.==(null)) null else if (`c₃`.length().==(0)) {
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Character value expected but empty string found in json", `in₂`)
                } else java.lang.Character.valueOf(`c₃`.charAt(0))
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c3"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJChar_fields)
      }
      if (required.&(7).==(0)) new co.blocke.scalajack.json.primitives.SampleJChar(_c1, _c2, _c3) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("c1", "c2", "c3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(7)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJChar] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJChar, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJChar = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJChar])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJDouble_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4", "d5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJDouble, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.label("d4")
    out.value(in.d4)
    out.label("d5")
    out.value(in.d5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJDouble = {
    var _d1: java.lang.Double = java.lang.Double.valueOf(0.0)
    var _d2: java.lang.Double = java.lang.Double.valueOf(0.0)
    var _d3: java.lang.Double = java.lang.Double.valueOf(0.0)
    var _d4: java.lang.Double = java.lang.Double.valueOf(0.0)
    var _d5: java.lang.Double = java.lang.Double.valueOf(0.0)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJDouble_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJDouble] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Double.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Double.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Double.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _d4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Double.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _d5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Double.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJDouble_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJDouble(_d1, _d2, _d3, _d4, _d5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4", "d5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJDouble] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJDouble, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJDouble = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJDouble])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJFloat_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("f1", "f2", "f3", "f4", "f5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJFloat, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("f1")
    out.value(in.f1)
    out.label("f2")
    out.value(in.f2)
    out.label("f3")
    out.value(in.f3)
    out.label("f4")
    out.value(in.f4)
    out.label("f5")
    out.value(in.f5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJFloat = {
    var _f1: java.lang.Float = java.lang.Float.valueOf(0.0f)
    var _f2: java.lang.Float = java.lang.Float.valueOf(0.0f)
    var _f3: java.lang.Float = java.lang.Float.valueOf(0.0f)
    var _f4: java.lang.Float = java.lang.Float.valueOf(0.0f)
    var _f5: java.lang.Float = java.lang.Float.valueOf(0.0f)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJFloat_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJFloat] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _f1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Float.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _f2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Float.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _f3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Float.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _f4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Float.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _f5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Float.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJFloat_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJFloat(_f1, _f2, _f3, _f4, _f5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("f1", "f2", "f3", "f4", "f5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJFloat] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJFloat, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJFloat = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJFloat])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJInt_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4", "i5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJInt, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("i1")
    out.value(in.i1)
    out.label("i2")
    out.value(in.i2)
    out.label("i3")
    out.value(in.i3)
    out.label("i4")
    out.value(in.i4)
    out.label("i5")
    out.value(in.i5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJInt = {
    var _i1: java.lang.Integer = java.lang.Integer.valueOf(0)
    var _i2: java.lang.Integer = java.lang.Integer.valueOf(0)
    var _i3: java.lang.Integer = java.lang.Integer.valueOf(0)
    var _i4: java.lang.Integer = java.lang.Integer.valueOf(0)
    var _i5: java.lang.Integer = java.lang.Integer.valueOf(0)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJInt_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJInt] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _i1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _i2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _i3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _i4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _i5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJInt_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJInt(_i1, _i2, _i3, _i4, _i5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4", "i5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJInt] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJInt, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJInt = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJInt])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJInt_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4", "i5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJInt, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("i1")
    out.value(in.i1)
    out.label("i2")
    out.value(in.i2)
    out.label("i3")
    out.value(in.i3)
    out.label("i4")
    out.value(in.i4)
    out.label("i5")
    out.value(in.i5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJInt = {
    var _i1: java.lang.Integer = java.lang.Integer.valueOf(0)
    var _i2: java.lang.Integer = java.lang.Integer.valueOf(0)
    var _i3: java.lang.Integer = java.lang.Integer.valueOf(0)
    var _i4: java.lang.Integer = java.lang.Integer.valueOf(0)
    var _i5: java.lang.Integer = java.lang.Integer.valueOf(0)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJInt_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJInt] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _i1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _i2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _i3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _i4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _i5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Integer.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJInt_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJInt(_i1, _i2, _i3, _i4, _i5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4", "i5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJInt] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJInt, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJInt = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJInt])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJLong_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("l1", "l2", "l3", "l4", "l5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJLong, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("l1")
    out.value(in.l1)
    out.label("l2")
    out.value(in.l2)
    out.label("l3")
    out.value(in.l3)
    out.label("l4")
    out.value(in.l4)
    out.label("l5")
    out.value(in.l5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJLong = {
    var _l1: java.lang.Long = java.lang.Long.valueOf(0L)
    var _l2: java.lang.Long = java.lang.Long.valueOf(0L)
    var _l3: java.lang.Long = java.lang.Long.valueOf(0L)
    var _l4: java.lang.Long = java.lang.Long.valueOf(0L)
    var _l5: java.lang.Long = java.lang.Long.valueOf(0L)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJLong_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJLong] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _l1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _l2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _l3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _l4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _l5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJLong_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJLong(_l1, _l2, _l3, _l4, _l5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("l1", "l2", "l3", "l4", "l5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJLong] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJLong, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJLong = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJLong])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJLong_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("l1", "l2", "l3", "l4", "l5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJLong, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("l1")
    out.value(in.l1)
    out.label("l2")
    out.value(in.l2)
    out.label("l3")
    out.value(in.l3)
    out.label("l4")
    out.value(in.l4)
    out.label("l5")
    out.value(in.l5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJLong = {
    var _l1: java.lang.Long = java.lang.Long.valueOf(0L)
    var _l2: java.lang.Long = java.lang.Long.valueOf(0L)
    var _l3: java.lang.Long = java.lang.Long.valueOf(0L)
    var _l4: java.lang.Long = java.lang.Long.valueOf(0L)
    var _l5: java.lang.Long = java.lang.Long.valueOf(0L)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJLong_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJLong] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _l1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _l2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _l3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _l4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _l5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Long.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJLong_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJLong(_l1, _l2, _l3, _l4, _l5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("l1", "l2", "l3", "l4", "l5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJLong] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJLong, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJLong = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJLong])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJNumber_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("n1", "n2", "n3", "n4", "n5", "n6", "n7", "n8", "n9", "n10", "n11", "n12", "n13", "n14", "n15", "n16", "n17")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJNumber, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("n1")
    out.value(in.n1)
    out.label("n2")
    out.value(in.n2)
    out.label("n3")
    out.value(in.n3)
    out.label("n4")
    out.value(in.n4)
    out.label("n5")
    out.value(in.n5)
    out.label("n6")
    out.value(in.n6)
    out.label("n7")
    out.value(in.n7)
    out.label("n8")
    out.value(in.n8)
    out.label("n9")
    out.value(in.n9)
    out.label("n10")
    out.value(in.n10)
    out.label("n11")
    out.value(in.n11)
    out.label("n12")
    out.value(in.n12)
    out.label("n13")
    out.value(in.n13)
    out.label("n14")
    out.value(in.n14)
    out.label("n15")
    out.value(in.n15)
    out.label("n16")
    out.value(in.n16)
    out.label("n17")
    out.value(in.n17)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJNumber = {
    var _n1: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n2: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n3: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n4: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n5: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n6: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n7: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n8: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n9: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n10: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n11: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n12: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n13: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n14: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n15: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n16: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var _n17: java.lang.Number = null.asInstanceOf[java.lang.Number]
    var required: scala.Int = 131071
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJNumber_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJNumber] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _n1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(n) match {
                    case d if d.isValidByte =>
                      java.lang.Byte.valueOf(d.toByteExact)
                    case d if `d₂`.isValidShort =>
                      java.lang.Short.valueOf(`d₂`.toShortExact)
                    case d if `d₃`.isValidInt =>
                      java.lang.Integer.valueOf(`d₃`.toIntExact)
                    case d if `d₄`.isValidLong =>
                      java.lang.Long.valueOf(`d₄`.toLongExact)
                    case d if `d₅`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₅`.toFloat)
                    case d if `d₆`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₆`.toDouble)
                    case d =>
                      (`d₇`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _n2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₂`) match {
                    case d if `d₈`.isValidByte =>
                      java.lang.Byte.valueOf(`d₈`.toByteExact)
                    case d if `d₉`.isValidShort =>
                      java.lang.Short.valueOf(`d₉`.toShortExact)
                    case d if `d₁₀`.isValidInt =>
                      java.lang.Integer.valueOf(`d₁₀`.toIntExact)
                    case d if `d₁₁`.isValidLong =>
                      java.lang.Long.valueOf(`d₁₁`.toLongExact)
                    case d if `d₁₂`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₁₂`.toFloat)
                    case d if `d₁₃`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₁₃`.toDouble)
                    case d =>
                      (`d₁₄`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _n3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₃`) match {
                    case d if `d₁₅`.isValidByte =>
                      java.lang.Byte.valueOf(`d₁₅`.toByteExact)
                    case d if `d₁₆`.isValidShort =>
                      java.lang.Short.valueOf(`d₁₆`.toShortExact)
                    case d if `d₁₇`.isValidInt =>
                      java.lang.Integer.valueOf(`d₁₇`.toIntExact)
                    case d if `d₁₈`.isValidLong =>
                      java.lang.Long.valueOf(`d₁₈`.toLongExact)
                    case d if `d₁₉`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₁₉`.toFloat)
                    case d if `d₂₀`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₂₀`.toDouble)
                    case d =>
                      (`d₂₁`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _n4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₄`) match {
                    case d if `d₂₂`.isValidByte =>
                      java.lang.Byte.valueOf(`d₂₂`.toByteExact)
                    case d if `d₂₃`.isValidShort =>
                      java.lang.Short.valueOf(`d₂₃`.toShortExact)
                    case d if `d₂₄`.isValidInt =>
                      java.lang.Integer.valueOf(`d₂₄`.toIntExact)
                    case d if `d₂₅`.isValidLong =>
                      java.lang.Long.valueOf(`d₂₅`.toLongExact)
                    case d if `d₂₆`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₂₆`.toFloat)
                    case d if `d₂₇`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₂₇`.toDouble)
                    case d =>
                      (`d₂₈`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _n5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₅`) match {
                    case d if `d₂₉`.isValidByte =>
                      java.lang.Byte.valueOf(`d₂₉`.toByteExact)
                    case d if `d₃₀`.isValidShort =>
                      java.lang.Short.valueOf(`d₃₀`.toShortExact)
                    case d if `d₃₁`.isValidInt =>
                      java.lang.Integer.valueOf(`d₃₁`.toIntExact)
                    case d if `d₃₂`.isValidLong =>
                      java.lang.Long.valueOf(`d₃₂`.toLongExact)
                    case d if `d₃₃`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₃₃`.toFloat)
                    case d if `d₃₄`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₃₄`.toDouble)
                    case d =>
                      (`d₃₅`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n5"), `in₂`)
          case 5 =>
            if (required.&(32).!=(0)) {
              required = required.^(32)
              _n6 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₆`) match {
                    case d if `d₃₆`.isValidByte =>
                      java.lang.Byte.valueOf(`d₃₆`.toByteExact)
                    case d if `d₃₇`.isValidShort =>
                      java.lang.Short.valueOf(`d₃₇`.toShortExact)
                    case d if `d₃₈`.isValidInt =>
                      java.lang.Integer.valueOf(`d₃₈`.toIntExact)
                    case d if `d₃₉`.isValidLong =>
                      java.lang.Long.valueOf(`d₃₉`.toLongExact)
                    case d if `d₄₀`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₄₀`.toFloat)
                    case d if `d₄₁`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₄₁`.toDouble)
                    case d =>
                      (`d₄₂`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n6"), `in₂`)
          case 6 =>
            if (required.&(64).!=(0)) {
              required = required.^(64)
              _n7 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₇`) match {
                    case d if `d₄₃`.isValidByte =>
                      java.lang.Byte.valueOf(`d₄₃`.toByteExact)
                    case d if `d₄₄`.isValidShort =>
                      java.lang.Short.valueOf(`d₄₄`.toShortExact)
                    case d if `d₄₅`.isValidInt =>
                      java.lang.Integer.valueOf(`d₄₅`.toIntExact)
                    case d if `d₄₆`.isValidLong =>
                      java.lang.Long.valueOf(`d₄₆`.toLongExact)
                    case d if `d₄₇`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₄₇`.toFloat)
                    case d if `d₄₈`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₄₈`.toDouble)
                    case d =>
                      (`d₄₉`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n7"), `in₂`)
          case 7 =>
            if (required.&(128).!=(0)) {
              required = required.^(128)
              _n8 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₈`) match {
                    case d if `d₅₀`.isValidByte =>
                      java.lang.Byte.valueOf(`d₅₀`.toByteExact)
                    case d if `d₅₁`.isValidShort =>
                      java.lang.Short.valueOf(`d₅₁`.toShortExact)
                    case d if `d₅₂`.isValidInt =>
                      java.lang.Integer.valueOf(`d₅₂`.toIntExact)
                    case d if `d₅₃`.isValidLong =>
                      java.lang.Long.valueOf(`d₅₃`.toLongExact)
                    case d if `d₅₄`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₅₄`.toFloat)
                    case d if `d₅₅`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₅₅`.toDouble)
                    case d =>
                      (`d₅₆`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n8"), `in₂`)
          case 8 =>
            if (required.&(256).!=(0)) {
              required = required.^(256)
              _n9 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₉`) match {
                    case d if `d₅₇`.isValidByte =>
                      java.lang.Byte.valueOf(`d₅₇`.toByteExact)
                    case d if `d₅₈`.isValidShort =>
                      java.lang.Short.valueOf(`d₅₈`.toShortExact)
                    case d if `d₅₉`.isValidInt =>
                      java.lang.Integer.valueOf(`d₅₉`.toIntExact)
                    case d if `d₆₀`.isValidLong =>
                      java.lang.Long.valueOf(`d₆₀`.toLongExact)
                    case d if `d₆₁`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₆₁`.toFloat)
                    case d if `d₆₂`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₆₂`.toDouble)
                    case d =>
                      (`d₆₃`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n9"), `in₂`)
          case 9 =>
            if (required.&(512).!=(0)) {
              required = required.^(512)
              _n10 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₀`) match {
                    case d if `d₆₄`.isValidByte =>
                      java.lang.Byte.valueOf(`d₆₄`.toByteExact)
                    case d if `d₆₅`.isValidShort =>
                      java.lang.Short.valueOf(`d₆₅`.toShortExact)
                    case d if `d₆₆`.isValidInt =>
                      java.lang.Integer.valueOf(`d₆₆`.toIntExact)
                    case d if `d₆₇`.isValidLong =>
                      java.lang.Long.valueOf(`d₆₇`.toLongExact)
                    case d if `d₆₈`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₆₈`.toFloat)
                    case d if `d₆₉`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₆₉`.toDouble)
                    case d =>
                      (`d₇₀`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n10"), `in₂`)
          case 10 =>
            if (required.&(1024).!=(0)) {
              required = required.^(1024)
              _n11 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₁`) match {
                    case d if `d₇₁`.isValidByte =>
                      java.lang.Byte.valueOf(`d₇₁`.toByteExact)
                    case d if `d₇₂`.isValidShort =>
                      java.lang.Short.valueOf(`d₇₂`.toShortExact)
                    case d if `d₇₃`.isValidInt =>
                      java.lang.Integer.valueOf(`d₇₃`.toIntExact)
                    case d if `d₇₄`.isValidLong =>
                      java.lang.Long.valueOf(`d₇₄`.toLongExact)
                    case d if `d₇₅`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₇₅`.toFloat)
                    case d if `d₇₆`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₇₆`.toDouble)
                    case d =>
                      (`d₇₇`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n11"), `in₂`)
          case 11 =>
            if (required.&(2048).!=(0)) {
              required = required.^(2048)
              _n12 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₂`) match {
                    case d if `d₇₈`.isValidByte =>
                      java.lang.Byte.valueOf(`d₇₈`.toByteExact)
                    case d if `d₇₉`.isValidShort =>
                      java.lang.Short.valueOf(`d₇₉`.toShortExact)
                    case d if `d₈₀`.isValidInt =>
                      java.lang.Integer.valueOf(`d₈₀`.toIntExact)
                    case d if `d₈₁`.isValidLong =>
                      java.lang.Long.valueOf(`d₈₁`.toLongExact)
                    case d if `d₈₂`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₈₂`.toFloat)
                    case d if `d₈₃`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₈₃`.toDouble)
                    case d =>
                      (`d₈₄`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n12"), `in₂`)
          case 12 =>
            if (required.&(4096).!=(0)) {
              required = required.^(4096)
              _n13 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₃`) match {
                    case d if `d₈₅`.isValidByte =>
                      java.lang.Byte.valueOf(`d₈₅`.toByteExact)
                    case d if `d₈₆`.isValidShort =>
                      java.lang.Short.valueOf(`d₈₆`.toShortExact)
                    case d if `d₈₇`.isValidInt =>
                      java.lang.Integer.valueOf(`d₈₇`.toIntExact)
                    case d if `d₈₈`.isValidLong =>
                      java.lang.Long.valueOf(`d₈₈`.toLongExact)
                    case d if `d₈₉`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₈₉`.toFloat)
                    case d if `d₉₀`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₉₀`.toDouble)
                    case d =>
                      (`d₉₁`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n13"), `in₂`)
          case 13 =>
            if (required.&(8192).!=(0)) {
              required = required.^(8192)
              _n14 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₄`) match {
                    case d if `d₉₂`.isValidByte =>
                      java.lang.Byte.valueOf(`d₉₂`.toByteExact)
                    case d if `d₉₃`.isValidShort =>
                      java.lang.Short.valueOf(`d₉₃`.toShortExact)
                    case d if `d₉₄`.isValidInt =>
                      java.lang.Integer.valueOf(`d₉₄`.toIntExact)
                    case d if `d₉₅`.isValidLong =>
                      java.lang.Long.valueOf(`d₉₅`.toLongExact)
                    case d if `d₉₆`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₉₆`.toFloat)
                    case d if `d₉₇`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₉₇`.toDouble)
                    case d =>
                      (`d₉₈`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n14"), `in₂`)
          case 14 =>
            if (required.&(16384).!=(0)) {
              required = required.^(16384)
              _n15 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₅`) match {
                    case d if `d₉₉`.isValidByte =>
                      java.lang.Byte.valueOf(`d₉₉`.toByteExact)
                    case d if `d₁₀₀`.isValidShort =>
                      java.lang.Short.valueOf(`d₁₀₀`.toShortExact)
                    case d if `d₁₀₁`.isValidInt =>
                      java.lang.Integer.valueOf(`d₁₀₁`.toIntExact)
                    case d if `d₁₀₂`.isValidLong =>
                      java.lang.Long.valueOf(`d₁₀₂`.toLongExact)
                    case d if `d₁₀₃`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₁₀₃`.toFloat)
                    case d if `d₁₀₄`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₁₀₄`.toDouble)
                    case d =>
                      (`d₁₀₅`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n15"), `in₂`)
          case 15 =>
            if (required.&(32768).!=(0)) {
              required = required.^(32768)
              _n16 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₆`) match {
                    case d if `d₁₀₆`.isValidByte =>
                      java.lang.Byte.valueOf(`d₁₀₆`.toByteExact)
                    case d if `d₁₀₇`.isValidShort =>
                      java.lang.Short.valueOf(`d₁₀₇`.toShortExact)
                    case d if `d₁₀₈`.isValidInt =>
                      java.lang.Integer.valueOf(`d₁₀₈`.toIntExact)
                    case d if `d₁₀₉`.isValidLong =>
                      java.lang.Long.valueOf(`d₁₀₉`.toLongExact)
                    case d if `d₁₁₀`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₁₁₀`.toFloat)
                    case d if `d₁₁₁`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₁₁₁`.toDouble)
                    case d =>
                      (`d₁₁₂`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n16"), `in₂`)
          case 16 =>
            if (required.&(65536).!=(0)) {
              required = required.^(65536)
              _n17 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  scala.math.BigDecimal.apply(`n₁₇`) match {
                    case d if `d₁₁₃`.isValidByte =>
                      java.lang.Byte.valueOf(`d₁₁₃`.toByteExact)
                    case d if `d₁₁₄`.isValidShort =>
                      java.lang.Short.valueOf(`d₁₁₄`.toShortExact)
                    case d if `d₁₁₅`.isValidInt =>
                      java.lang.Integer.valueOf(`d₁₁₅`.toIntExact)
                    case d if `d₁₁₆`.isValidLong =>
                      java.lang.Long.valueOf(`d₁₁₆`.toLongExact)
                    case d if `d₁₁₇`.isDecimalFloat =>
                      java.lang.Float.valueOf(`d₁₁₇`.toFloat)
                    case d if `d₁₁₈`.isDecimalDouble =>
                      java.lang.Double.valueOf(`d₁₁₈`.toDouble)
                    case d =>
                      (`d₁₁₉`: scala.math.BigDecimal)
                  }
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("n17"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJNumber_fields)
      }
      if (required.&(131071).==(0)) new co.blocke.scalajack.json.primitives.SampleJNumber(_n1, _n2, _n3, _n4, _n5, _n6, _n7, _n8, _n9, _n10, _n11, _n12, _n13, _n14, _n15, _n16, _n17) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("n1", "n2", "n3", "n4", "n5", "n6", "n7", "n8", "n9", "n10", "n11", "n12", "n13", "n14", "n15", "n16", "n17")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(131071)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJNumber] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJNumber, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJNumber = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJNumber])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJByte_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("b1", "b2", "b3", "b4", "b5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJByte, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("b1")
    out.value(in.b1)
    out.label("b2")
    out.value(in.b2)
    out.label("b3")
    out.value(in.b3)
    out.label("b4")
    out.value(in.b4)
    out.label("b5")
    out.value(in.b5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJByte = {
    var _b1: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var _b2: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var _b3: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var _b4: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var _b5: java.lang.Byte = scala.Predef.byte2Byte(java.lang.Byte.MIN_VALUE)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJByte_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJByte] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _b1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _b3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _b4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _b5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Byte.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJByte_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJByte(_b1, _b2, _b3, _b4, _b5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("b1", "b2", "b3", "b4", "b5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJByte] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJByte, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJByte = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJByte])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJShort_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("s1", "s2", "s3", "s4", "s5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJShort, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("s1")
    out.value(in.s1)
    out.label("s2")
    out.value(in.s2)
    out.label("s3")
    out.value(in.s3)
    out.label("s4")
    out.value(in.s4)
    out.label("s5")
    out.value(in.s5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJShort = {
    var _s1: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var _s2: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var _s3: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var _s4: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var _s5: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJShort_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJShort] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _s1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _s2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _s3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _s4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _s5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJShort_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJShort(_s1, _s2, _s3, _s4, _s5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("s1", "s2", "s3", "s4", "s5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJShort] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJShort, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJShort = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJShort])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleJShort_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("s1", "s2", "s3", "s4", "s5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleJShort, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("s1")
    out.value(in.s1)
    out.label("s2")
    out.value(in.s2)
    out.label("s3")
    out.value(in.s3)
    out.label("s4")
    out.value(in.s4)
    out.label("s5")
    out.value(in.s5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJShort = {
    var _s1: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var _s2: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var _s3: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var _s4: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var _s5: java.lang.Short = java.lang.Short.valueOf(0.toShort)
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleJShort_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleJShort] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _s1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(n)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _s2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(`n₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _s3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(`n₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _s4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(`n₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _s5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case n =>
                  java.lang.Short.valueOf(`n₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleJShort_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleJShort(_s1, _s2, _s3, _s4, _s5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("s1", "s2", "s3", "s4", "s5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJShort] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleJShort, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleJShort = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleJShort])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleBigDecimal_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("bd1", "bd2", "bd3", "bd4", "bd5", "bd6")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleBigDecimal, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("bd1")
    out.value(in.bd1)
    out.label("bd2")
    out.value(in.bd2)
    out.label("bd3")
    out.value(in.bd3)
    out.label("bd4")
    out.value(in.bd4)
    out.label("bd5")
    out.value(in.bd5)
    out.label("bd6")
    out.value(in.bd6)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleBigDecimal = {
    var _bd1: scala.math.BigDecimal = scala.math.BigDecimal.apply(0)
    var _bd2: scala.math.BigDecimal = scala.math.BigDecimal.apply(0)
    var _bd3: scala.math.BigDecimal = scala.math.BigDecimal.apply(0)
    var _bd4: scala.math.BigDecimal = scala.math.BigDecimal.apply(0)
    var _bd5: scala.math.BigDecimal = scala.math.BigDecimal.apply(0)
    var _bd6: scala.math.BigDecimal = scala.math.BigDecimal.apply(0)
    var required: scala.Int = 63
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleBigDecimal_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleBigDecimal] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _bd1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigDecimal.apply(s)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _bd2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigDecimal.apply(`s₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _bd3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigDecimal.apply(`s₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _bd4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigDecimal.apply(`s₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _bd5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigDecimal.apply(`s₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd5"), `in₂`)
          case 5 =>
            if (required.&(32).!=(0)) {
              required = required.^(32)
              _bd6 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigDecimal.apply(`s₆`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd6"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleBigDecimal_fields)
      }
      if (required.&(63).==(0)) new co.blocke.scalajack.json.primitives.SampleBigDecimal(_bd1, _bd2, _bd3, _bd4, _bd5, _bd6) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("bd1", "bd2", "bd3", "bd4", "bd5", "bd6")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(63)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleBigDecimal] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleBigDecimal, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleBigDecimal = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleBigDecimal])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleBigInt_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("bi1", "bi2", "bi3", "bi4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleBigInt, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("bi1")
    out.value(in.bi1)
    out.label("bi2")
    out.value(in.bi2)
    out.label("bi3")
    out.value(in.bi3)
    out.label("bi4")
    out.value(in.bi4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleBigInt = {
    var _bi1: scala.math.BigInt = scala.math.BigInt.apply(0)
    var _bi2: scala.math.BigInt = scala.math.BigInt.apply(0)
    var _bi3: scala.math.BigInt = scala.math.BigInt.apply(0)
    var _bi4: scala.math.BigInt = scala.math.BigInt.apply(0)
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleBigInt_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleBigInt] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _bi1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigInt.apply(s)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _bi2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigInt.apply(`s₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _bi3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigInt.apply(`s₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _bi4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigInt.apply(`s₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleBigInt_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleBigInt(_bi1, _bi2, _bi3, _bi4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("bi1", "bi2", "bi3", "bi4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleBigInt] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleBigInt, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleBigInt = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleBigInt])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleBoolean_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("bool1", "bool2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleBoolean, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("bool1")
    out.value(in.bool1)
    out.label("bool2")
    out.value(in.bool2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleBoolean = {
    var _bool1: scala.Boolean = false
    var _bool2: scala.Boolean = false
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleBoolean_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleBoolean] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _bool1 = `in₂`.expectBoolean()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bool1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _bool2 = `in₂`.expectBoolean()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bool2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleBoolean_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleBoolean(_bool1, _bool2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("bool1", "bool2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleBoolean] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleBoolean, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleBoolean = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleBoolean])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleByte_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("b1", "b2", "b3", "b4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleByte, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("b1")
    out.value(in.b1)
    out.label("b2")
    out.value(in.b2)
    out.label("b3")
    out.value(in.b3)
    out.label("b4")
    out.value(in.b4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleByte = {
    var _b1: scala.Byte = 0.toByte
    var _b2: scala.Byte = 0.toByte
    var _b3: scala.Byte = 0.toByte
    var _b4: scala.Byte = 0.toByte
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleByte_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleByte] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _b1 = `in₂`.expectInt().toByte
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b2 = `in₂`.expectInt().toByte
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _b3 = `in₂`.expectInt().toByte
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _b4 = `in₂`.expectInt().toByte
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleByte_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleByte(_b1, _b2, _b3, _b4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("b1", "b2", "b3", "b4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleByte] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleByte, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleByte = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleByte])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleChar_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("c1", "c2", "c3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleChar, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("c1")
    out.value(in.c1)
    out.label("c2")
    out.value(in.c2)
    out.label("c3")
    out.value(in.c3)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleChar = {
    var _c1: scala.Char = 0.toChar
    var _c2: scala.Char = 0.toChar
    var _c3: scala.Char = 0.toChar
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleChar_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleChar] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _c1 = `in₂`.expectString() match {
                case null =>
                  `in₂`.backspace()
                  `in₂`.backspace()
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Char value cannot be null", `in₂`)
                case "" =>
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Char value expected but empty string found in json", `in₂`)
                case c =>
                  c.charAt(0)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _c2 = `in₂`.expectString() match {
                case null =>
                  `in₂`.backspace()
                  `in₂`.backspace()
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Char value cannot be null", `in₂`)
                case "" =>
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Char value expected but empty string found in json", `in₂`)
                case c =>
                  `c₂`.charAt(0)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _c3 = `in₂`.expectString() match {
                case null =>
                  `in₂`.backspace()
                  `in₂`.backspace()
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Char value cannot be null", `in₂`)
                case "" =>
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Char value expected but empty string found in json", `in₂`)
                case c =>
                  `c₃`.charAt(0)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c3"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleChar_fields)
      }
      if (required.&(7).==(0)) new co.blocke.scalajack.json.primitives.SampleChar(_c1, _c2, _c3) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("c1", "c2", "c3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(7)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleChar] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleChar, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleChar = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleChar])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleDouble_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleDouble, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.label("d4")
    out.value(in.d4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleDouble = {
    var _d1: scala.Double = 0.0
    var _d2: scala.Double = 0.0
    var _d3: scala.Double = 0.0
    var _d4: scala.Double = 0.0
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleDouble_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleDouble] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectDouble()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectDouble()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectDouble()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _d4 = `in₂`.expectDouble()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleDouble_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleDouble(_d1, _d2, _d3, _d4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleDouble] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleDouble, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleDouble = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleDouble])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleFloat_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("f1", "f2", "f3", "f4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleFloat, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("f1")
    out.value(in.f1)
    out.label("f2")
    out.value(in.f2)
    out.label("f3")
    out.value(in.f3)
    out.label("f4")
    out.value(in.f4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleFloat = {
    var _f1: scala.Float = 0.0f
    var _f2: scala.Float = 0.0f
    var _f3: scala.Float = 0.0f
    var _f4: scala.Float = 0.0f
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleFloat_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleFloat] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _f1 = `in₂`.expectFloat()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _f2 = `in₂`.expectFloat()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _f3 = `in₂`.expectFloat()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _f4 = `in₂`.expectFloat()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleFloat_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleFloat(_f1, _f2, _f3, _f4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("f1", "f2", "f3", "f4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleFloat] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleFloat, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleFloat = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleFloat])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleInt_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleInt, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("i1")
    out.value(in.i1)
    out.label("i2")
    out.value(in.i2)
    out.label("i3")
    out.value(in.i3)
    out.label("i4")
    out.value(in.i4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleInt = {
    var _i1: scala.Int = 0
    var _i2: scala.Int = 0
    var _i3: scala.Int = 0
    var _i4: scala.Int = 0
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleInt_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleInt] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _i1 = `in₂`.expectInt()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _i2 = `in₂`.expectInt()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _i3 = `in₂`.expectInt()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _i4 = `in₂`.expectInt()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleInt_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleInt(_i1, _i2, _i3, _i4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleInt] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleInt, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleInt = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleInt])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleLong_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("l1", "l2", "l3", "l4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleLong, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("l1")
    out.value(in.l1)
    out.label("l2")
    out.value(in.l2)
    out.label("l3")
    out.value(in.l3)
    out.label("l4")
    out.value(in.l4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLong = {
    var _l1: scala.Long = 0L
    var _l2: scala.Long = 0L
    var _l3: scala.Long = 0L
    var _l4: scala.Long = 0L
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleLong_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleLong] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _l1 = `in₂`.expectLong()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _l2 = `in₂`.expectLong()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _l3 = `in₂`.expectLong()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _l4 = `in₂`.expectLong()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleLong_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleLong(_l1, _l2, _l3, _l4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("l1", "l2", "l3", "l4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLong] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleLong, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLong = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLong])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleShort_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("s1", "s2", "s3", "s4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleShort, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("s1")
    out.value(in.s1)
    out.label("s2")
    out.value(in.s2)
    out.label("s3")
    out.value(in.s3)
    out.label("s4")
    out.value(in.s4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleShort = {
    var _s1: scala.Short = 0.toShort
    var _s2: scala.Short = 0.toShort
    var _s3: scala.Short = 0.toShort
    var _s4: scala.Short = 0.toShort
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleShort_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleShort] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _s1 = `in₂`.expectInt().toShort
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _s2 = `in₂`.expectInt().toShort
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _s3 = `in₂`.expectInt().toShort
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _s4 = `in₂`.expectInt().toShort
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleShort_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleShort(_s1, _s2, _s3, _s4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("s1", "s2", "s3", "s4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleShort] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleShort, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleShort = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleShort])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleString_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("s1", "s2", "s3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleString, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("s1")
    out.valueEscaped(in.s1)
    out.label("s2")
    out.valueEscaped(in.s2)
    out.label("s3")
    out.valueEscaped(in.s3)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleString = {
    var _s1: java.lang.String = ""
    var _s2: java.lang.String = ""
    var _s3: java.lang.String = ""
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleString_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleString] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _s1 = `in₂`.expectString()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _s2 = `in₂`.expectString()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _s3 = `in₂`.expectString()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s3"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleString_fields)
      }
      if (required.&(7).==(0)) new co.blocke.scalajack.json.primitives.SampleString(_s1, _s2, _s3) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("s1", "s2", "s3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(7)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleString] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleString, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleString = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleString])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleBigDecimal_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("bd1", "bd2", "bd3", "bd4", "bd5", "bd6")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleBigDecimal, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("bd1")
    out.value(in.bd1)
    out.label("bd2")
    out.value(in.bd2)
    out.label("bd3")
    out.value(in.bd3)
    out.label("bd4")
    out.value(in.bd4)
    out.label("bd5")
    out.value(in.bd5)
    out.label("bd6")
    out.value(in.bd6)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleBigDecimal = {
    var _bd1: scala.math.BigDecimal = scala.math.BigDecimal.apply(0)
    var _bd2: scala.math.BigDecimal = scala.math.BigDecimal.apply(0)
    var _bd3: scala.math.BigDecimal = scala.math.BigDecimal.apply(0)
    var _bd4: scala.math.BigDecimal = scala.math.BigDecimal.apply(0)
    var _bd5: scala.math.BigDecimal = scala.math.BigDecimal.apply(0)
    var _bd6: scala.math.BigDecimal = scala.math.BigDecimal.apply(0)
    var required: scala.Int = 63
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleBigDecimal_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleBigDecimal] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _bd1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigDecimal.apply(s)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _bd2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigDecimal.apply(`s₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _bd3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigDecimal.apply(`s₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _bd4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigDecimal.apply(`s₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _bd5 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigDecimal.apply(`s₅`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd5"), `in₂`)
          case 5 =>
            if (required.&(32).!=(0)) {
              required = required.^(32)
              _bd6 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigDecimal.apply(`s₆`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bd6"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleBigDecimal_fields)
      }
      if (required.&(63).==(0)) new co.blocke.scalajack.json.primitives.SampleBigDecimal(_bd1, _bd2, _bd3, _bd4, _bd5, _bd6) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("bd1", "bd2", "bd3", "bd4", "bd5", "bd6")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(63)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleBigDecimal] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleBigDecimal, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleBigDecimal = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleBigDecimal])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleBigInt_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("bi1", "bi2", "bi3", "bi4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleBigInt, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("bi1")
    out.value(in.bi1)
    out.label("bi2")
    out.value(in.bi2)
    out.label("bi3")
    out.value(in.bi3)
    out.label("bi4")
    out.value(in.bi4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleBigInt = {
    var _bi1: scala.math.BigInt = scala.math.BigInt.apply(0)
    var _bi2: scala.math.BigInt = scala.math.BigInt.apply(0)
    var _bi3: scala.math.BigInt = scala.math.BigInt.apply(0)
    var _bi4: scala.math.BigInt = scala.math.BigInt.apply(0)
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleBigInt_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleBigInt] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _bi1 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigInt.apply(s)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _bi2 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigInt.apply(`s₂`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _bi3 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigInt.apply(`s₃`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _bi4 = `in₂`.expectNumberOrNull() match {
                case null =>
                  null
                case s =>
                  scala.math.BigInt.apply(`s₄`)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bi4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleBigInt_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleBigInt(_bi1, _bi2, _bi3, _bi4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("bi1", "bi2", "bi3", "bi4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleBigInt] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleBigInt, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleBigInt = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleBigInt])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleBoolean_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("bool1", "bool2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleBoolean, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("bool1")
    out.value(in.bool1)
    out.label("bool2")
    out.value(in.bool2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleBoolean = {
    var _bool1: scala.Boolean = false
    var _bool2: scala.Boolean = false
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleBoolean_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleBoolean] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _bool1 = `in₂`.expectBoolean()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bool1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _bool2 = `in₂`.expectBoolean()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("bool2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleBoolean_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleBoolean(_bool1, _bool2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("bool1", "bool2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleBoolean] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleBoolean, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleBoolean = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleBoolean])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleByte_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("b1", "b2", "b3", "b4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleByte, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("b1")
    out.value(in.b1)
    out.label("b2")
    out.value(in.b2)
    out.label("b3")
    out.value(in.b3)
    out.label("b4")
    out.value(in.b4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleByte = {
    var _b1: scala.Byte = 0.toByte
    var _b2: scala.Byte = 0.toByte
    var _b3: scala.Byte = 0.toByte
    var _b4: scala.Byte = 0.toByte
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleByte_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleByte] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _b1 = `in₂`.expectInt().toByte
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _b2 = `in₂`.expectInt().toByte
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _b3 = `in₂`.expectInt().toByte
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _b4 = `in₂`.expectInt().toByte
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("b4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleByte_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleByte(_b1, _b2, _b3, _b4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("b1", "b2", "b3", "b4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleByte] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleByte, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleByte = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleByte])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleChar_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("c1", "c2", "c3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleChar, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("c1")
    out.value(in.c1)
    out.label("c2")
    out.value(in.c2)
    out.label("c3")
    out.value(in.c3)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleChar = {
    var _c1: scala.Char = 0.toChar
    var _c2: scala.Char = 0.toChar
    var _c3: scala.Char = 0.toChar
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleChar_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleChar] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _c1 = `in₂`.expectString() match {
                case null =>
                  `in₂`.backspace()
                  `in₂`.backspace()
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Char value cannot be null", `in₂`)
                case "" =>
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Char value expected but empty string found in json", `in₂`)
                case c =>
                  c.charAt(0)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _c2 = `in₂`.expectString() match {
                case null =>
                  `in₂`.backspace()
                  `in₂`.backspace()
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Char value cannot be null", `in₂`)
                case "" =>
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Char value expected but empty string found in json", `in₂`)
                case c =>
                  `c₂`.charAt(0)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _c3 = `in₂`.expectString() match {
                case null =>
                  `in₂`.backspace()
                  `in₂`.backspace()
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Char value cannot be null", `in₂`)
                case "" =>
                  `in₂`.backspace()
                  `in₂`.backspace()
                  throw co.blocke.scalajack.json.JsonParseError.apply("Char value expected but empty string found in json", `in₂`)
                case c =>
                  `c₃`.charAt(0)
              }
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("c3"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleChar_fields)
      }
      if (required.&(7).==(0)) new co.blocke.scalajack.json.primitives.SampleChar(_c1, _c2, _c3) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("c1", "c2", "c3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(7)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleChar] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleChar, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleChar = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleChar])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleDouble_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleDouble, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.label("d4")
    out.value(in.d4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleDouble = {
    var _d1: scala.Double = 0.0
    var _d2: scala.Double = 0.0
    var _d3: scala.Double = 0.0
    var _d4: scala.Double = 0.0
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleDouble_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleDouble] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectDouble()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectDouble()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectDouble()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _d4 = `in₂`.expectDouble()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleDouble_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleDouble(_d1, _d2, _d3, _d4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleDouble] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleDouble, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleDouble = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleDouble])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleFloat_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("f1", "f2", "f3", "f4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleFloat, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("f1")
    out.value(in.f1)
    out.label("f2")
    out.value(in.f2)
    out.label("f3")
    out.value(in.f3)
    out.label("f4")
    out.value(in.f4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleFloat = {
    var _f1: scala.Float = 0.0f
    var _f2: scala.Float = 0.0f
    var _f3: scala.Float = 0.0f
    var _f4: scala.Float = 0.0f
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleFloat_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleFloat] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _f1 = `in₂`.expectFloat()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _f2 = `in₂`.expectFloat()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _f3 = `in₂`.expectFloat()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _f4 = `in₂`.expectFloat()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("f4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleFloat_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleFloat(_f1, _f2, _f3, _f4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("f1", "f2", "f3", "f4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleFloat] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleFloat, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleFloat = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleFloat])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleInt_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleInt, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("i1")
    out.value(in.i1)
    out.label("i2")
    out.value(in.i2)
    out.label("i3")
    out.value(in.i3)
    out.label("i4")
    out.value(in.i4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleInt = {
    var _i1: scala.Int = 0
    var _i2: scala.Int = 0
    var _i3: scala.Int = 0
    var _i4: scala.Int = 0
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleInt_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleInt] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _i1 = `in₂`.expectInt()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _i2 = `in₂`.expectInt()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _i3 = `in₂`.expectInt()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _i4 = `in₂`.expectInt()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleInt_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleInt(_i1, _i2, _i3, _i4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleInt] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleInt, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleInt = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleInt])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleLong_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("l1", "l2", "l3", "l4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleLong, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("l1")
    out.value(in.l1)
    out.label("l2")
    out.value(in.l2)
    out.label("l3")
    out.value(in.l3)
    out.label("l4")
    out.value(in.l4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLong = {
    var _l1: scala.Long = 0L
    var _l2: scala.Long = 0L
    var _l3: scala.Long = 0L
    var _l4: scala.Long = 0L
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleLong_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleLong] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _l1 = `in₂`.expectLong()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _l2 = `in₂`.expectLong()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _l3 = `in₂`.expectLong()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _l4 = `in₂`.expectLong()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("l4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleLong_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleLong(_l1, _l2, _l3, _l4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("l1", "l2", "l3", "l4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLong] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleLong, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLong = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLong])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleShort_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("s1", "s2", "s3", "s4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleShort, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("s1")
    out.value(in.s1)
    out.label("s2")
    out.value(in.s2)
    out.label("s3")
    out.value(in.s3)
    out.label("s4")
    out.value(in.s4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleShort = {
    var _s1: scala.Short = 0.toShort
    var _s2: scala.Short = 0.toShort
    var _s3: scala.Short = 0.toShort
    var _s4: scala.Short = 0.toShort
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleShort_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleShort] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _s1 = `in₂`.expectInt().toShort
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _s2 = `in₂`.expectInt().toShort
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _s3 = `in₂`.expectInt().toShort
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _s4 = `in₂`.expectInt().toShort
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleShort_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleShort(_s1, _s2, _s3, _s4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("s1", "s2", "s3", "s4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleShort] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleShort, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleShort = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleShort])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleString_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("s1", "s2", "s3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleString, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("s1")
    out.valueEscaped(in.s1)
    out.label("s2")
    out.valueEscaped(in.s2)
    out.label("s3")
    out.valueEscaped(in.s3)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleString = {
    var _s1: java.lang.String = ""
    var _s2: java.lang.String = ""
    var _s3: java.lang.String = ""
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleString_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleString] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _s1 = `in₂`.expectString()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _s2 = `in₂`.expectString()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _s3 = `in₂`.expectString()
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("s3"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleString_fields)
      }
      if (required.&(7).==(0)) new co.blocke.scalajack.json.primitives.SampleString(_s1, _s2, _s3) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("s1", "s2", "s3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(7)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleString] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleString, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleString = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleString])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleDuration_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleDuration, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleDuration = {
    var _d1: java.time.Duration = null
    var _d2: java.time.Duration = null
    var _d3: java.time.Duration = null
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleDuration_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleDuration] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectString[java.time.Duration](((x$0: java.lang.CharSequence) => java.time.Duration.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectString[java.time.Duration](((`x$0₂`: java.lang.CharSequence) => java.time.Duration.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectString[java.time.Duration](((`x$0₃`: java.lang.CharSequence) => java.time.Duration.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleDuration_fields)
      }
      if (required.&(7).==(0)) new co.blocke.scalajack.json.primitives.SampleDuration(_d1, _d2, _d3) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(7)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleDuration] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleDuration, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleDuration = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleDuration])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleDuration_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleDuration, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleDuration = {
    var _d1: java.time.Duration = null
    var _d2: java.time.Duration = null
    var _d3: java.time.Duration = null
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleDuration_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleDuration] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectString[java.time.Duration](((x$0: java.lang.CharSequence) => java.time.Duration.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectString[java.time.Duration](((`x$0₂`: java.lang.CharSequence) => java.time.Duration.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectString[java.time.Duration](((`x$0₃`: java.lang.CharSequence) => java.time.Duration.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleDuration_fields)
      }
      if (required.&(7).==(0)) new co.blocke.scalajack.json.primitives.SampleDuration(_d1, _d2, _d3) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(7)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleDuration] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleDuration, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleDuration = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleDuration])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleInstant_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4", "i5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleInstant, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("i1")
    out.value(in.i1)
    out.label("i2")
    out.value(in.i2)
    out.label("i3")
    out.value(in.i3)
    out.label("i4")
    out.value(in.i4)
    out.label("i5")
    out.value(in.i5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleInstant = {
    var _i1: java.time.Instant = null
    var _i2: java.time.Instant = null
    var _i3: java.time.Instant = null
    var _i4: java.time.Instant = null
    var _i5: java.time.Instant = null
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleInstant_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleInstant] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _i1 = `in₂`.expectString[java.time.Instant](((x$0: java.lang.CharSequence) => java.time.Instant.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _i2 = `in₂`.expectString[java.time.Instant](((`x$0₂`: java.lang.CharSequence) => java.time.Instant.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _i3 = `in₂`.expectString[java.time.Instant](((`x$0₃`: java.lang.CharSequence) => java.time.Instant.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _i4 = `in₂`.expectString[java.time.Instant](((`x$0₄`: java.lang.CharSequence) => java.time.Instant.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _i5 = `in₂`.expectString[java.time.Instant](((`x$0₅`: java.lang.CharSequence) => java.time.Instant.parse(`x$0₅`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleInstant_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleInstant(_i1, _i2, _i3, _i4, _i5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4", "i5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleInstant] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleInstant, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleInstant = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleInstant])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleInstant_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4", "i5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleInstant, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("i1")
    out.value(in.i1)
    out.label("i2")
    out.value(in.i2)
    out.label("i3")
    out.value(in.i3)
    out.label("i4")
    out.value(in.i4)
    out.label("i5")
    out.value(in.i5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleInstant = {
    var _i1: java.time.Instant = null
    var _i2: java.time.Instant = null
    var _i3: java.time.Instant = null
    var _i4: java.time.Instant = null
    var _i5: java.time.Instant = null
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleInstant_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleInstant] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _i1 = `in₂`.expectString[java.time.Instant](((x$0: java.lang.CharSequence) => java.time.Instant.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _i2 = `in₂`.expectString[java.time.Instant](((`x$0₂`: java.lang.CharSequence) => java.time.Instant.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _i3 = `in₂`.expectString[java.time.Instant](((`x$0₃`: java.lang.CharSequence) => java.time.Instant.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _i4 = `in₂`.expectString[java.time.Instant](((`x$0₄`: java.lang.CharSequence) => java.time.Instant.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _i5 = `in₂`.expectString[java.time.Instant](((`x$0₅`: java.lang.CharSequence) => java.time.Instant.parse(`x$0₅`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleInstant_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleInstant(_i1, _i2, _i3, _i4, _i5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4", "i5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleInstant] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleInstant, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleInstant = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleInstant])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleLocalDateTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleLocalDateTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.label("d4")
    out.value(in.d4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalDateTime = {
    var _d1: java.time.LocalDateTime = null
    var _d2: java.time.LocalDateTime = null
    var _d3: java.time.LocalDateTime = null
    var _d4: java.time.LocalDateTime = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleLocalDateTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleLocalDateTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectString[java.time.LocalDateTime](((x$0: java.lang.CharSequence) => java.time.LocalDateTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectString[java.time.LocalDateTime](((`x$0₂`: java.lang.CharSequence) => java.time.LocalDateTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectString[java.time.LocalDateTime](((`x$0₃`: java.lang.CharSequence) => java.time.LocalDateTime.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _d4 = `in₂`.expectString[java.time.LocalDateTime](((`x$0₄`: java.lang.CharSequence) => java.time.LocalDateTime.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleLocalDateTime_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleLocalDateTime(_d1, _d2, _d3, _d4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalDateTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleLocalDateTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalDateTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalDateTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleLocalDateTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleLocalDateTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.label("d4")
    out.value(in.d4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalDateTime = {
    var _d1: java.time.LocalDateTime = null
    var _d2: java.time.LocalDateTime = null
    var _d3: java.time.LocalDateTime = null
    var _d4: java.time.LocalDateTime = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleLocalDateTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleLocalDateTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectString[java.time.LocalDateTime](((x$0: java.lang.CharSequence) => java.time.LocalDateTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectString[java.time.LocalDateTime](((`x$0₂`: java.lang.CharSequence) => java.time.LocalDateTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectString[java.time.LocalDateTime](((`x$0₃`: java.lang.CharSequence) => java.time.LocalDateTime.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _d4 = `in₂`.expectString[java.time.LocalDateTime](((`x$0₄`: java.lang.CharSequence) => java.time.LocalDateTime.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleLocalDateTime_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleLocalDateTime(_d1, _d2, _d3, _d4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalDateTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleLocalDateTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalDateTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalDateTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleLocalDate_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleLocalDate, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.label("d4")
    out.value(in.d4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalDate = {
    var _d1: java.time.LocalDate = null
    var _d2: java.time.LocalDate = null
    var _d3: java.time.LocalDate = null
    var _d4: java.time.LocalDate = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleLocalDate_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleLocalDate] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectString[java.time.LocalDate](((x$0: java.lang.CharSequence) => java.time.LocalDate.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectString[java.time.LocalDate](((`x$0₂`: java.lang.CharSequence) => java.time.LocalDate.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectString[java.time.LocalDate](((`x$0₃`: java.lang.CharSequence) => java.time.LocalDate.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _d4 = `in₂`.expectString[java.time.LocalDate](((`x$0₄`: java.lang.CharSequence) => java.time.LocalDate.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleLocalDate_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleLocalDate(_d1, _d2, _d3, _d4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalDate] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleLocalDate, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalDate = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalDate])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleLocalDate_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleLocalDate, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.label("d4")
    out.value(in.d4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalDate = {
    var _d1: java.time.LocalDate = null
    var _d2: java.time.LocalDate = null
    var _d3: java.time.LocalDate = null
    var _d4: java.time.LocalDate = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleLocalDate_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleLocalDate] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectString[java.time.LocalDate](((x$0: java.lang.CharSequence) => java.time.LocalDate.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectString[java.time.LocalDate](((`x$0₂`: java.lang.CharSequence) => java.time.LocalDate.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectString[java.time.LocalDate](((`x$0₃`: java.lang.CharSequence) => java.time.LocalDate.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _d4 = `in₂`.expectString[java.time.LocalDate](((`x$0₄`: java.lang.CharSequence) => java.time.LocalDate.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleLocalDate_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleLocalDate(_d1, _d2, _d3, _d4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalDate] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleLocalDate, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalDate = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalDate])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleLocalTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4", "d5", "d6")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleLocalTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.label("d4")
    out.value(in.d4)
    out.label("d5")
    out.value(in.d5)
    out.label("d6")
    out.value(in.d6)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalTime = {
    var _d1: java.time.LocalTime = null
    var _d2: java.time.LocalTime = null
    var _d3: java.time.LocalTime = null
    var _d4: java.time.LocalTime = null
    var _d5: java.time.LocalTime = null
    var _d6: java.time.LocalTime = null
    var required: scala.Int = 63
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleLocalTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleLocalTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectString[java.time.LocalTime](((x$0: java.lang.CharSequence) => java.time.LocalTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectString[java.time.LocalTime](((`x$0₂`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectString[java.time.LocalTime](((`x$0₃`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _d4 = `in₂`.expectString[java.time.LocalTime](((`x$0₄`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _d5 = `in₂`.expectString[java.time.LocalTime](((`x$0₅`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₅`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d5"), `in₂`)
          case 5 =>
            if (required.&(32).!=(0)) {
              required = required.^(32)
              _d6 = `in₂`.expectString[java.time.LocalTime](((`x$0₆`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₆`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d6"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleLocalTime_fields)
      }
      if (required.&(63).==(0)) new co.blocke.scalajack.json.primitives.SampleLocalTime(_d1, _d2, _d3, _d4, _d5, _d6) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4", "d5", "d6")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(63)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleLocalTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleLocalTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4", "d5", "d6")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleLocalTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.label("d4")
    out.value(in.d4)
    out.label("d5")
    out.value(in.d5)
    out.label("d6")
    out.value(in.d6)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalTime = {
    var _d1: java.time.LocalTime = null
    var _d2: java.time.LocalTime = null
    var _d3: java.time.LocalTime = null
    var _d4: java.time.LocalTime = null
    var _d5: java.time.LocalTime = null
    var _d6: java.time.LocalTime = null
    var required: scala.Int = 63
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleLocalTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleLocalTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectString[java.time.LocalTime](((x$0: java.lang.CharSequence) => java.time.LocalTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectString[java.time.LocalTime](((`x$0₂`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectString[java.time.LocalTime](((`x$0₃`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _d4 = `in₂`.expectString[java.time.LocalTime](((`x$0₄`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _d5 = `in₂`.expectString[java.time.LocalTime](((`x$0₅`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₅`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d5"), `in₂`)
          case 5 =>
            if (required.&(32).!=(0)) {
              required = required.^(32)
              _d6 = `in₂`.expectString[java.time.LocalTime](((`x$0₆`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₆`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d6"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleLocalTime_fields)
      }
      if (required.&(63).==(0)) new co.blocke.scalajack.json.primitives.SampleLocalTime(_d1, _d2, _d3, _d4, _d5, _d6) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4", "d5", "d6")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(63)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleLocalTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleMonthDay_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("m1", "m2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleMonthDay, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("m1")
    out.value(in.m1)
    out.label("m2")
    out.value(in.m2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleMonthDay = {
    var _m1: java.time.MonthDay = null
    var _m2: java.time.MonthDay = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleMonthDay_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleMonthDay] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _m1 = `in₂`.expectString[java.time.MonthDay](((x$0: java.lang.CharSequence) => java.time.MonthDay.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("m1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _m2 = `in₂`.expectString[java.time.MonthDay](((`x$0₂`: java.lang.CharSequence) => java.time.MonthDay.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("m2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleMonthDay_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleMonthDay(_m1, _m2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("m1", "m2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleMonthDay] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleMonthDay, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleMonthDay = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleMonthDay])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleMonthDay_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("m1", "m2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleMonthDay, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("m1")
    out.value(in.m1)
    out.label("m2")
    out.value(in.m2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleMonthDay = {
    var _m1: java.time.MonthDay = null
    var _m2: java.time.MonthDay = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleMonthDay_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleMonthDay] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _m1 = `in₂`.expectString[java.time.MonthDay](((x$0: java.lang.CharSequence) => java.time.MonthDay.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("m1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _m2 = `in₂`.expectString[java.time.MonthDay](((`x$0₂`: java.lang.CharSequence) => java.time.MonthDay.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("m2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleMonthDay_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleMonthDay(_m1, _m2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("m1", "m2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleMonthDay] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleMonthDay, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleMonthDay = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleMonthDay])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleOffsetDateTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("o1", "o2", "o3", "o4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleOffsetDateTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("o1")
    out.value(in.o1)
    out.label("o2")
    out.value(in.o2)
    out.label("o3")
    out.value(in.o3)
    out.label("o4")
    out.value(in.o4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleOffsetDateTime = {
    var _o1: java.time.OffsetDateTime = null
    var _o2: java.time.OffsetDateTime = null
    var _o3: java.time.OffsetDateTime = null
    var _o4: java.time.OffsetDateTime = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleOffsetDateTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleOffsetDateTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _o1 = `in₂`.expectString[java.time.OffsetDateTime](((x$0: java.lang.CharSequence) => java.time.OffsetDateTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _o2 = `in₂`.expectString[java.time.OffsetDateTime](((`x$0₂`: java.lang.CharSequence) => java.time.OffsetDateTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _o3 = `in₂`.expectString[java.time.OffsetDateTime](((`x$0₃`: java.lang.CharSequence) => java.time.OffsetDateTime.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _o4 = `in₂`.expectString[java.time.OffsetDateTime](((`x$0₄`: java.lang.CharSequence) => java.time.OffsetDateTime.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleOffsetDateTime_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleOffsetDateTime(_o1, _o2, _o3, _o4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("o1", "o2", "o3", "o4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleOffsetDateTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleOffsetDateTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleOffsetDateTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleOffsetDateTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleOffsetDateTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("o1", "o2", "o3", "o4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleOffsetDateTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("o1")
    out.value(in.o1)
    out.label("o2")
    out.value(in.o2)
    out.label("o3")
    out.value(in.o3)
    out.label("o4")
    out.value(in.o4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleOffsetDateTime = {
    var _o1: java.time.OffsetDateTime = null
    var _o2: java.time.OffsetDateTime = null
    var _o3: java.time.OffsetDateTime = null
    var _o4: java.time.OffsetDateTime = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleOffsetDateTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleOffsetDateTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _o1 = `in₂`.expectString[java.time.OffsetDateTime](((x$0: java.lang.CharSequence) => java.time.OffsetDateTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _o2 = `in₂`.expectString[java.time.OffsetDateTime](((`x$0₂`: java.lang.CharSequence) => java.time.OffsetDateTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _o3 = `in₂`.expectString[java.time.OffsetDateTime](((`x$0₃`: java.lang.CharSequence) => java.time.OffsetDateTime.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _o4 = `in₂`.expectString[java.time.OffsetDateTime](((`x$0₄`: java.lang.CharSequence) => java.time.OffsetDateTime.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleOffsetDateTime_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleOffsetDateTime(_o1, _o2, _o3, _o4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("o1", "o2", "o3", "o4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleOffsetDateTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleOffsetDateTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleOffsetDateTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleOffsetDateTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleOffsetTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("o1", "o2", "o3", "o4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleOffsetTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("o1")
    out.value(in.o1)
    out.label("o2")
    out.value(in.o2)
    out.label("o3")
    out.value(in.o3)
    out.label("o4")
    out.value(in.o4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleOffsetTime = {
    var _o1: java.time.OffsetTime = null
    var _o2: java.time.OffsetTime = null
    var _o3: java.time.OffsetTime = null
    var _o4: java.time.OffsetTime = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleOffsetTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleOffsetTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _o1 = `in₂`.expectString[java.time.OffsetTime](((x$0: java.lang.CharSequence) => java.time.OffsetTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _o2 = `in₂`.expectString[java.time.OffsetTime](((`x$0₂`: java.lang.CharSequence) => java.time.OffsetTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _o3 = `in₂`.expectString[java.time.OffsetTime](((`x$0₃`: java.lang.CharSequence) => java.time.OffsetTime.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _o4 = `in₂`.expectString[java.time.OffsetTime](((`x$0₄`: java.lang.CharSequence) => java.time.OffsetTime.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleOffsetTime_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleOffsetTime(_o1, _o2, _o3, _o4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("o1", "o2", "o3", "o4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleOffsetTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleOffsetTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleOffsetTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleOffsetTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleOffsetTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("o1", "o2", "o3", "o4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleOffsetTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("o1")
    out.value(in.o1)
    out.label("o2")
    out.value(in.o2)
    out.label("o3")
    out.value(in.o3)
    out.label("o4")
    out.value(in.o4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleOffsetTime = {
    var _o1: java.time.OffsetTime = null
    var _o2: java.time.OffsetTime = null
    var _o3: java.time.OffsetTime = null
    var _o4: java.time.OffsetTime = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleOffsetTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleOffsetTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _o1 = `in₂`.expectString[java.time.OffsetTime](((x$0: java.lang.CharSequence) => java.time.OffsetTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _o2 = `in₂`.expectString[java.time.OffsetTime](((`x$0₂`: java.lang.CharSequence) => java.time.OffsetTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _o3 = `in₂`.expectString[java.time.OffsetTime](((`x$0₃`: java.lang.CharSequence) => java.time.OffsetTime.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _o4 = `in₂`.expectString[java.time.OffsetTime](((`x$0₄`: java.lang.CharSequence) => java.time.OffsetTime.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleOffsetTime_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleOffsetTime(_o1, _o2, _o3, _o4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("o1", "o2", "o3", "o4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleOffsetTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleOffsetTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleOffsetTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleOffsetTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SamplePeriod_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("p1", "p2", "p3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SamplePeriod, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("p1")
    out.value(in.p1)
    out.label("p2")
    out.value(in.p2)
    out.label("p3")
    out.value(in.p3)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SamplePeriod = {
    var _p1: java.time.Period = null
    var _p2: java.time.Period = null
    var _p3: java.time.Period = null
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SamplePeriod_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SamplePeriod] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _p1 = `in₂`.expectString[java.time.Period](((x$0: java.lang.CharSequence) => java.time.Period.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("p1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _p2 = `in₂`.expectString[java.time.Period](((`x$0₂`: java.lang.CharSequence) => java.time.Period.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("p2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _p3 = `in₂`.expectString[java.time.Period](((`x$0₃`: java.lang.CharSequence) => java.time.Period.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("p3"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SamplePeriod_fields)
      }
      if (required.&(7).==(0)) new co.blocke.scalajack.json.primitives.SamplePeriod(_p1, _p2, _p3) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("p1", "p2", "p3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(7)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SamplePeriod] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SamplePeriod, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SamplePeriod = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SamplePeriod])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SamplePeriod_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("p1", "p2", "p3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SamplePeriod, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("p1")
    out.value(in.p1)
    out.label("p2")
    out.value(in.p2)
    out.label("p3")
    out.value(in.p3)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SamplePeriod = {
    var _p1: java.time.Period = null
    var _p2: java.time.Period = null
    var _p3: java.time.Period = null
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SamplePeriod_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SamplePeriod] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _p1 = `in₂`.expectString[java.time.Period](((x$0: java.lang.CharSequence) => java.time.Period.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("p1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _p2 = `in₂`.expectString[java.time.Period](((`x$0₂`: java.lang.CharSequence) => java.time.Period.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("p2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _p3 = `in₂`.expectString[java.time.Period](((`x$0₃`: java.lang.CharSequence) => java.time.Period.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("p3"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SamplePeriod_fields)
      }
      if (required.&(7).==(0)) new co.blocke.scalajack.json.primitives.SamplePeriod(_p1, _p2, _p3) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("p1", "p2", "p3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(7)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SamplePeriod] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SamplePeriod, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SamplePeriod = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SamplePeriod])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleYear_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("y1", "y2", "y3", "y4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleYear, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("y1")
    out.value(in.y1)
    out.label("y2")
    out.value(in.y2)
    out.label("y3")
    out.value(in.y3)
    out.label("y4")
    out.value(in.y4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleYear = {
    var _y1: java.time.Year = null
    var _y2: java.time.Year = null
    var _y3: java.time.Year = null
    var _y4: java.time.Year = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleYear_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleYear] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _y1 = `in₂`.expectString[java.time.Year](((x$0: java.lang.CharSequence) => java.time.Year.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _y2 = `in₂`.expectString[java.time.Year](((`x$0₂`: java.lang.CharSequence) => java.time.Year.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _y3 = `in₂`.expectString[java.time.Year](((`x$0₃`: java.lang.CharSequence) => java.time.Year.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _y4 = `in₂`.expectString[java.time.Year](((`x$0₄`: java.lang.CharSequence) => java.time.Year.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleYear_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleYear(_y1, _y2, _y3, _y4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("y1", "y2", "y3", "y4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleYear] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleYear, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleYear = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleYear])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleYear_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("y1", "y2", "y3", "y4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleYear, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("y1")
    out.value(in.y1)
    out.label("y2")
    out.value(in.y2)
    out.label("y3")
    out.value(in.y3)
    out.label("y4")
    out.value(in.y4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleYear = {
    var _y1: java.time.Year = null
    var _y2: java.time.Year = null
    var _y3: java.time.Year = null
    var _y4: java.time.Year = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleYear_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleYear] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _y1 = `in₂`.expectString[java.time.Year](((x$0: java.lang.CharSequence) => java.time.Year.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _y2 = `in₂`.expectString[java.time.Year](((`x$0₂`: java.lang.CharSequence) => java.time.Year.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _y3 = `in₂`.expectString[java.time.Year](((`x$0₃`: java.lang.CharSequence) => java.time.Year.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _y4 = `in₂`.expectString[java.time.Year](((`x$0₄`: java.lang.CharSequence) => java.time.Year.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleYear_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleYear(_y1, _y2, _y3, _y4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("y1", "y2", "y3", "y4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleYear] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleYear, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleYear = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleYear])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleYearMonth_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("y1", "y2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleYearMonth, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("y1")
    out.value(in.y1)
    out.label("y2")
    out.value(in.y2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleYearMonth = {
    var _y1: java.time.YearMonth = null
    var _y2: java.time.YearMonth = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleYearMonth_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleYearMonth] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _y1 = `in₂`.expectString[java.time.YearMonth](((x$0: java.lang.CharSequence) => java.time.YearMonth.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _y2 = `in₂`.expectString[java.time.YearMonth](((`x$0₂`: java.lang.CharSequence) => java.time.YearMonth.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleYearMonth_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleYearMonth(_y1, _y2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("y1", "y2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleYearMonth] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleYearMonth, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleYearMonth = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleYearMonth])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleYearMonth_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("y1", "y2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleYearMonth, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("y1")
    out.value(in.y1)
    out.label("y2")
    out.value(in.y2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleYearMonth = {
    var _y1: java.time.YearMonth = null
    var _y2: java.time.YearMonth = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleYearMonth_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleYearMonth] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _y1 = `in₂`.expectString[java.time.YearMonth](((x$0: java.lang.CharSequence) => java.time.YearMonth.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _y2 = `in₂`.expectString[java.time.YearMonth](((`x$0₂`: java.lang.CharSequence) => java.time.YearMonth.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleYearMonth_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleYearMonth(_y1, _y2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("y1", "y2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleYearMonth] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleYearMonth, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleYearMonth = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleYearMonth])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleZonedDateTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("o1", "o2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleZonedDateTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("o1")
    out.value(in.o1)
    out.label("o2")
    out.value(in.o2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZonedDateTime = {
    var _o1: java.time.ZonedDateTime = null
    var _o2: java.time.ZonedDateTime = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleZonedDateTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleZonedDateTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _o1 = `in₂`.expectString[java.time.ZonedDateTime](((x$0: java.lang.CharSequence) => java.time.ZonedDateTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _o2 = `in₂`.expectString[java.time.ZonedDateTime](((`x$0₂`: java.lang.CharSequence) => java.time.ZonedDateTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleZonedDateTime_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleZonedDateTime(_o1, _o2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("o1", "o2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZonedDateTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleZonedDateTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZonedDateTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZonedDateTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleZonedDateTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("o1", "o2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleZonedDateTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("o1")
    out.value(in.o1)
    out.label("o2")
    out.value(in.o2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZonedDateTime = {
    var _o1: java.time.ZonedDateTime = null
    var _o2: java.time.ZonedDateTime = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleZonedDateTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleZonedDateTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _o1 = `in₂`.expectString[java.time.ZonedDateTime](((x$0: java.lang.CharSequence) => java.time.ZonedDateTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _o2 = `in₂`.expectString[java.time.ZonedDateTime](((`x$0₂`: java.lang.CharSequence) => java.time.ZonedDateTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleZonedDateTime_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleZonedDateTime(_o1, _o2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("o1", "o2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZonedDateTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleZonedDateTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZonedDateTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZonedDateTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleZoneId_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("z1", "z2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleZoneId, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("z1")
    out.value(in.z1)
    out.label("z2")
    out.value(in.z2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZoneId = {
    var _z1: java.time.ZoneId = null
    var _z2: java.time.ZoneId = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleZoneId_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleZoneId] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _z1 = `in₂`.expectString[java.time.ZoneId](((x$0: java.lang.String) => java.time.ZoneId.of(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("z1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _z2 = `in₂`.expectString[java.time.ZoneId](((`x$0₂`: java.lang.String) => java.time.ZoneId.of(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("z2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleZoneId_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleZoneId(_z1, _z2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("z1", "z2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZoneId] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleZoneId, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZoneId = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZoneId])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleZoneId_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("z1", "z2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleZoneId, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("z1")
    out.value(in.z1)
    out.label("z2")
    out.value(in.z2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZoneId = {
    var _z1: java.time.ZoneId = null
    var _z2: java.time.ZoneId = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleZoneId_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleZoneId] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _z1 = `in₂`.expectString[java.time.ZoneId](((x$0: java.lang.String) => java.time.ZoneId.of(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("z1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _z2 = `in₂`.expectString[java.time.ZoneId](((`x$0₂`: java.lang.String) => java.time.ZoneId.of(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("z2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleZoneId_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleZoneId(_z1, _z2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("z1", "z2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZoneId] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleZoneId, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZoneId = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZoneId])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleZoneOffset_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("z1", "z2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleZoneOffset, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("z1")
    out.value(in.z1)
    out.label("z2")
    out.value(in.z2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZoneOffset = {
    var _z1: java.time.ZoneOffset = null
    var _z2: java.time.ZoneOffset = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleZoneOffset_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleZoneOffset] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _z1 = `in₂`.expectString[java.time.ZoneOffset](((x$0: java.lang.String) => java.time.ZoneOffset.of(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("z1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _z2 = `in₂`.expectString[java.time.ZoneOffset](((`x$0₂`: java.lang.String) => java.time.ZoneOffset.of(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("z2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleZoneOffset_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleZoneOffset(_z1, _z2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("z1", "z2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZoneOffset] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleZoneOffset, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZoneOffset = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZoneOffset])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleZoneOffset_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("z1", "z2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleZoneOffset, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("z1")
    out.value(in.z1)
    out.label("z2")
    out.value(in.z2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZoneOffset = {
    var _z1: java.time.ZoneOffset = null
    var _z2: java.time.ZoneOffset = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleZoneOffset_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleZoneOffset] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _z1 = `in₂`.expectString[java.time.ZoneOffset](((x$0: java.lang.String) => java.time.ZoneOffset.of(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("z1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _z2 = `in₂`.expectString[java.time.ZoneOffset](((`x$0₂`: java.lang.String) => java.time.ZoneOffset.of(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("z2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleZoneOffset_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleZoneOffset(_z1, _z2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("z1", "z2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZoneOffset] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleZoneOffset, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZoneOffset = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZoneOffset])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleNet_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("u1", "u2", "u3", "u4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleNet, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("u1")
    out.value(in.u1)
    out.label("u2")
    out.value(in.u2)
    out.label("u3")
    out.value(in.u3)
    out.label("u4")
    out.value(in.u4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleNet = {
    var _u1: java.net.URL = null
    var _u2: java.net.URL = null
    var _u3: java.net.URI = null
    var _u4: java.net.URI = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleNet_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleNet] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _u1 = `in₂`.expectString[java.net.URL](((s: java.lang.String) => new java.net.URL(s)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _u2 = `in₂`.expectString[java.net.URL](((`s₂`: java.lang.String) => new java.net.URL(`s₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _u3 = `in₂`.expectString[java.net.URI](((`s₃`: java.lang.String) => new java.net.URI(`s₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _u4 = `in₂`.expectString[java.net.URI](((`s₄`: java.lang.String) => new java.net.URI(`s₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleNet_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleNet(_u1, _u2, _u3, _u4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("u1", "u2", "u3", "u4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleNet] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleNet, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleNet = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleNet])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleNet_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("u1", "u2", "u3", "u4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleNet, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("u1")
    out.value(in.u1)
    out.label("u2")
    out.value(in.u2)
    out.label("u3")
    out.value(in.u3)
    out.label("u4")
    out.value(in.u4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleNet = {
    var _u1: java.net.URL = null
    var _u2: java.net.URL = null
    var _u3: java.net.URI = null
    var _u4: java.net.URI = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleNet_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleNet] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _u1 = `in₂`.expectString[java.net.URL](((s: java.lang.String) => new java.net.URL(s)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _u2 = `in₂`.expectString[java.net.URL](((`s₂`: java.lang.String) => new java.net.URL(`s₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _u3 = `in₂`.expectString[java.net.URI](((`s₃`: java.lang.String) => new java.net.URI(`s₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _u4 = `in₂`.expectString[java.net.URI](((`s₄`: java.lang.String) => new java.net.URI(`s₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleNet_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleNet(_u1, _u2, _u3, _u4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("u1", "u2", "u3", "u4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleNet] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleNet, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleNet = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleNet])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleUUID_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("u1", "u2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleUUID, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("u1")
    out.value(in.u1)
    out.label("u2")
    out.value(in.u2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleUUID = {
    var _u1: java.util.UUID = null
    var _u2: java.util.UUID = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleUUID_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleUUID] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _u1 = `in₂`.expectString[java.util.UUID](((x$0: java.lang.String) => java.util.UUID.fromString(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _u2 = `in₂`.expectString[java.util.UUID](((`x$0₂`: java.lang.String) => java.util.UUID.fromString(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleUUID_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleUUID(_u1, _u2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("u1", "u2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleUUID] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleUUID, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleUUID = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleUUID])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleUUID_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("u1", "u2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleUUID, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("u1")
    out.value(in.u1)
    out.label("u2")
    out.value(in.u2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleUUID = {
    var _u1: java.util.UUID = null
    var _u2: java.util.UUID = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleUUID_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleUUID] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _u1 = `in₂`.expectString[java.util.UUID](((x$0: java.lang.String) => java.util.UUID.fromString(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _u2 = `in₂`.expectString[java.util.UUID](((`x$0₂`: java.lang.String) => java.util.UUID.fromString(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleUUID_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleUUID(_u1, _u2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("u1", "u2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleUUID] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleUUID, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleUUID = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleUUID])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleDuration_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleDuration, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleDuration = {
    var _d1: java.time.Duration = null
    var _d2: java.time.Duration = null
    var _d3: java.time.Duration = null
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleDuration_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleDuration] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectString[java.time.Duration](((x$0: java.lang.CharSequence) => java.time.Duration.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectString[java.time.Duration](((`x$0₂`: java.lang.CharSequence) => java.time.Duration.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectString[java.time.Duration](((`x$0₃`: java.lang.CharSequence) => java.time.Duration.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleDuration_fields)
      }
      if (required.&(7).==(0)) new co.blocke.scalajack.json.primitives.SampleDuration(_d1, _d2, _d3) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(7)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleDuration] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleDuration, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleDuration = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleDuration])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleDuration_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleDuration, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleDuration = {
    var _d1: java.time.Duration = null
    var _d2: java.time.Duration = null
    var _d3: java.time.Duration = null
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleDuration_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleDuration] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectString[java.time.Duration](((x$0: java.lang.CharSequence) => java.time.Duration.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectString[java.time.Duration](((`x$0₂`: java.lang.CharSequence) => java.time.Duration.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectString[java.time.Duration](((`x$0₃`: java.lang.CharSequence) => java.time.Duration.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleDuration_fields)
      }
      if (required.&(7).==(0)) new co.blocke.scalajack.json.primitives.SampleDuration(_d1, _d2, _d3) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(7)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleDuration] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleDuration, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleDuration = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleDuration])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleInstant_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4", "i5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleInstant, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("i1")
    out.value(in.i1)
    out.label("i2")
    out.value(in.i2)
    out.label("i3")
    out.value(in.i3)
    out.label("i4")
    out.value(in.i4)
    out.label("i5")
    out.value(in.i5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleInstant = {
    var _i1: java.time.Instant = null
    var _i2: java.time.Instant = null
    var _i3: java.time.Instant = null
    var _i4: java.time.Instant = null
    var _i5: java.time.Instant = null
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleInstant_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleInstant] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _i1 = `in₂`.expectString[java.time.Instant](((x$0: java.lang.CharSequence) => java.time.Instant.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _i2 = `in₂`.expectString[java.time.Instant](((`x$0₂`: java.lang.CharSequence) => java.time.Instant.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _i3 = `in₂`.expectString[java.time.Instant](((`x$0₃`: java.lang.CharSequence) => java.time.Instant.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _i4 = `in₂`.expectString[java.time.Instant](((`x$0₄`: java.lang.CharSequence) => java.time.Instant.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _i5 = `in₂`.expectString[java.time.Instant](((`x$0₅`: java.lang.CharSequence) => java.time.Instant.parse(`x$0₅`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleInstant_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleInstant(_i1, _i2, _i3, _i4, _i5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4", "i5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleInstant] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleInstant, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleInstant = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleInstant])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleInstant_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4", "i5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleInstant, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("i1")
    out.value(in.i1)
    out.label("i2")
    out.value(in.i2)
    out.label("i3")
    out.value(in.i3)
    out.label("i4")
    out.value(in.i4)
    out.label("i5")
    out.value(in.i5)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleInstant = {
    var _i1: java.time.Instant = null
    var _i2: java.time.Instant = null
    var _i3: java.time.Instant = null
    var _i4: java.time.Instant = null
    var _i5: java.time.Instant = null
    var required: scala.Int = 31
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleInstant_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleInstant] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _i1 = `in₂`.expectString[java.time.Instant](((x$0: java.lang.CharSequence) => java.time.Instant.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _i2 = `in₂`.expectString[java.time.Instant](((`x$0₂`: java.lang.CharSequence) => java.time.Instant.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _i3 = `in₂`.expectString[java.time.Instant](((`x$0₃`: java.lang.CharSequence) => java.time.Instant.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _i4 = `in₂`.expectString[java.time.Instant](((`x$0₄`: java.lang.CharSequence) => java.time.Instant.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _i5 = `in₂`.expectString[java.time.Instant](((`x$0₅`: java.lang.CharSequence) => java.time.Instant.parse(`x$0₅`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("i5"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleInstant_fields)
      }
      if (required.&(31).==(0)) new co.blocke.scalajack.json.primitives.SampleInstant(_i1, _i2, _i3, _i4, _i5) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("i1", "i2", "i3", "i4", "i5")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(31)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleInstant] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleInstant, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleInstant = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleInstant])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleLocalDateTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleLocalDateTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.label("d4")
    out.value(in.d4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalDateTime = {
    var _d1: java.time.LocalDateTime = null
    var _d2: java.time.LocalDateTime = null
    var _d3: java.time.LocalDateTime = null
    var _d4: java.time.LocalDateTime = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleLocalDateTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleLocalDateTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectString[java.time.LocalDateTime](((x$0: java.lang.CharSequence) => java.time.LocalDateTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectString[java.time.LocalDateTime](((`x$0₂`: java.lang.CharSequence) => java.time.LocalDateTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectString[java.time.LocalDateTime](((`x$0₃`: java.lang.CharSequence) => java.time.LocalDateTime.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _d4 = `in₂`.expectString[java.time.LocalDateTime](((`x$0₄`: java.lang.CharSequence) => java.time.LocalDateTime.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleLocalDateTime_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleLocalDateTime(_d1, _d2, _d3, _d4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalDateTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleLocalDateTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalDateTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalDateTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleLocalDateTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleLocalDateTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.label("d4")
    out.value(in.d4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalDateTime = {
    var _d1: java.time.LocalDateTime = null
    var _d2: java.time.LocalDateTime = null
    var _d3: java.time.LocalDateTime = null
    var _d4: java.time.LocalDateTime = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleLocalDateTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleLocalDateTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectString[java.time.LocalDateTime](((x$0: java.lang.CharSequence) => java.time.LocalDateTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectString[java.time.LocalDateTime](((`x$0₂`: java.lang.CharSequence) => java.time.LocalDateTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectString[java.time.LocalDateTime](((`x$0₃`: java.lang.CharSequence) => java.time.LocalDateTime.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _d4 = `in₂`.expectString[java.time.LocalDateTime](((`x$0₄`: java.lang.CharSequence) => java.time.LocalDateTime.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleLocalDateTime_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleLocalDateTime(_d1, _d2, _d3, _d4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalDateTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleLocalDateTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalDateTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalDateTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleLocalDate_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleLocalDate, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.label("d4")
    out.value(in.d4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalDate = {
    var _d1: java.time.LocalDate = null
    var _d2: java.time.LocalDate = null
    var _d3: java.time.LocalDate = null
    var _d4: java.time.LocalDate = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleLocalDate_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleLocalDate] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectString[java.time.LocalDate](((x$0: java.lang.CharSequence) => java.time.LocalDate.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectString[java.time.LocalDate](((`x$0₂`: java.lang.CharSequence) => java.time.LocalDate.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectString[java.time.LocalDate](((`x$0₃`: java.lang.CharSequence) => java.time.LocalDate.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _d4 = `in₂`.expectString[java.time.LocalDate](((`x$0₄`: java.lang.CharSequence) => java.time.LocalDate.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleLocalDate_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleLocalDate(_d1, _d2, _d3, _d4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalDate] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleLocalDate, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalDate = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalDate])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleLocalDate_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleLocalDate, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.label("d4")
    out.value(in.d4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalDate = {
    var _d1: java.time.LocalDate = null
    var _d2: java.time.LocalDate = null
    var _d3: java.time.LocalDate = null
    var _d4: java.time.LocalDate = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleLocalDate_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleLocalDate] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectString[java.time.LocalDate](((x$0: java.lang.CharSequence) => java.time.LocalDate.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectString[java.time.LocalDate](((`x$0₂`: java.lang.CharSequence) => java.time.LocalDate.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectString[java.time.LocalDate](((`x$0₃`: java.lang.CharSequence) => java.time.LocalDate.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _d4 = `in₂`.expectString[java.time.LocalDate](((`x$0₄`: java.lang.CharSequence) => java.time.LocalDate.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleLocalDate_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleLocalDate(_d1, _d2, _d3, _d4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalDate] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleLocalDate, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalDate = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalDate])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleLocalTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4", "d5", "d6")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleLocalTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.label("d4")
    out.value(in.d4)
    out.label("d5")
    out.value(in.d5)
    out.label("d6")
    out.value(in.d6)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalTime = {
    var _d1: java.time.LocalTime = null
    var _d2: java.time.LocalTime = null
    var _d3: java.time.LocalTime = null
    var _d4: java.time.LocalTime = null
    var _d5: java.time.LocalTime = null
    var _d6: java.time.LocalTime = null
    var required: scala.Int = 63
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleLocalTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleLocalTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectString[java.time.LocalTime](((x$0: java.lang.CharSequence) => java.time.LocalTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectString[java.time.LocalTime](((`x$0₂`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectString[java.time.LocalTime](((`x$0₃`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _d4 = `in₂`.expectString[java.time.LocalTime](((`x$0₄`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _d5 = `in₂`.expectString[java.time.LocalTime](((`x$0₅`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₅`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d5"), `in₂`)
          case 5 =>
            if (required.&(32).!=(0)) {
              required = required.^(32)
              _d6 = `in₂`.expectString[java.time.LocalTime](((`x$0₆`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₆`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d6"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleLocalTime_fields)
      }
      if (required.&(63).==(0)) new co.blocke.scalajack.json.primitives.SampleLocalTime(_d1, _d2, _d3, _d4, _d5, _d6) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4", "d5", "d6")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(63)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleLocalTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleLocalTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4", "d5", "d6")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleLocalTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("d1")
    out.value(in.d1)
    out.label("d2")
    out.value(in.d2)
    out.label("d3")
    out.value(in.d3)
    out.label("d4")
    out.value(in.d4)
    out.label("d5")
    out.value(in.d5)
    out.label("d6")
    out.value(in.d6)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalTime = {
    var _d1: java.time.LocalTime = null
    var _d2: java.time.LocalTime = null
    var _d3: java.time.LocalTime = null
    var _d4: java.time.LocalTime = null
    var _d5: java.time.LocalTime = null
    var _d6: java.time.LocalTime = null
    var required: scala.Int = 63
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleLocalTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleLocalTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _d1 = `in₂`.expectString[java.time.LocalTime](((x$0: java.lang.CharSequence) => java.time.LocalTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _d2 = `in₂`.expectString[java.time.LocalTime](((`x$0₂`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _d3 = `in₂`.expectString[java.time.LocalTime](((`x$0₃`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _d4 = `in₂`.expectString[java.time.LocalTime](((`x$0₄`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d4"), `in₂`)
          case 4 =>
            if (required.&(16).!=(0)) {
              required = required.^(16)
              _d5 = `in₂`.expectString[java.time.LocalTime](((`x$0₅`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₅`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d5"), `in₂`)
          case 5 =>
            if (required.&(32).!=(0)) {
              required = required.^(32)
              _d6 = `in₂`.expectString[java.time.LocalTime](((`x$0₆`: java.lang.CharSequence) => java.time.LocalTime.parse(`x$0₆`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("d6"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleLocalTime_fields)
      }
      if (required.&(63).==(0)) new co.blocke.scalajack.json.primitives.SampleLocalTime(_d1, _d2, _d3, _d4, _d5, _d6) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("d1", "d2", "d3", "d4", "d5", "d6")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(63)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleLocalTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleLocalTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleLocalTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleMonthDay_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("m1", "m2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleMonthDay, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("m1")
    out.value(in.m1)
    out.label("m2")
    out.value(in.m2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleMonthDay = {
    var _m1: java.time.MonthDay = null
    var _m2: java.time.MonthDay = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleMonthDay_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleMonthDay] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _m1 = `in₂`.expectString[java.time.MonthDay](((x$0: java.lang.CharSequence) => java.time.MonthDay.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("m1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _m2 = `in₂`.expectString[java.time.MonthDay](((`x$0₂`: java.lang.CharSequence) => java.time.MonthDay.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("m2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleMonthDay_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleMonthDay(_m1, _m2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("m1", "m2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleMonthDay] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleMonthDay, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleMonthDay = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleMonthDay])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleMonthDay_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("m1", "m2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleMonthDay, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("m1")
    out.value(in.m1)
    out.label("m2")
    out.value(in.m2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleMonthDay = {
    var _m1: java.time.MonthDay = null
    var _m2: java.time.MonthDay = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleMonthDay_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleMonthDay] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _m1 = `in₂`.expectString[java.time.MonthDay](((x$0: java.lang.CharSequence) => java.time.MonthDay.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("m1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _m2 = `in₂`.expectString[java.time.MonthDay](((`x$0₂`: java.lang.CharSequence) => java.time.MonthDay.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("m2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleMonthDay_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleMonthDay(_m1, _m2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("m1", "m2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleMonthDay] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleMonthDay, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleMonthDay = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleMonthDay])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleOffsetDateTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("o1", "o2", "o3", "o4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleOffsetDateTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("o1")
    out.value(in.o1)
    out.label("o2")
    out.value(in.o2)
    out.label("o3")
    out.value(in.o3)
    out.label("o4")
    out.value(in.o4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleOffsetDateTime = {
    var _o1: java.time.OffsetDateTime = null
    var _o2: java.time.OffsetDateTime = null
    var _o3: java.time.OffsetDateTime = null
    var _o4: java.time.OffsetDateTime = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleOffsetDateTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleOffsetDateTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _o1 = `in₂`.expectString[java.time.OffsetDateTime](((x$0: java.lang.CharSequence) => java.time.OffsetDateTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _o2 = `in₂`.expectString[java.time.OffsetDateTime](((`x$0₂`: java.lang.CharSequence) => java.time.OffsetDateTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _o3 = `in₂`.expectString[java.time.OffsetDateTime](((`x$0₃`: java.lang.CharSequence) => java.time.OffsetDateTime.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _o4 = `in₂`.expectString[java.time.OffsetDateTime](((`x$0₄`: java.lang.CharSequence) => java.time.OffsetDateTime.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleOffsetDateTime_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleOffsetDateTime(_o1, _o2, _o3, _o4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("o1", "o2", "o3", "o4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleOffsetDateTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleOffsetDateTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleOffsetDateTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleOffsetDateTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleOffsetDateTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("o1", "o2", "o3", "o4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleOffsetDateTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("o1")
    out.value(in.o1)
    out.label("o2")
    out.value(in.o2)
    out.label("o3")
    out.value(in.o3)
    out.label("o4")
    out.value(in.o4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleOffsetDateTime = {
    var _o1: java.time.OffsetDateTime = null
    var _o2: java.time.OffsetDateTime = null
    var _o3: java.time.OffsetDateTime = null
    var _o4: java.time.OffsetDateTime = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleOffsetDateTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleOffsetDateTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _o1 = `in₂`.expectString[java.time.OffsetDateTime](((x$0: java.lang.CharSequence) => java.time.OffsetDateTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _o2 = `in₂`.expectString[java.time.OffsetDateTime](((`x$0₂`: java.lang.CharSequence) => java.time.OffsetDateTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _o3 = `in₂`.expectString[java.time.OffsetDateTime](((`x$0₃`: java.lang.CharSequence) => java.time.OffsetDateTime.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _o4 = `in₂`.expectString[java.time.OffsetDateTime](((`x$0₄`: java.lang.CharSequence) => java.time.OffsetDateTime.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleOffsetDateTime_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleOffsetDateTime(_o1, _o2, _o3, _o4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("o1", "o2", "o3", "o4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleOffsetDateTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleOffsetDateTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleOffsetDateTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleOffsetDateTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleOffsetTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("o1", "o2", "o3", "o4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleOffsetTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("o1")
    out.value(in.o1)
    out.label("o2")
    out.value(in.o2)
    out.label("o3")
    out.value(in.o3)
    out.label("o4")
    out.value(in.o4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleOffsetTime = {
    var _o1: java.time.OffsetTime = null
    var _o2: java.time.OffsetTime = null
    var _o3: java.time.OffsetTime = null
    var _o4: java.time.OffsetTime = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleOffsetTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleOffsetTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _o1 = `in₂`.expectString[java.time.OffsetTime](((x$0: java.lang.CharSequence) => java.time.OffsetTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _o2 = `in₂`.expectString[java.time.OffsetTime](((`x$0₂`: java.lang.CharSequence) => java.time.OffsetTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _o3 = `in₂`.expectString[java.time.OffsetTime](((`x$0₃`: java.lang.CharSequence) => java.time.OffsetTime.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _o4 = `in₂`.expectString[java.time.OffsetTime](((`x$0₄`: java.lang.CharSequence) => java.time.OffsetTime.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleOffsetTime_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleOffsetTime(_o1, _o2, _o3, _o4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("o1", "o2", "o3", "o4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleOffsetTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleOffsetTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleOffsetTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleOffsetTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleOffsetTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("o1", "o2", "o3", "o4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleOffsetTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("o1")
    out.value(in.o1)
    out.label("o2")
    out.value(in.o2)
    out.label("o3")
    out.value(in.o3)
    out.label("o4")
    out.value(in.o4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleOffsetTime = {
    var _o1: java.time.OffsetTime = null
    var _o2: java.time.OffsetTime = null
    var _o3: java.time.OffsetTime = null
    var _o4: java.time.OffsetTime = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleOffsetTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleOffsetTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _o1 = `in₂`.expectString[java.time.OffsetTime](((x$0: java.lang.CharSequence) => java.time.OffsetTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _o2 = `in₂`.expectString[java.time.OffsetTime](((`x$0₂`: java.lang.CharSequence) => java.time.OffsetTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _o3 = `in₂`.expectString[java.time.OffsetTime](((`x$0₃`: java.lang.CharSequence) => java.time.OffsetTime.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _o4 = `in₂`.expectString[java.time.OffsetTime](((`x$0₄`: java.lang.CharSequence) => java.time.OffsetTime.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleOffsetTime_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleOffsetTime(_o1, _o2, _o3, _o4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("o1", "o2", "o3", "o4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleOffsetTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleOffsetTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleOffsetTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleOffsetTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SamplePeriod_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("p1", "p2", "p3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SamplePeriod, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("p1")
    out.value(in.p1)
    out.label("p2")
    out.value(in.p2)
    out.label("p3")
    out.value(in.p3)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SamplePeriod = {
    var _p1: java.time.Period = null
    var _p2: java.time.Period = null
    var _p3: java.time.Period = null
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SamplePeriod_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SamplePeriod] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _p1 = `in₂`.expectString[java.time.Period](((x$0: java.lang.CharSequence) => java.time.Period.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("p1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _p2 = `in₂`.expectString[java.time.Period](((`x$0₂`: java.lang.CharSequence) => java.time.Period.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("p2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _p3 = `in₂`.expectString[java.time.Period](((`x$0₃`: java.lang.CharSequence) => java.time.Period.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("p3"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SamplePeriod_fields)
      }
      if (required.&(7).==(0)) new co.blocke.scalajack.json.primitives.SamplePeriod(_p1, _p2, _p3) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("p1", "p2", "p3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(7)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SamplePeriod] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SamplePeriod, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SamplePeriod = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SamplePeriod])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SamplePeriod_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("p1", "p2", "p3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SamplePeriod, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("p1")
    out.value(in.p1)
    out.label("p2")
    out.value(in.p2)
    out.label("p3")
    out.value(in.p3)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SamplePeriod = {
    var _p1: java.time.Period = null
    var _p2: java.time.Period = null
    var _p3: java.time.Period = null
    var required: scala.Int = 7
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SamplePeriod_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SamplePeriod] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _p1 = `in₂`.expectString[java.time.Period](((x$0: java.lang.CharSequence) => java.time.Period.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("p1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _p2 = `in₂`.expectString[java.time.Period](((`x$0₂`: java.lang.CharSequence) => java.time.Period.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("p2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _p3 = `in₂`.expectString[java.time.Period](((`x$0₃`: java.lang.CharSequence) => java.time.Period.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("p3"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SamplePeriod_fields)
      }
      if (required.&(7).==(0)) new co.blocke.scalajack.json.primitives.SamplePeriod(_p1, _p2, _p3) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("p1", "p2", "p3")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(7)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SamplePeriod] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SamplePeriod, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SamplePeriod = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SamplePeriod])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleYear_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("y1", "y2", "y3", "y4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleYear, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("y1")
    out.value(in.y1)
    out.label("y2")
    out.value(in.y2)
    out.label("y3")
    out.value(in.y3)
    out.label("y4")
    out.value(in.y4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleYear = {
    var _y1: java.time.Year = null
    var _y2: java.time.Year = null
    var _y3: java.time.Year = null
    var _y4: java.time.Year = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleYear_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleYear] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _y1 = `in₂`.expectString[java.time.Year](((x$0: java.lang.CharSequence) => java.time.Year.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _y2 = `in₂`.expectString[java.time.Year](((`x$0₂`: java.lang.CharSequence) => java.time.Year.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _y3 = `in₂`.expectString[java.time.Year](((`x$0₃`: java.lang.CharSequence) => java.time.Year.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _y4 = `in₂`.expectString[java.time.Year](((`x$0₄`: java.lang.CharSequence) => java.time.Year.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleYear_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleYear(_y1, _y2, _y3, _y4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("y1", "y2", "y3", "y4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleYear] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleYear, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleYear = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleYear])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleYear_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("y1", "y2", "y3", "y4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleYear, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("y1")
    out.value(in.y1)
    out.label("y2")
    out.value(in.y2)
    out.label("y3")
    out.value(in.y3)
    out.label("y4")
    out.value(in.y4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleYear = {
    var _y1: java.time.Year = null
    var _y2: java.time.Year = null
    var _y3: java.time.Year = null
    var _y4: java.time.Year = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleYear_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleYear] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _y1 = `in₂`.expectString[java.time.Year](((x$0: java.lang.CharSequence) => java.time.Year.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _y2 = `in₂`.expectString[java.time.Year](((`x$0₂`: java.lang.CharSequence) => java.time.Year.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _y3 = `in₂`.expectString[java.time.Year](((`x$0₃`: java.lang.CharSequence) => java.time.Year.parse(`x$0₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _y4 = `in₂`.expectString[java.time.Year](((`x$0₄`: java.lang.CharSequence) => java.time.Year.parse(`x$0₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleYear_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleYear(_y1, _y2, _y3, _y4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("y1", "y2", "y3", "y4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleYear] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleYear, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleYear = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleYear])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleYearMonth_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("y1", "y2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleYearMonth, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("y1")
    out.value(in.y1)
    out.label("y2")
    out.value(in.y2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleYearMonth = {
    var _y1: java.time.YearMonth = null
    var _y2: java.time.YearMonth = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleYearMonth_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleYearMonth] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _y1 = `in₂`.expectString[java.time.YearMonth](((x$0: java.lang.CharSequence) => java.time.YearMonth.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _y2 = `in₂`.expectString[java.time.YearMonth](((`x$0₂`: java.lang.CharSequence) => java.time.YearMonth.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleYearMonth_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleYearMonth(_y1, _y2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("y1", "y2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleYearMonth] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleYearMonth, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleYearMonth = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleYearMonth])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleYearMonth_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("y1", "y2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleYearMonth, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("y1")
    out.value(in.y1)
    out.label("y2")
    out.value(in.y2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleYearMonth = {
    var _y1: java.time.YearMonth = null
    var _y2: java.time.YearMonth = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleYearMonth_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleYearMonth] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _y1 = `in₂`.expectString[java.time.YearMonth](((x$0: java.lang.CharSequence) => java.time.YearMonth.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _y2 = `in₂`.expectString[java.time.YearMonth](((`x$0₂`: java.lang.CharSequence) => java.time.YearMonth.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("y2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleYearMonth_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleYearMonth(_y1, _y2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("y1", "y2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleYearMonth] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleYearMonth, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleYearMonth = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleYearMonth])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleZoneId_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("z1", "z2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleZoneId, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("z1")
    out.value(in.z1)
    out.label("z2")
    out.value(in.z2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZoneId = {
    var _z1: java.time.ZoneId = null
    var _z2: java.time.ZoneId = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleZoneId_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleZoneId] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _z1 = `in₂`.expectString[java.time.ZoneId](((x$0: java.lang.String) => java.time.ZoneId.of(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("z1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _z2 = `in₂`.expectString[java.time.ZoneId](((`x$0₂`: java.lang.String) => java.time.ZoneId.of(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("z2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleZoneId_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleZoneId(_z1, _z2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("z1", "z2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZoneId] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleZoneId, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZoneId = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZoneId])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleZoneId_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("z1", "z2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleZoneId, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("z1")
    out.value(in.z1)
    out.label("z2")
    out.value(in.z2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZoneId = {
    var _z1: java.time.ZoneId = null
    var _z2: java.time.ZoneId = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleZoneId_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleZoneId] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _z1 = `in₂`.expectString[java.time.ZoneId](((x$0: java.lang.String) => java.time.ZoneId.of(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("z1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _z2 = `in₂`.expectString[java.time.ZoneId](((`x$0₂`: java.lang.String) => java.time.ZoneId.of(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("z2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleZoneId_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleZoneId(_z1, _z2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("z1", "z2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZoneId] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleZoneId, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZoneId = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZoneId])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleZonedDateTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("o1", "o2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleZonedDateTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("o1")
    out.value(in.o1)
    out.label("o2")
    out.value(in.o2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZonedDateTime = {
    var _o1: java.time.ZonedDateTime = null
    var _o2: java.time.ZonedDateTime = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleZonedDateTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleZonedDateTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _o1 = `in₂`.expectString[java.time.ZonedDateTime](((x$0: java.lang.CharSequence) => java.time.ZonedDateTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _o2 = `in₂`.expectString[java.time.ZonedDateTime](((`x$0₂`: java.lang.CharSequence) => java.time.ZonedDateTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleZonedDateTime_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleZonedDateTime(_o1, _o2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("o1", "o2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZonedDateTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleZonedDateTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZonedDateTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZonedDateTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleZonedDateTime_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("o1", "o2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleZonedDateTime, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("o1")
    out.value(in.o1)
    out.label("o2")
    out.value(in.o2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZonedDateTime = {
    var _o1: java.time.ZonedDateTime = null
    var _o2: java.time.ZonedDateTime = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleZonedDateTime_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleZonedDateTime] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _o1 = `in₂`.expectString[java.time.ZonedDateTime](((x$0: java.lang.CharSequence) => java.time.ZonedDateTime.parse(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _o2 = `in₂`.expectString[java.time.ZonedDateTime](((`x$0₂`: java.lang.CharSequence) => java.time.ZonedDateTime.parse(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("o2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleZonedDateTime_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleZonedDateTime(_o1, _o2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("o1", "o2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZonedDateTime] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleZonedDateTime, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleZonedDateTime = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleZonedDateTime])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleNet_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("u1", "u2", "u3", "u4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleNet, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("u1")
    out.value(in.u1)
    out.label("u2")
    out.value(in.u2)
    out.label("u3")
    out.value(in.u3)
    out.label("u4")
    out.value(in.u4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleNet = {
    var _u1: java.net.URL = null
    var _u2: java.net.URL = null
    var _u3: java.net.URI = null
    var _u4: java.net.URI = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleNet_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleNet] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _u1 = `in₂`.expectString[java.net.URL](((s: java.lang.String) => new java.net.URL(s)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _u2 = `in₂`.expectString[java.net.URL](((`s₂`: java.lang.String) => new java.net.URL(`s₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _u3 = `in₂`.expectString[java.net.URI](((`s₃`: java.lang.String) => new java.net.URI(`s₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _u4 = `in₂`.expectString[java.net.URI](((`s₄`: java.lang.String) => new java.net.URI(`s₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleNet_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleNet(_u1, _u2, _u3, _u4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("u1", "u2", "u3", "u4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleNet] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleNet, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleNet = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleNet])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleNet_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("u1", "u2", "u3", "u4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleNet, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("u1")
    out.value(in.u1)
    out.label("u2")
    out.value(in.u2)
    out.label("u3")
    out.value(in.u3)
    out.label("u4")
    out.value(in.u4)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleNet = {
    var _u1: java.net.URL = null
    var _u2: java.net.URL = null
    var _u3: java.net.URI = null
    var _u4: java.net.URI = null
    var required: scala.Int = 15
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleNet_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleNet] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _u1 = `in₂`.expectString[java.net.URL](((s: java.lang.String) => new java.net.URL(s)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _u2 = `in₂`.expectString[java.net.URL](((`s₂`: java.lang.String) => new java.net.URL(`s₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u2"), `in₂`)
          case 2 =>
            if (required.&(4).!=(0)) {
              required = required.^(4)
              _u3 = `in₂`.expectString[java.net.URI](((`s₃`: java.lang.String) => new java.net.URI(`s₃`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u3"), `in₂`)
          case 3 =>
            if (required.&(8).!=(0)) {
              required = required.^(8)
              _u4 = `in₂`.expectString[java.net.URI](((`s₄`: java.lang.String) => new java.net.URI(`s₄`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u4"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleNet_fields)
      }
      if (required.&(15).==(0)) new co.blocke.scalajack.json.primitives.SampleNet(_u1, _u2, _u3, _u4) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("u1", "u2", "u3", "u4")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(15)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleNet] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleNet, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleNet = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleNet])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleUUID_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("u1", "u2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleUUID, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("u1")
    out.value(in.u1)
    out.label("u2")
    out.value(in.u2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleUUID = {
    var _u1: java.util.UUID = null
    var _u2: java.util.UUID = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleUUID_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleUUID] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _u1 = `in₂`.expectString[java.util.UUID](((x$0: java.lang.String) => java.util.UUID.fromString(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _u2 = `in₂`.expectString[java.util.UUID](((`x$0₂`: java.lang.String) => java.util.UUID.fromString(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleUUID_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleUUID(_u1, _u2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("u1", "u2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleUUID] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleUUID, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleUUID = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleUUID])
}
Codec: {
  val __co_blocke_scalajack_json_primitives_SampleUUID_fields: co.blocke.scalajack.json.StringMatrix = new co.blocke.scalajack.json.StringMatrix(scala.Array.apply[java.lang.String]("u1", "u2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])))
  def w0(in: co.blocke.scalajack.json.primitives.SampleUUID, out: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = if (in.==(null)) out.burpNull() else {
    out.startObject()
    out.label("u1")
    out.value(in.u1)
    out.label("u2")
    out.value(in.u2)
    out.endObject()
  }
  def r0(`in₂`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleUUID = {
    var _u1: java.util.UUID = null
    var _u2: java.util.UUID = null
    var required: scala.Int = 3
    var maybeFieldNum: scala.Option[scala.Int] = `in₂`.expectFirstObjectField(__co_blocke_scalajack_json_primitives_SampleUUID_fields)
    if (maybeFieldNum.==(null)) null.asInstanceOf[co.blocke.scalajack.json.primitives.SampleUUID] else {
      while (maybeFieldNum.isDefined) {
        maybeFieldNum.get match {
          case 0 =>
            if (required.&(1).!=(0)) {
              required = required.^(1)
              _u1 = `in₂`.expectString[java.util.UUID](((x$0: java.lang.String) => java.util.UUID.fromString(x$0)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u1"), `in₂`)
          case 1 =>
            if (required.&(2).!=(0)) {
              required = required.^(2)
              _u2 = `in₂`.expectString[java.util.UUID](((`x$0₂`: java.lang.String) => java.util.UUID.fromString(`x$0₂`)))
            } else throw new co.blocke.scalajack.json.JsonParseError("Duplicate field ".+("u2"), `in₂`)
          case _ =>
            `in₂`.skipValue()
        }
        maybeFieldNum = `in₂`.expectObjectField(__co_blocke_scalajack_json_primitives_SampleUUID_fields)
      }
      if (required.&(3).==(0)) new co.blocke.scalajack.json.primitives.SampleUUID(_u1, _u2) else throw new co.blocke.scalajack.json.JsonParseError("Missing required field(s) ".+(scala.Array.apply[java.lang.String]("u1", "u2")(scala.reflect.ClassTag.apply[java.lang.String](scala.Predef.classOf[java.lang.String])).apply(java.lang.Integer.numberOfTrailingZeros(required.&(3)))), `in₂`)
    }
  }
  final class $anon() extends co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleUUID] {
    def encodeValue(`in₃`: co.blocke.scalajack.json.primitives.SampleUUID, `out₂`: co.blocke.scalajack.json.writing.JsonOutput): scala.Unit = w0(`in₃`, `out₂`)
    def decodeValue(`in₄`: co.blocke.scalajack.json.reading.JsonSource): co.blocke.scalajack.json.primitives.SampleUUID = r0(`in₄`)
  }

  (new $anon(): co.blocke.scalajack.json.JsonCodec[co.blocke.scalajack.json.primitives.SampleUUID])
}
[info] done compiling
[info] JavaCollSpec:
[info] -------------------------------
[info] :    Java Collection Tests    :
[info] -------------------------------
[info]   +++ Basic functions (Set) +++
[info]   - Set is null must work
[info]   - Set of numeric must work
[info]   - Set of string must work
[info]   - Set of boolean must work
[info]   - Set of Set (nested) must work *** FAILED ***
[info]     java.lang.ClassCastException: class java.util.TreeSet cannot be cast to class java.lang.Comparable (java.util.TreeSet and java.lang.Comparable are in module java.base of loader 'bootstrap')
[info]     at java.base/java.util.TreeMap.compare(TreeMap.java:1569)
[info]     at java.base/java.util.TreeMap.addEntryToEmptyMap(TreeMap.java:776)
[info]     at java.base/java.util.TreeMap.put(TreeMap.java:785)
[info]     at java.base/java.util.TreeMap.put(TreeMap.java:534)
[info]     at java.base/java.util.TreeSet.add(TreeSet.java:255)
[info]     at java.base/java.util.AbstractCollection.addAll(AbstractCollection.java:338)
[info]     at java.base/java.util.TreeSet.addAll(TreeSet.java:309)
[info]     at java.base/java.util.TreeSet.<init>(TreeSet.java:160)
[info]     at co.blocke.scalajack.json.collections.JavaCollSpec.co$blocke$scalajack$json$collections$JavaCollSpec$$_$_$r0$5(JavaCollSpec.scala:61)
[info]     at co.blocke.scalajack.json.collections.JavaCollSpec$$anon$6.decodeValue(JavaCollSpec.scala:61)
[info]     ...
[info]   - Set of either must work *** FAILED ***
[info]     java.lang.ClassCastException: class scala.util.Right cannot be cast to class java.lang.Comparable (scala.util.Right is in unnamed module of loader sbt.internal.ScalaLibraryClassLoader @34e01d38; java.lang.Comparable is in module java.base of loader 'bootstrap')
[info]     at java.base/java.util.TreeMap.compare(TreeMap.java:1569)
[info]     at java.base/java.util.TreeMap.addEntryToEmptyMap(TreeMap.java:776)
[info]     at java.base/java.util.TreeMap.put(TreeMap.java:785)
[info]     at java.base/java.util.TreeMap.put(TreeMap.java:534)
[info]     at java.base/java.util.TreeSet.add(TreeSet.java:255)
[info]     at java.base/java.util.AbstractCollection.addAll(AbstractCollection.java:338)
[info]     at java.base/java.util.TreeSet.addAll(TreeSet.java:309)
[info]     at java.base/java.util.TreeSet.<init>(TreeSet.java:160)
[info]     at co.blocke.scalajack.json.collections.JavaCollSpec.co$blocke$scalajack$json$collections$JavaCollSpec$$_$_$r0$6(JavaCollSpec.scala:68)
[info]     at co.blocke.scalajack.json.collections.JavaCollSpec$$anon$7.decodeValue(JavaCollSpec.scala:68)
[info]     ...
[info]   - Set of union must work *** FAILED ***
[info]     java.lang.ClassCastException: class java.lang.Boolean cannot be cast to class java.lang.Integer (java.lang.Boolean and java.lang.Integer are in module java.base of loader 'bootstrap')
[info]     at java.base/java.lang.Integer.compareTo(Integer.java:72)
[info]     at java.base/java.util.TreeMap.put(TreeMap.java:814)
[info]     at java.base/java.util.TreeMap.put(TreeMap.java:534)
[info]     at java.base/java.util.TreeSet.add(TreeSet.java:255)
[info]     at java.base/java.util.AbstractCollection.addAll(AbstractCollection.java:338)
[info]     at java.base/java.util.TreeSet.addAll(TreeSet.java:309)
[info]     at java.base/java.util.TreeSet.<init>(TreeSet.java:160)
[info]     at co.blocke.scalajack.json.collections.JavaCollSpec.co$blocke$scalajack$json$collections$JavaCollSpec$$_$_$r0$7(JavaCollSpec.scala:75)
[info]     at co.blocke.scalajack.json.collections.JavaCollSpec$$anon$8.decodeValue(JavaCollSpec.scala:75)
[info]     at co.blocke.scalajack.json.collections.JavaCollSpec$$anon$8.decodeValue(JavaCollSpec.scala:75)
[info]     ...
[info]   - Set of option must work *** FAILED ***
[info]     java.lang.ClassCastException: class scala.Some cannot be cast to class java.lang.Comparable (scala.Some is in unnamed module of loader sbt.internal.ScalaLibraryClassLoader @34e01d38; java.lang.Comparable is in module java.base of loader 'bootstrap')
[info]     at java.base/java.util.TreeMap.compare(TreeMap.java:1569)
[info]     at java.base/java.util.TreeMap.addEntryToEmptyMap(TreeMap.java:776)
[info]     at java.base/java.util.TreeMap.put(TreeMap.java:785)
[info]     at java.base/java.util.TreeMap.put(TreeMap.java:534)
[info]     at java.base/java.util.TreeSet.add(TreeSet.java:255)
[info]     at java.base/java.util.AbstractCollection.addAll(AbstractCollection.java:338)
[info]     at java.base/java.util.TreeSet.addAll(TreeSet.java:309)
[info]     at java.base/java.util.TreeSet.<init>(TreeSet.java:160)
[info]     at co.blocke.scalajack.json.collections.JavaCollSpec.co$blocke$scalajack$json$collections$JavaCollSpec$$_$_$r0$8(JavaCollSpec.scala:82)
[info]     at co.blocke.scalajack.json.collections.JavaCollSpec$$anon$9.decodeValue(JavaCollSpec.scala:82)
[info]     ...
[info]   - Set of map must work *** FAILED ***
[info]     java.lang.ClassCastException: class scala.collection.immutable.Map$Map2 cannot be cast to class java.lang.Comparable (scala.collection.immutable.Map$Map2 is in unnamed module of loader sbt.internal.ScalaLibraryClassLoader @34e01d38; java.lang.Comparable is in module java.base of loader 'bootstrap')
[info]     at java.base/java.util.TreeMap.compare(TreeMap.java:1569)
[info]     at java.base/java.util.TreeMap.addEntryToEmptyMap(TreeMap.java:776)
[info]     at java.base/java.util.TreeMap.put(TreeMap.java:785)
[info]     at java.base/java.util.TreeMap.put(TreeMap.java:534)
[info]     at java.base/java.util.TreeSet.add(TreeSet.java:255)
[info]     at java.base/java.util.AbstractCollection.addAll(AbstractCollection.java:338)
[info]     at java.base/java.util.TreeSet.addAll(TreeSet.java:309)
[info]     at java.base/java.util.TreeSet.<init>(TreeSet.java:160)
[info]     at co.blocke.scalajack.json.collections.JavaCollSpec.co$blocke$scalajack$json$collections$JavaCollSpec$$_$_$r0$9(JavaCollSpec.scala:89)
[info]     at co.blocke.scalajack.json.collections.JavaCollSpec$$anon$10.decodeValue(JavaCollSpec.scala:89)
[info]     ...
[info]   - Set of class must work *** FAILED ***
[info]     java.lang.ClassCastException: class co.blocke.scalajack.json.collections.Person cannot be cast to class java.lang.Comparable (co.blocke.scalajack.json.collections.Person is in unnamed module of loader sbt.internal.LayeredClassLoader @2aa03814; java.lang.Comparable is in module java.base of loader 'bootstrap')
[info]     at java.base/java.util.TreeMap.compare(TreeMap.java:1569)
[info]     at java.base/java.util.TreeMap.addEntryToEmptyMap(TreeMap.java:776)
[info]     at java.base/java.util.TreeMap.put(TreeMap.java:785)
[info]     at java.base/java.util.TreeMap.put(TreeMap.java:534)
[info]     at java.base/java.util.TreeSet.add(TreeSet.java:255)
[info]     at java.base/java.util.AbstractCollection.addAll(AbstractCollection.java:338)
[info]     at java.base/java.util.TreeSet.addAll(TreeSet.java:309)
[info]     at java.base/java.util.TreeSet.<init>(TreeSet.java:160)
[info]     at co.blocke.scalajack.json.collections.JavaCollSpec.co$blocke$scalajack$json$collections$JavaCollSpec$$_$_$r0$10(JavaCollSpec.scala:96)
[info]     at co.blocke.scalajack.json.collections.JavaCollSpec$$anon$11.decodeValue(JavaCollSpec.scala:96)
[info]     ...
[info]   +++ Basic functions (ArrayList) +++
[info]   - ArrayList is null must work
[info]   - ArrayList of numeric must work
[info]   - ArrayList of string must work
[info]   - ArrayList of boolean must work
[info]   - ArrayList of ArrayList (nested) must work
[info]   - ArrayList of either must work
[info]   - ArrayList of union must work
[info]   - ArrayList of option must work
[info]   - ArrayList of map must work
[info]   - ArrayList of class must work
[info]   +++ Coersions (special cases, traits, etc) +++
[info]   - ArrayBlockingQueue
[info]   - TreeSet
[info]   - Stack (pending)
[info]   - List (pending)
[info]   - Iterable (pending)
[info]   - Queue (pending)
[info]   - SortedSet (pending)
[info]   - Deque (pending)
[info]   - BlockingQueue (pending)
[info]   - Vector (generic Collection example) (pending)
[info] Run completed in 180 milliseconds.
[info] Total number of tests run: 22
[info] Suites: completed 1, aborted 0
[info] Tests: succeeded 16, failed 6, canceled 0, ignored 0, pending 8
[info] *** 6 TESTS FAILED ***
[error] Failed tests:
[error] 	co.blocke.scalajack.json.collections.JavaCollSpec
[error] (Test / testOnly) sbt.TestsFailedException: Tests unsuccessful
[error] Total time: 22 s, completed Apr 6, 2024, 11:44:32 PM
